<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to write a manifold ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="example.html">How to write a manifold</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#manifold-tutorial-prel"><span>Technical preliminaries</span></a></li><li><a class="tocitem" href="#manifold-tutorial-startup"><span>Startup</span></a></li><li><a class="tocitem" href="#manifold-tutorial-task"><span>The manifold</span></a></li><li><a class="tocitem" href="#manifold-tutorial-checks"><span>Checking points and tangents</span></a></li><li><a class="tocitem" href="#manifold-tutorial-fn"><span>Functions on the manifold</span></a></li><li><a class="tocitem" href="#manifold-tutorial-emb"><span>Adding an isometric embedding</span></a></li><li><a class="tocitem" href="#manifold-tutorial-outlook"><span>Conclusion</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="manifold_type.html">The manifold type</a></li><li><span class="tocitem">Functions on Maniolds</span><ul><li><a class="tocitem" href="functions.html">Basic functions</a></li><li><a class="tocitem" href="projections.html">Projections</a></li><li><a class="tocitem" href="retractions.html">Retractions</a></li><li><a class="tocitem" href="vector_transports.html">Vector Transports</a></li></ul></li><li><a class="tocitem" href="manifolds.html">Manifolds</a></li><li><a class="tocitem" href="decorator.html">Extending Manifolds</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="example.html">How to write a manifold</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="example.html">How to write a manifold</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manifold-tutorial"><a class="docs-heading-anchor" href="#manifold-tutorial">How to implement your own manifold</a><a id="manifold-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This tutorial explains, how to implement a manifold using the <code>ManifoldsBase.jl</code> interface. We assume that you are familiar with the basic terminology on Riemannian manifolds, especially the dimension of a manifold, the exponential map, and the inner product on tangent spaces. To read more about this you can for example check [<a href="#doCarmo1992">do Carmo, 1992</a>], Chapter 3, first.</p><p>Furthermore, we will look into a manifold that is isometrically embedded into e Euclidean space.</p><p>In general you need just a datatype (<code>struct</code>) that inherits from <a href="manifold_type.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to define a manifold. No function is <em>per se</em> required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_vector</code></a>, as we do in this tutorial.</p><p>We start with two technical preliminaries. If you want to start directly, you can <a href="example.html#manifold-tutorial-task">skip</a> this paragraph and revisit it for two of the implementation details.</p><p>After that, we will</p><ul><li><a href="example.html#manifold-tutorial-task">model</a> the manifold</li><li><a href="example.html#manifold-tutorial-checks">implement</a> two tests, so that points and tangent vectors can be checked for validity, for example also within <a href="manifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>,</li><li><a href="example.html#manifold-tutorial-fn">implement</a> two functions, the exponential map and the manifold dimension.</li><li><a href="example.html#manifold-tutorial-emb">decorate</a> the manifold with an embedding to gain further features.</li></ul><h2 id="manifold-tutorial-prel"><a class="docs-heading-anchor" href="#manifold-tutorial-prel">Technical preliminaries</a><a id="manifold-tutorial-prel-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-prel" title="Permalink"></a></h2><p>There are only two small technical things we need to explain at this point. First of all our <a href="manifold_type.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>{ùîΩ}</code> has a parameter <code>ùîΩ</code>. This parameter indicates the <a href="bases.html#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ"><code>number_system</code></a> the manifold is based on, for example <code>‚Ñù</code> for rel manifolds, which is short for <code>RealNumbers()</code>. This indicates that the manifold is a real manifold.</p><h2 id="manifold-tutorial-startup"><a class="docs-heading-anchor" href="#manifold-tutorial-startup">Startup</a><a id="manifold-tutorial-startup-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-startup" title="Permalink"></a></h2><p>As a start, let&#39;s load <code>ManifoldsBase.jl</code> and import the functions we consider throughout this tutorial.</p><pre><code class="language-julia hljs">using ManifoldsBase, LinearAlgebra, Test
import ManifoldsBase: check_point, check_vector, manifold_dimension, exp!, inner
import Base: show</code></pre><p>We load <code>LinearAlgebra</code> for some computations. <code>Test</code> is only loaded for illustrations in the examples.</p><p>We import the mutating variant of the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map, see <a href="design.html#mutating-and-nonmutating">the design section on mutating and nonmutating functions</a>.</p><h2 id="manifold-tutorial-task"><a class="docs-heading-anchor" href="#manifold-tutorial-task">The manifold</a><a id="manifold-tutorial-task-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-task" title="Permalink"></a></h2><p>The manifold we want to implement here a sphere, with a radius <span>$r$</span>. Since this radius is a property inherent to the manifold, it will become a field of the manifold. The second information, we want to store is the dimension of the sphere, for example whether it&#39;s the 1-sphere, i.e. the circle, represented by vectors <span>$p\in\mathbb R^2$</span> or norm <span>$r$</span> or the 2-sphere in <span>$\mathbb R^3$</span> of radius <span>$r$</span>. Since the latter might be something we want to <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">dispatch</a> on, we model it as a parameter of the type. In general the <code>struct</code> of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is ‚Äì most prominently ‚Äì a way to determine the manifold dimension.</p><p>Note that this a slightly more general manifold than the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/sphere.html">Sphere</a> in <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/index.html">Manifolds.jl</a></p><p>For our example we define the following struct. While a first implementation might also just take <a href="manifold_type.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>{‚Ñù}</code> as supertype, we directly take <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>`{‚Ñù}, which will be useful later. For now it does not make a difference.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    ScaledSphere{N} &lt;: AbstractDecoratorManifold{‚Ñù}

Define an `N`-sphere of radius `r`. Construct by `ScaledSphere(radius,n)`.
&quot;&quot;&quot;
struct ScaledSphere{N} &lt;: AbstractDecoratorManifold{ManifoldsBase.‚Ñù} where {N}
    radius::Float64
end
ScaledSphere(radius, n) = ScaledSphere{n}(radius)
Base.show(io::IO, M::ScaledSphere{n}) where {n} = print(io, &quot;ScaledSphere($(M.radius),$n)&quot;)</code></pre><p>Here, the last line just provides a nicer print of a variable of that type. Now we can already initialize our manifold that we will use later, the <span>$2$</span>-sphere of radius <span>$1.5$</span>.</p><pre><code class="language-julia hljs">S = ScaledSphere(1.5, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ScaledSphere(1.5,2)</code></pre><h2 id="manifold-tutorial-checks"><a class="docs-heading-anchor" href="#manifold-tutorial-checks">Checking points and tangents</a><a id="manifold-tutorial-checks-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-checks" title="Permalink"></a></h2><p>If we have now a point, represented as an array, we would first like to check, that it is a valid point on the manifold. For this one can use the easy interface <a href="functions.html#ManifoldsBase.is_point"><code>is_point</code></a>. This is a function on <a href="design.html#design-layer1">layer 1</a> which handles specialy cases, so it should not be implemented. The actual functions where we dispatch per manifold are on <a href="design.html#design-layer3">layer 3</a>. For the test of points this function is <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> which we actually will implement. This function returns <code>nothing</code> if the point is a valid point and returns an error not throw it) otherwise. This is usually a <code>DomainError</code>.</p><p>We have to check two things: that a point <code>p</code> is a vector with <code>N+1</code> entries and its norm is the desired radius. To spare a few lines, we can use <a href="https://docs.julialang.org/en/v1/manual/control-flow/#Short-Circuit-Evaluation-1">short-circuit evaluation</a> instead of <code>if</code> statements. If something has to only hold up to precision, we can pass that down, too using the <code>kwargs...</code>.</p><pre><code class="language-julia hljs">function check_point(M::ScaledSphere{N}, p; kwargs...) where {N}
    (size(p)) == (N+1,) || return DomainError(size(p),&quot;The size of $p is not $((N+1,)).&quot;)
    if !isapprox(norm(p), M.radius; kwargs...)
        return DomainError(norm(p), &quot;The norm of $p is not $(M.radius).&quot;)
    end
    return nothing
end</code></pre><p>Similarly, we can verify, whether a tangent vector <code>X</code> is valid. It has to fulfill the same size requirements and it has to be orthogonal to <code>p</code>. We can again use the <code>kwargs</code>, but also provide a way to check <code>p</code>, too.</p><pre><code class="language-julia hljs">function check_vector(M::ScaledSphere, p, X; kwargs...)
    size(X) != size(p) &amp;&amp; return DomainError(size(X), &quot;The size of $X is not $(size(p)).&quot;)
    if !isapprox(dot(p,X), 0.0; kwargs...)
        return DomainError(dot(p,X), &quot;The tangent $X is not orthogonal to $p.&quot;)
    end
    return nothing
end</code></pre><p>to test points we can now use</p><pre><code class="language- hljs">is_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false
@test_throws DomainError is_point(S, [1.5,0.0], true) # only on R^2, throws an error.
p = [1.5,0.0,0.0]
X = [0.0,1.0,0.0]
# The following two tests return true
[ is_point(S, p); is_vector(S,p,X) ]</code></pre><h2 id="manifold-tutorial-fn"><a class="docs-heading-anchor" href="#manifold-tutorial-fn">Functions on the manifold</a><a id="manifold-tutorial-fn-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-fn" title="Permalink"></a></h2><p>For the <a href="functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a> we have to just return the <code>N</code> parameter</p><pre><code class="language-julia hljs">manifold_dimension(::ScaledSphere{N}) where {N} = N
manifold_dimension(S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.</p><p>To implement the exponential map, we have to implement the formula for great arcs, given a start point <code>p</code> and a direction <code>X</code> on the <span>$n$</span>-sphere of radius <span>$r$</span> the formula reads</p><p class="math-container">\[\exp_p X = \cos(\frac{1}{r}\lVert X \rVert)p + \sin(\frac{1}{r}\lVert X \rVert)\frac{r}{\lVert X \rVert}X.\]</p><p>Note that with this choice we for example implicitly assume a certain metric. This is completely fine. We only have to think about specifying a metric explicitly, when we have (at least) two different metrics on the same manifold.</p><p>An implementation of the mutation version, see the <a href="example.html#manifold-tutorial-prel">technical note</a>, reads</p><pre><code class="language-julia hljs">function exp!(M::ScaledSphere{N}, q, p, X) where {N}
    nX = norm(X)
    if nX == 0
        q .= p
    else
        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (X./nX)
    end
    return q
end</code></pre><p>A first easy check can be done taking <code>p</code> from above and any vector <code>X</code> of length <code>1.5œÄ</code> from its tangent space. The resulting point is opposite of <code>p</code>, i.e. <code>-p</code>.</p><pre><code class="language- hljs">q = exp(S, p, [0.0,1.5œÄ,0.0])
[isapprox(p, -q); is_point(S, q)]</code></pre><h2 id="manifold-tutorial-emb"><a class="docs-heading-anchor" href="#manifold-tutorial-emb">Adding an isometric embedding</a><a id="manifold-tutorial-emb-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-emb" title="Permalink"></a></h2><p>Since the sphere is isometrically embedded, we do not have to implement the <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a><code>(M,p,X,Y)</code>for tangent vectors, but we can ‚Äúdelegate‚Äù it to the embedding. The embedding is the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/essentialmanifold.html">Euclidean</a> which is also available in <code>ManifoldsBase</code> as <code>DefaultManifold</code> for testing purposes.</p><pre><code class="language-julia hljs">using ManifoldsBase: DefaultManifold, IsIsometricEmbeddedManifold
import ManifoldsBase: active_traits, merge_traits, get_embedding</code></pre><p>Now we can activate a decorator by specifying that the sphere has the <a href="decorator.html#ManifoldsBase.IsIsometricEmbeddedManifold"><code>IsIsometricEmbeddedManifold</code></a> trait for the manifold by writing</p><pre><code class="language-julia hljs">active_traits(::ScaledSphere, args...) = merge_traits(IsIsometricEmbeddedManifold())</code></pre><p>and then specifying that said embedding is the default manifold</p><pre><code class="language-julia hljs">get_embedding(::ScaledSphere{N}) where {N} = DefaultManifold(N+1)</code></pre><p>Now metric related functions are passed to this embedding, so the inner product works by using the embedding</p><p>Now we can compute the inner product by calling <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a></p><pre><code class="language- hljs">X = [0.0, 0.1, 3.0]
Y = [0.0, 4.0, 0.2]
    # returns 1.0 by calling the inner product in DefaultManifold(3)
inner(S, p, X, Y)</code></pre><h2 id="manifold-tutorial-outlook"><a class="docs-heading-anchor" href="#manifold-tutorial-outlook">Conclusion</a><a id="manifold-tutorial-outlook-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-outlook" title="Permalink"></a></h2><p>You can now just continue implementing further functions from <code>ManifoldsBase.jl</code>. but with just <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a> you for example already have</p><ul><li><a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a> the (not necessarily shortest) geodesic emanating from <code>p</code> in direction <code>X</code>.</li><li>the <a href="retractions.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>, that the <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> function uses by default.</li></ul><p>For the <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> the implementation of a logarithm <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, again better a <a href="functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>log!</code></a> is necessary.</p><p>Sometimes a default implementation is provided; for example if you implemented <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>, the <a href="functions.html#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>norm</code></a> is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With <a href="functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>log!</code></a> and <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a> you get the <a href="functions.html#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>distance</code></a>, and so.</p><p>In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from <code>Manifolds.jl</code> requires another function to be specifically implemented, you get a reasonable error message.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><ul>
<li id="doCarmo1992">
    [<a>doCarmo, 1992</a>]
    M. P. do Carmo,
    <emph>Riemannian Geometry</emph>,
    Birkh√§user Boston, 1992,
    ISBN: 0-8176-3490-8.
</li>
</ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">¬´ Home</a><a class="docs-footer-nextpage" href="design.html">Design principles ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Wednesday 9 February 2022 07:00">Wednesday 9 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
