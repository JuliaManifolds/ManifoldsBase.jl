<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design principles · ManifoldsBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li class="is-active"><a class="tocitem" href>Design principles</a><ul class="internal"><li><a class="tocitem" href="#General-order-of-parameters"><span>General order of parameters</span></a></li><li><a class="tocitem" href="#A-3-Layer-architecture-for-dispatch"><span>A 3-Layer architecture for dispatch</span></a></li><li><a class="tocitem" href="#inplace-and-noninplace"><span>Mutating and allocating functions</span></a></li></ul></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="../functions/">Basic functions</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li><a class="tocitem" href="../vector_transports/">Vector transports</a></li></ul></li><li><a class="tocitem" href="../manifolds/">Manifolds</a></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Design principles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design principles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design"><a class="docs-heading-anchor" href="#Design">Main Design Principles</a><a id="Design-1"></a><a class="docs-heading-anchor-permalink" href="#Design" title="Permalink"></a></h1><p>The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from <a href="https://manoptjl.org"><code>Manopt.jl</code></a> can be implemented on <em>arbitrary</em> manifolds.</p><p>The main design criteria for the interface are:</p><ul><li>Aims to also provide <em>efficient</em> <em>global state-free</em>, both <em>in-place</em> and <em>out-of-place</em> computations whenever possible.</li><li>Provide a high level interface that is easy to use.</li></ul><p>Therefore this interface has 3 main features, that we will explain using two (related) concepts, the <a href="https://en.wikipedia.org/wiki/Exponential_map_(Riemannian_geometry)">exponential map</a> that maps a tangent vector <span>$X$</span> at a point <span>$p$</span> to a point <span>$q$</span> or mathematically <span>$\exp_p:T_p\mathcal M \to \mathcal M$</span> and its generalization, a <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>ion <span>$\operatorname{retr}_p$</span> with the same domain and range.</p><p>You do not need to know their exact definition at this point, just that there is <em>one</em> exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (called <a href="../retractions/#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a> for completeness). Every retraction has its own subtype of the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> that uniquely defines it.</p><p>The following three design patterns aim to fulfil the criteria from above, while also avoiding ambiguities in multiple dispatch using the <a href="https://docs.julialang.org/en/v1/manual/methods/#Dispatch-on-one-argument-at-a-time">dispatch on one argument at a time</a> approach.</p><h2 id="General-order-of-parameters"><a class="docs-heading-anchor" href="#General-order-of-parameters">General order of parameters</a><a id="General-order-of-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#General-order-of-parameters" title="Permalink"></a></h2><p>Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for in-place functions. Then the classical parameters of a function (for example a point and a tangent vector for the retraction) follow and the final part are parameters to further dispatch on, which usually have their defaults.</p><h2 id="A-3-Layer-architecture-for-dispatch"><a class="docs-heading-anchor" href="#A-3-Layer-architecture-for-dispatch">A 3-Layer architecture for dispatch</a><a id="A-3-Layer-architecture-for-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#A-3-Layer-architecture-for-dispatch" title="Permalink"></a></h2><p>The general architecture consists of three layers</p><ul><li>The high level interface for ease of use – and to dispatch on other manifolds.</li><li>The intermediate layer to dispatch on different parameters in the last section, e.g. type of retraction or vector transport.</li><li>The lowest layer for specific manifolds to dispatch on different types of points and tangent vectors. Usually this layer with a specific manifold and no optional parameters.</li></ul><p>These three layers are described in more detail in the following. The main motivation to introduce these layers is, that it reduces method ambiguities. It also provides a good structure where to implement extensions to this interface.</p><h3 id="design-layer1"><a class="docs-heading-anchor" href="#design-layer1">Layer I: The high level interface and ease of use</a><a id="design-layer1-1"></a><a class="docs-heading-anchor-permalink" href="#design-layer1" title="Permalink"></a></h3><p>The highest layer for convenience of decorators. A usual scheme is, that a manifold might assume several things implicitly, for example the default implementation of the sphere <span>$\mathbb S^n$</span> using unit vectors in <span>$\mathbb R^{n+1}$</span>. The embedding can be explicitly used to avoid re-implementations – the inner product can be “passed on” to its embedding.</p><p>To do so, we “decorate” the manifold by making it an <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> and activating the right traits see the tutorial <a href="../tutorials/implement-a-manifold/#How-to-Implement-a-Manifold">How to Implement a Manifold</a>.</p><p>The explicit case of the <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> can be used to distinguish different embeddings of a manifold, but also their dispatch (onto the manifold or its embedding, depending on the type of embedding) happens here.</p><p>Note that all other parameters of a function should be as least typed as possible for all parameters besides the manifold. With respect to the <a href="https://docs.julialang.org/en/v1/manual/methods/#Dispatch-on-one-argument-at-a-time">dispatch on one argument at a time</a> paradigm, this layer dispatches the <em>manifold first</em>. We also stay as abstract as possible, for example on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> level if possible.</p><p>If a function has optional positional arguments, (like <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>) their default values might be filled/provided on this layer. This layer ends usually in calling the same functions like <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> but prefixed with a <code>_</code> to enter <a href="#design-layer2">Layer II</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Usually only functions from this layer are exported from the interface, since these are the ones one should use for generic implementations. If you implement your own manifold, <code>import</code> the necessary lower layer functions as needed.</p></div></div><h3 id="design-layer2"><a class="docs-heading-anchor" href="#design-layer2">Layer II: An internal dispatch interface for parameters</a><a id="design-layer2-1"></a><a class="docs-heading-anchor-permalink" href="#design-layer2" title="Permalink"></a></h3><p>This layer is an interims layer to dispatch on the (optional/default) parameters of a function. For example the last parameter of retraction: <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> determines the type (variant) to be used. The last function in the previous layer calls <code>_retract</code>, which is an internal function. These parameters are usually the last parameters of a function.</p><p>On this layer, e.g. for <code>_retract</code> only these last parameters should be typed, the manifold should stay at the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> level. The layer dispatches on different functions per existing parameter type (and might pass this one further on, if it has fields). Function definitions on this layer should only be extended when introducing new such parameter types, for example when introducing a new type of a retraction.</p><p>The functions from this layer should never be called directly, are hence also not exported and carry the <code>_</code> prefix. They should only be called as the final step in the previous layer.</p><p>If the default parameters are not dispatched per type, using <code>_</code> might be skipped. The same holds for functions that do not have these parameters. The following resolution might even be seen as a last step in layer I or the resolution here in layer II.</p><pre><code class="language-julia hljs">exp(M::AbstractManifold, p, X, t::Real) = exp(M, p, t * X)</code></pre><p>When there is no dispatch for different types of the optional parameter (here <code>t</code>), the <code>_</code> might be skipped. One could hence see the last code line as a definition on Layer I that passes directly to Layer III, since there are not parameter to dispatch on.</p><p>To close this section, let‘s look at an example. The high level (or <a href="#design-layer1">Layer I</a>) definition of the retraction is given by</p><pre><code class="language-julia hljs">retract(M::AbstractManifold, p, X, m::AbstractRetractionMethod=default_retraction_method(M, typeof(p))) = _retract(M, p, X, m)</code></pre><p>This level now dispatches on different retraction types <code>m</code>. It usually passes to specific functions implemented in <a href="#design-layer3">Layer III</a>, here for example</p><pre><code class="language-julia hljs">_retract(M::AbstractManifold, p, X, m::Exponentialretraction) = exp(M, p, X)
_retract(M::AbstractManifold, p, X, m::PolarRetraction) = retract_polar(M, p, X)</code></pre><p>where the <a href="../retractions/#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a> is resolved by again calling a function on <a href="#design-layer1">Layer I</a> (to fill futher default values if these exist). The <a href="../retractions/#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> is dispatched to <a href="../retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}"><code>retract_polar</code></a>, a function on <a href="#design-layer3">Layer III</a>.</p><p>For further details and dispatches, see <a href="../retractions/#sec-retractions">retractions and inverse retractions</a> for an overview.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The documentation should be attached to the high level functions, since this again fosters ease of use. If you implement a polar retraction, you should write a method of function <a href="../retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}"><code>retract_polar</code></a> but the doc string should be attached to <code>retract(::M, ::P, ::V, ::PolarRetraction)</code> for your types <code>::M, ::P, ::V</code> of the manifold, points and vectors, respectively.</p></div></div><p>To summarize, with respect to the <a href="https://docs.julialang.org/en/v1/manual/methods/#Dispatch-on-one-argument-at-a-time">dispatch on one argument at a time</a> paradigm, this layer dispatches the (optional) <em>parameters second</em>.</p><h3 id="design-layer3"><a class="docs-heading-anchor" href="#design-layer3">Layer III: The base layer with focus on implementations</a><a id="design-layer3-1"></a><a class="docs-heading-anchor-permalink" href="#design-layer3" title="Permalink"></a></h3><p>This lower level aims for the actual implementation of the function avoiding ambiguities. It should have as few as possible optional parameters and as concrete as possible types for these.</p><p>This means</p><ul><li>the function name should be similar to its high level parent (for example <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> and <a href="../retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}"><code>retract_polar</code></a>  above)</li><li>The manifold type in method signature should always be as narrow as possible.</li><li>The points/vectors should either be untyped (for the default representation or if there is only one implementation) or provide all type bounds (for second representations or when using <a href="../types/#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> and <a href="../types/#ManifoldsBase.TVector"><code>TVector</code></a>, respectively).</li></ul><p>The first step that often happens on this level is memory allocation and calling the in-place function. If faster, it might also implement the function at hand itself.</p><p>Usually functions from this layer are not exported, when they have an analogue on the first layer. For example the function <a href="../retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}"><code>retract_polar</code></a><code>(M, p, X)</code> is not exported, since when using the interface one would use the <a href="../retractions/#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a> or to be precise call <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a><code>(M, p, X, PolarRetraction())</code>. When implementing your own manifold, you have to import functions like these anyway.</p><p>To summarize, with respect to the <a href="https://docs.julialang.org/en/v1/manual/methods/#Dispatch-on-one-argument-at-a-time">dispatch on one argument at a time</a> paradigm, this layer dispatches the <em>concrete manifold and point/vector types last</em>.</p><h2 id="inplace-and-noninplace"><a class="docs-heading-anchor" href="#inplace-and-noninplace">Mutating and allocating functions</a><a id="inplace-and-noninplace-1"></a><a class="docs-heading-anchor-permalink" href="#inplace-and-noninplace" title="Permalink"></a></h2><p>Every function, where this is applicable, should provide an in-place and an allocating variant. For example for the exponential map <code>exp(M, p, X, t)</code> returns a <em>new</em> point <code>q</code> where the result is computed in. On the other hand <code>exp!(M, q, p, X, t)</code> computes the result in place of <code>q</code>, where the design of the implementation should keep in mind that also <code>exp!(M, p, p, X, t)</code> should correctly overwrite <code>p</code>.</p><p>The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> is to allocate the resulting memory and call <a href="../functions/#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the in-place variants.</p></div></div><p>Non-mutating functions in <code>ManifoldsBase.jl</code> are typically implemented using in-place variants after a suitable allocation of memory.</p><p>Not that this allocation usually takes place only on <a href="#design-layer3">Layer III</a> when dispatching on points. Both <a href="#design-layer1">Layer I</a> and <a href="#design-layer1">Layer II</a> are usually implemented for both variants in parallel.</p><h3 id="Allocation-of-new-points-and-vectors"><a class="docs-heading-anchor" href="#Allocation-of-new-points-and-vectors">Allocation of new points and vectors</a><a id="Allocation-of-new-points-and-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Allocation-of-new-points-and-vectors" title="Permalink"></a></h3><p>The <a href="../functions/#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> function behaves like <code>similar</code> for simple representations of points and vectors (for example <code>Array{Float64}</code>). For more complex types, such as nested representations of <a href="../manifolds/#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> (see <a href="../manifolds/#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a>), checked types like <a href="../manifolds/#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a> and more it operates differently. While <code>similar</code> only concerns itself with the higher level of nested structures, <code>allocate</code> maps itself through all levels of nesting until a simple array of numbers is reached and then calls <code>similar</code>. The difference can be most easily seen in the following example:</p><pre><code class="language-julia hljs">julia&gt; x = similar([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 #undef
 #undef

julia&gt; y = allocate([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 [6.90031725726027e-310]
 [6.9003678131654e-310]

julia&gt; x[1]
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744
 [2] top-level scope at REPL[12]:1

julia&gt; y[1]
1-element Array{Float64,1}:
 6.90031725726027e-310</code></pre><p>The function <a href="../functions/#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> allocates a correct return value. It takes into account the possibility that different arguments may have different numeric <a href="../functions/#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a> types thorough the <a href="../functions/#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>allocate_result_type</code></a> function. The most prominent example of the usage of this function is the logarithmic function <a href="../functions/#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> when used with typed points. Lets assume on a manifold <code>M</code> the have points of type <code>P</code> and corresponding tangent vector types <code>V</code>. then the logarithmic map has the signature</p><pre><code class="language-julia hljs">log(::M, ::P, ::P)</code></pre><p>but the return type would be <span>$V$</span>, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by implementing a method <code>allocate_result(::M, ::typeof(log), ::P, ::P)</code> that returns the concrete variable for the result. This way, even with specific types, one just has to implement <code>log!</code> and the one line for the allocation.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This dispatch from the allocating to the in-place variant happens in Layer III, that is, functions like <code>exp</code> or <a href="../retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}"><code>retract_polar</code></a> (but not <a href="../manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> itself) allocate their result (using <code>::typeof(retract)</code> for the second function) and call the in-place variant <code>exp!</code> and <a href="../retractions/#ManifoldsBase.retract_polar!-Tuple{AbstractManifold, Any, Any, Any, Number}"><code>retract_polar!</code></a> afterwards.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/implement-a-manifold/">« How to define a manifold</a><a class="docs-footer-nextpage" href="../types/">An abstract manifold »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 22 September 2023 17:43">Friday 22 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
