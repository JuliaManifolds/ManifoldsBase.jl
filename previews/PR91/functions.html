<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic functions · ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to write a manifold</a></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="manifold.html">The manifold</a></li><li><span class="tocitem">Functions on Maniolds</span><ul><li class="is-active"><a class="tocitem" href="functions.html">Basic functions</a><ul class="internal"><li><a class="tocitem" href="#Validation"><span>Validation</span></a></li><li><a class="tocitem" href="#exp-and-log"><span>The exponential and the logarithmic map, and geodesics</span></a></li><li><a class="tocitem" href="#Vector-transport"><span>Vector transport</span></a></li><li><a class="tocitem" href="#Projections"><span>Projections</span></a></li><li><a class="tocitem" href="#Further-functions"><span>Further functions</span></a></li><li><a class="tocitem" href="#Error-Messages"><span>Error Messages</span></a></li></ul></li><li><a class="tocitem" href="retractions.html">Retractions</a></li><li><a class="tocitem" href="vector_transports.html">Vector Transports</a></li></ul></li><li><a class="tocitem" href="manifolds.html">Manifolds</a></li><li><a class="tocitem" href="decorator.html">Extending Manifolds</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions on Maniolds</a></li><li class="is-active"><a href="functions.html">Basic functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Basic functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-on-manifolds"><a class="docs-heading-anchor" href="#Functions-on-manifolds">Functions on manifolds</a><a id="Functions-on-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-manifolds" title="Permalink"></a></h1><p>This page collects several basic functions on manifolds.</p><h2 id="Validation"><a class="docs-heading-anchor" href="#Validation">Validation</a><a id="Validation-1"></a><a class="docs-heading-anchor-permalink" href="#Validation" title="Permalink"></a></h2><p>ince points and tangent vectors are represented usually as multidimensional arrays or for more complex cases as structs, there might be values, which invalidate a point of tangent vector. Here the interface provides two <a href="design.html#design-layer1">high level functions</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_point" href="#ManifoldsBase.is_point"><code>ManifoldsBase.is_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_point(M::AbstractManifold, p, throw_error = false; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_point"><code>check_point(M, p; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L388-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_vector" href="#ManifoldsBase.is_vector"><code>ManifoldsBase.is_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_vector(M::AbstractManifold, p, X, throw_error = false; check_base_point=true, kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_vector"><code>check_vector(M, p, X; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>If <code>check_base_point</code> is true, then the point <code>p</code> will be first checked using the <a href="functions.html#ManifoldsBase.check_point"><code>check_point</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L404-L417">source</a></section></article><p>These are mapped to the <a href="design.html#design-layer3">lower level functions</a></p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point" href="#ManifoldsBase.check_point"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractManifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="manifold.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L117-L125">source</a></section><section><div><pre><code class="language-julia hljs">check_point(M::AbstractPowerManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on an <a href="manifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. each element of <code>p</code> has to be a valid point on the base manifold. If <code>p</code> is not a point on <code>M</code> a <a href="functions.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/PowerManifold.jl#L207-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector" href="#ManifoldsBase.check_vector"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractManifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. An implementation does not have to validate the point <code>p</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="bases.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L128-L138">source</a></section><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractPowerManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> an the <a href="manifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. atfer <a href="functions.html#ManifoldsBase.check_point"><code>check_point</code></a><code>(M, p)</code>, and all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="functions.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/PowerManifold.jl#L230-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_size" href="#ManifoldsBase.check_size"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">check_size(M::AbstractManifold, p)
check_size(M::AbstractManifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> for a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L141-L151">source</a></section></article><h2 id="exp-and-log"><a class="docs-heading-anchor" href="#exp-and-log">The exponential and the logarithmic map, and geodesics</a><a id="exp-and-log-1"></a><a class="docs-heading-anchor-permalink" href="#exp-and-log" title="Permalink"></a></h2><p>Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector “points towards” the other point.</p><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractManifold, Any, Any}" href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractManifold, p, X)
exp(M::AbstractManifold, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[\exp_p X = γ_{p,X}(1),\]</p><p>where <span>$γ_{p,X}$</span> is the unique geodesic starting in <span>$γ(0)=p$</span> such that <span>$\dot γ(0) = X$</span>.</p><p>See also <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a>, <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractManifold, Any, Any}" href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractManifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The logarithmic map is the inverse of the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>See also <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L60-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp!(M::AbstractManifold, q, p, X)
exp!(M::AbstractManifold, q, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p><p>See also <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L22-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.</p><p>This function returns a function of (time) <code>t</code>.</p><pre><code class="nohighlight hljs">geodesic(M::AbstractManifold, p, X, t::Real)
geodesic(M::AbstractManifold, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the geodesic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L35-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log!(M::AbstractManifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>X</code>. The logarithmic map is the inverse of the <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>see also <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> and <a href="retractions.html#ManifoldsBase.inverse_retract!"><code>inverse_retract!</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L75-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="nohighlight hljs">shortest_geodesic(M::AabstractManifold, p, q, t::Real)
shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/exp_log_geo.jl#L87-L100">source</a></section></article><h2 id="Vector-transport"><a class="docs-heading-anchor" href="#Vector-transport">Vector transport</a><a id="Vector-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-transport" title="Permalink"></a></h2><p>There are three main functions for vector transport:</p><ul><li><a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a></li><li><a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a></li><li><a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a></li></ul><p>Different types of vector transport are implemented using subtypes of <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>:</p><ul><li><a href="functions.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a></li><li><a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a></li><li><a href="functions.html#ManifoldsBase.ProjectionTransport"><code>ProjectionTransport</code></a></li><li><a href="functions.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractLinearVectorTransportMethod" href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>ManifoldsBase.AbstractLinearVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLinearVectorTransportMethod &lt;: AbstractVectorTransportMethod</code></pre><p>Abstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors. Such vector transports are not necessarily linear.</p><p><strong>See also</strong></p><p><a href="functions.html#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DifferentiatedRetractionVectorTransport" href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>ManifoldsBase.DifferentiatedRetractionVectorTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DifferentiatedRetractionVectorTransport{R&lt;:AbstractRetractionMethod} &lt;:
    AbstractVectorTransportMethod</code></pre><p>A type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let <span>$\mathcal M$</span> be a Riemannian manifold, <span>$p\in\mathcal M$</span> a point, and <span>$X,Y\in T_p\mathcal M$</span> denote two tangent vectors at <span>$p$</span>.</p><p>Given a retraction (cf. <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>) <span>$\operatorname{retr}$</span>, the vector transport of <code>X</code> in direction <code>Y</code> (cf. <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>) by differentiation this retraction, is given by</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{p,Y}X
= D_Y\operatorname{retr}_p(Y)[X]
= \frac{\mathrm{d}}{\mathrm{d}t}\operatorname{retr}_p(Y+tX)\Bigr|_{t=0}.\]</p><p>see <sup class="footnote-reference"><a id="citeref-AbsilMahonySepulchre2008" href="#footnote-AbsilMahonySepulchre2008">[AbsilMahonySepulchre2008]</a></sup>, Section 8.1.2 for more details.</p><p>This can be phrased similarly as a <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a> by introducing <span>$q=\operatorname{retr}_pX$</span> and defining</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{q \gets p}X = \mathcal T^{\operatorname{retr}}_{p,Y}X\]</p><p>which in practice usually requires the <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a> to exists in order to compute <span>$Y = \operatorname{retr}_p^{-1}q$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L22-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use parallel transport vector transport method.</p><p>To be precise let <span>$c(t)$</span> be a curve depending on the method</p><ul><li>the (assumed to be unique) geodesic <span>$c(t) = γ_{p,q}(t)$</span> from <span>$γ_{p,q}(0)=p$</span> to <span>$γ_{p,q}(1)=q$</span> for <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a> <span>$\mathcal P_{q\gets p}Y$</span></li><li>the unique geodesic <span>$c(t)=γ_{p,X}(t)$</span> from <span>$γ_{p,X}(0)=p$</span> into direction <span>$\dot γ_{p,X}(0)=X$</span> for <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> <span>$\mathcal P_{p,X}Y$</span></li><li>a given curve <span>$c(0)=p$</span> for <a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a> <span>$\mathcal P^cY$</span></li></ul><p>In these cases <span>$Y\in T_p\mathcal M$</span> is the vector that we would like to transport from the tangent space at <span>$p=c(0)$</span> to the tangent space at <span>$c(1)$</span>.</p><p>Let <span>$Z\colon [0,1] \to T\mathcal M$</span>, <span>$Z(t)\in T_{c(t)}\mathcal M$</span> be a smooth vector field along the curve <span>$c$</span> with <span>$Z(0) = Y$</span>, such that <span>$Z$</span> is <em>parallel</em>, i.e. its covariant derivative <span>$\frac{\mathrm{D}}{\mathrm{d}t}Z$</span> is zero. Note that such a <span>$Z$</span> always exists and is unique.</p><p>Then the parallel transport is given by <span>$Z(1)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L67-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PoleLadderTransport" href="#ManifoldsBase.PoleLadderTransport"><code>ManifoldsBase.PoleLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoleLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="functions.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> as vector transport method within <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>, <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then <span>$x = \exp_pX$</span> is used to call <code>y =</code><a href="functions.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a><code>(M, p, x, q)</code> and the resulting vector is obtained by computing <span>$Y = -\log_qy$</span>.</p><p>The <a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> posesses two advantages compared to <a href="functions.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>:</p><ul><li>it is cheaper to evaluate, if you want to transport several vectors, since the mid point <span>$c$</span> then stays unchanged.</li><li>while both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds<sup class="footnote-reference"><a id="citeref-Pennec2018" href="#footnote-Pennec2018">[Pennec2018]</a></sup></li></ul><p>The pole ladder was was proposed in <sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PoleLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical pole ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. For an even cheaper transport the inner operations can be changed to an <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L99-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>, <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>. See <a href="functions.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L89-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ScaledVectorTransport" href="#ManifoldsBase.ScaledVectorTransport"><code>ManifoldsBase.ScaledVectorTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledVectorTransport{T} &lt;: AbstractVectorTransportMethod</code></pre><p>Introduce a scaled variant of any <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>T</code>, as introduced in <sup class="footnote-reference"><a id="citeref-SatoIwai2013" href="#footnote-SatoIwai2013">[SatoIwai2013]</a></sup> for some <span>$X\in T_p\mathcal M$</span> as</p><p class="math-container">\[    \mathcal T^{\mathrm{S}}(X) = \frac{\lVert X\rVert_p}{\lVert \mathcal T(X)\rVert_q}\mathcal T(X).\]</p><p>Note that the resulting point <code>q</code> has to be known, i.e. for <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ScaledVectorTransport(m::AbstractVectorTransportMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L162-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.SchildsLadderTransport" href="#ManifoldsBase.SchildsLadderTransport"><code>ManifoldsBase.SchildsLadderTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SchildsLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="functions.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> as vector transport method within <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>, <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X\in T_p\mathcal M$</span> be a tangent vector at <span>$p\in\mathcal M$</span> and <span>$q\in\mathcal M$</span> the point to transport to. Then</p><p class="math-container">\[P^{\mathrm{S}}_{q\gets p}(X) =
    \log_q\bigl( \operatorname{retr}_p ( 2\operatorname{retr}_p^{-1}c ) \bigr),\]</p><p>where <span>$c$</span> is the mid point between <span>$q$</span> and <span>$d=\exp_pX$</span>.</p><p>This method employs the internal function <a href="functions.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a><code>(M, p, d, q)</code> that avoids leaving the manifold.</p><p>The name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in <sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SchildsLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical Schilds ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>. For an even cheaper transport these inner operations can be changed to an <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L191-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}" href="#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}"><code>ManifoldsBase._vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::PoleLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L548-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, SchildsLadderTransport}" href="#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, SchildsLadderTransport}"><code>ManifoldsBase._vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::SchildsLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="functions.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L611-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}" href="#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}"><code>ManifoldsBase._vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::PoleLadderTransport)</code></pre><p>Perform a vector transport by using <a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L804-L808">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}" href="#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}"><code>ManifoldsBase._vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::SchildsLadderTransport)</code></pre><p>Perform a vector transport by using <a href="functions.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L843-L847">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::AbstractManifold)</code></pre><p>The <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> that is used when calling <a href="functions.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>, or <a href="functions.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> without specifying the vector transport method. By default, this is <a href="functions.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L250-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder" href="#ManifoldsBase.pole_ladder"><code>ManifoldsBase.pole_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, p, q);
    retraction=default_retraction_method(M),
    inverse_retraction=default_inverse_retraction_method(M)
)</code></pre><p>Compute an inner step of the pole ladder, that can be used as a <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>. Let <span>$c = \gamma_{p,q}(\frac{1}{2})$</span> mid point between <code>p</code> and <code>q</code>, then the pole ladder is given by</p><p class="math-container">\[    \operatorname{Pl}(p,d,q) = \operatorname{retr}_d (2\operatorname{retr}_d^{-1}c)\]</p><p>Where the classical pole ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = -\log_q \operatorname{Pl}(p,d,q)$</span>, you will obtain the <a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = (-1)^n\log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p><p>It is cheaper to evaluate than <a href="functions.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a>, sinc if you want to form multiple ladder steps between <code>p</code> and <code>q</code>, but with different <code>d</code>, there is just one evaluation of a geodesic each., since the center <code>c</code> can be reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L262-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder!" href="#ManifoldsBase.pole_ladder!"><code>ManifoldsBase.pole_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    pl,
    p,
    d,
    q,
    c = mid_point(M, p, q),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Compute the <a href="functions.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a>, i.e. the result is saved in <code>pl</code>. <code>X</code> is used for storing intermediate inverse retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L305-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder" href="#ManifoldsBase.schilds_ladder"><code>ManifoldsBase.schilds_ladder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, q, d);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Perform an inner step of schilds ladder, which can be used as a <a href="functions.html#ManifoldsBase.vector_transport_to"><code>vector_transport_to</code></a>, see <a href="functions.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>. Let <span>$c = \gamma_{q,d}(\frac{1}{2})$</span> denote the mid point on the shortest geodesic connecting <span>$q$</span> and the point <span>$d$</span>. Then Schild&#39;s ladder reads as</p><p class="math-container">\[\operatorname{Sl}(p,d,q) = \operatorname{retr}_x( 2\operatorname{retr}_p^{-1} c)\]</p><p>Where the classical Schilds ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>In consistency with <a href="functions.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> you can change the way the mid point is computed using the optional parameter <code>c</code>, but note that here it&#39;s the mid point between <code>q</code> and <code>d</code>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = \log_q \operatorname{Sl}(p,d,q)$</span>, you will obtain the <a href="functions.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. Then the approximation to the transported vector is given by <span>$\log_q\operatorname{Sl}(p,d,q)$</span>.</p><p>When performing multiple steps, this method avoidsd the switching to the tangent space. Hence after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = \log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L337-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder!" href="#ManifoldsBase.schilds_ladder!"><code>ManifoldsBase.schilds_ladder!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder!(
    M,
    sl
    p,
    d,
    q,
    c = mid_point(M, q, d),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M),
    inverse_retraction = default_inverse_retraction_method(M),
)</code></pre><p>Compute <a href="functions.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> and return the value in the parameter <code>sl</code>. If the required mid point <code>c</code> was computed before, it can be passed using <code>c</code>, and the allocation of new memory can be avoided providing a tangent vector <code>X</code> for the interims result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L383-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along" href="#ManifoldsBase.vector_transport_along"><code>ManifoldsBase.vector_transport_along</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along(M::AbstractManifold, p, X, c)
vector_transport_along(M::AbstractManifold, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L424-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!" href="#ManifoldsBase.vector_transport_along!"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(M::AbstractManifold, Y, p, X, c)
vector_transport_along!(M::AbstractManifold, Y, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L477-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(
    M::AbstractManifold,
    Y,
    p,
    X,
    c::AbstractVector,
    method::AbstractVectorTransportMethod
) where {T}</code></pre><p>Compute the vector transport along a discretized curve <code>c</code> using an <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> succesively along the sampled curve.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L515-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction" href="#ManifoldsBase.vector_transport_direction"><code>ManifoldsBase.vector_transport_direction</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::AbstractManifold, p, X, d)
vector_transport_direction(M::AbstractManifold, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> and <a href="functions.html#ManifoldsBase.vector_transport_to!"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L674-L682">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!" href="#ManifoldsBase.vector_transport_direction!"><code>ManifoldsBase.vector_transport_direction!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction!(M::AbstractManifold, Y, p, X, d)
vector_transport_direction!(M::AbstractManifold, Y, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> and <a href="functions.html#ManifoldsBase.vector_transport_to!"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L694-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to" href="#ManifoldsBase.vector_transport_to"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractManifold, p, X, q)
vector_transport_to(M::AbstractManifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L714-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!" href="#ManifoldsBase.vector_transport_to!"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q)
vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> to the tangent space at another point <code>q</code>. By default, the <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/vector_transport.jl#L760-L768">source</a></section></article><h2 id="Projections"><a class="docs-heading-anchor" href="#Projections">Projections</a><a id="Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Projections" title="Permalink"></a></h2><p>A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/circle.html">Circle</a> is embedded in the complex plane. Let‘s keep the circle in mind in the following as a simple example. For the general case see of explicitly stating an embedding and/or distinguising several, different embeddings, see <a href="decorator.html#subsec-embeddedmanifold">Embedded Manifolds</a> below.</p><p>To make this a little more concrete, let‘s assume we have a manifold <span>$\mathcal M$</span> which is embedded in some manifold <span>$\mathcal N$</span> and the image <span>$i(\mathcal M)$</span> of the embedding function <span>$i$</span> is a closed set (with respect to the topology on <span>$\mathcal N$</span>). Then we can do two kinds of projections.</p><p>To make this concrete in an example for the Circle <span>$\mathcal M=\mathcal C := \{ p ∈ ℂ | |p| = 1\}$</span> the embedding can be chosen to be the manifold <span>$N = ℂ$</span> and due to our representation of <span>$\mathcal C$</span> as complex numbers already, we have <span>$i(p) = p$</span> the identity as the embedding function.</p><ol><li>Given a point <span>$p∈\mathcal N$</span> we can look for the closest point on the manifold <span>$\mathcal M$</span> formally as</li></ol><p class="math-container">\[  \operatorname*{arg\,min}_{q\in \mathcal M} d_{\mathcal N}(i(q),p)\]</p><p>And this resulting <span>$q$</span> we call the projection of <span>$p$</span> onto the manifold <span>$\mathcal M$</span>.</p><ol><li>Given a point <span>$p∈\mathcal M$</span> and a vector in <span>$X\inT_{i(p)}\mathcal N$</span> in the embedding we can similarly look for the closest point to <span>$Y∈ T_p\mathcal M$</span> using the push forward <span>$\mathrm{d}i_p$</span> of the embedding.</li></ol><p class="math-container">\[  \operatorname*{arg\,min}_{Y\in T_p\mathcal M} \lVert \mathrm{d}i(p)[Y] - X \rVert_{i(p)}\]</p><p>And we call the resulting <span>$Y$</span> the projection of <span>$X$</span> onto the tangent space <span>$T_p\mathcal M$</span> at <span>$p$</span>.</p><p>Let‘s look at the little more concrete example of the complex Circle again. Here, the closest point of <span>$p ∈ ℂ$</span> is just the projection onto the circle, or in other words <span>$q = \frac{p}{\lvert p \rvert}$</span>. A tangent space <span>$T_p\mathcal C$</span> in the embedding is the line orthogonal to a point <span>$p∈\mathcal C$</span> through the origin. This can be better visualized by looking at <span>$p+T_p\mathcal C$</span> which is actually the line tangent to <span>$p$</span>. Note that this shift does not change the resulting projection relative to the origin of the tangent space.</p><p>Here the projection can be computed as the classical projection onto the line, i.e.  <span>$Y = X - ⟨X,p⟩X$</span>.</p><p>this is illustrated in the following figure</p><p><img src="assets/images/projection_illustration_600.png" alt="An example illustrating the two kinds of projections on the Circle."/></p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(M::AbstractManifold, Y, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved in vector <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/projections.jl#L55-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.project!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project!(M::AbstractManifold, q, p)</code></pre><p>Project point <code>p</code> from the ambient space onto the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is storedin <code>q</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>embed!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/projections.jl#L18-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractManifold, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>project</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>embed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/projections.jl#L32-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractManifold, p)</code></pre><p>Project point <code>p</code> from the ambient space of the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> to <code>M</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same array data, the data is changed accordingly.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>embed</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/projections.jl#L1-L11">source</a></section></article><h2 id="Further-functions"><a class="docs-heading-anchor" href="#Further-functions">Further functions</a><a id="Further-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Further-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map or <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="functions.html#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>injectivity_radius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.angle-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with respect to the inner product from <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L98-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any, Any}" href="#Base.copy-Tuple{AbstractManifold, Any, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p, X)</code></pre><p>Copy the value(s) from the tangent vector <code>X</code> at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new tangent vector. See <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L199-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any}" href="#Base.copy-Tuple{AbstractManifold, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p)</code></pre><p>Copy the value(s) from the point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new point. See <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, Y, p, X)</code></pre><p>Copy the value(s) from <code>X</code> to <code>Y</code>, where both are tangent vectors from the tangent space at <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(Y, X)</code>, but it might be useful to overwrite the function at the level, where also information from <code>p</code> and <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L223-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, q, p)</code></pre><p>Copy the value(s) from <code>p</code> to <code>q</code>, where both are points on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(q, p)</code>, but it might be useful to overwrite the function at the level, where also information from <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L377-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, q; kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L368-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractManifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. By default this is computed using <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L484-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}" href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate(a)
allocate(a, dims::Integer...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Integer...)
allocate(a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="functions.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L41-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}" href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result(M::AbstractManifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L69-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}" href="#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L83-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::AbstractManifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L107-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractManifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="manifold.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_size(M::AbstractManifold, p)
check_size(M::AbstractManifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> for a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L141-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractManifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. An implementation does not have to validate the point <code>p</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="bases.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L128-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[d(p,q) = \inf_{γ} L(γ),\]</p><p>where the infimum is over all piecewise smooth curves <span>$γ: [a,b] \to \mathcal M$</span> connecting <span>$γ(a)=p$</span> and <span>$γ(b)=q$</span> and</p><p class="math-container">\[L(γ) = \displaystyle\int_{a}^{b} \lVert \dotγ(t)\rVert_{γ(t)} \mathrm{d}t\]</p><p>is the length of the curve <span>$γ$</span>.</p><p>If <span>$\mathcal M$</span> is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be <span>$∞$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L233-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, Y, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space and return the result in <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L315-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, q, p)</code></pre><p>Embed point <code>p</code> from the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if points on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your point <code>p</code> is already represented in some embedding, see <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L273-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).</p><p>Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if tangent vectors on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>If you have more than one embedding, see <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your tangent vector <code>X</code> is already represented in some embedding, see <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L291-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p)</code></pre><p>Embed point <code>p</code> from the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed</code> includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly.</p><p>See also: <a href="decorator.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="functions.html#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L255-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractManifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold)</code></pre><p>Infimum of the injectivity radius of all manifold points.</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L332-L349">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L360-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_point" href="#ManifoldsBase.is_point"><code>ManifoldsBase.is_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_point(M::AbstractManifold, p, throw_error = false; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_point"><code>check_point(M, p; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L388-L397">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_vector" href="#ManifoldsBase.is_vector"><code>ManifoldsBase.is_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_vector(M::AbstractManifold, p, X, throw_error = false; check_base_point=true, kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_vector"><code>check_vector(M, p, X; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>If <code>check_base_point</code> is true, then the point <code>p</code> will be first checked using the <a href="functions.html#ManifoldsBase.check_point"><code>check_point</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L404-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::AbstractManifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is homeomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L441-L446">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.mid_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point!(M::AbstractManifold, q, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>. Saves the result in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L460-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.mid_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point(M::AbstractManifold, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L449-L454">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjuntion with <a href="functions.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> or <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L492-L497">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{AbstractManifold}" href="#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representation_size(M::AbstractManifold)</code></pre><p>The size of an array representing a point on <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns <code>nothing</code> by default indicating that points are not represented using an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L508-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple" href="#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>ManifoldsBase.size_to_tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L519-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.zero_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector!(M::AbstractManifold, X, p)</code></pre><p>Save to <code>X</code> the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> that represents the zero vector, i.e. such that retracting <code>X</code> to the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L526-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.zero_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::AbstractManifold, p)</code></pre><p>Return the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/ManifoldsBase.jl#L535-L541">source</a></section></article><h2 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h2><p>especially to collect and display errors on <a href="manifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>s the following component and collection error messages are available.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComponentManifoldError" href="#ManifoldsBase.ComponentManifoldError"><code>ManifoldsBase.ComponentManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompnentError{I,E} &lt;: Exception</code></pre><p>Store an error that occured in a component, where the additional <code>index</code> is stored.</p><p><strong>Fields</strong></p><ul><li><code>index</code> index where the error occured`</li><li><code>error</code> error that occured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/errors.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CompositeManifoldError" href="#ManifoldsBase.CompositeManifoldError"><code>ManifoldsBase.CompositeManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeManifoldError{T} &lt;: Exception</code></pre><p>A composite type to collect a set of errors that occured. Mainly used in conjunction with <a href="functions.html#ManifoldsBase.ComponentManifoldError"><code>ComponentManifoldError</code></a> to store a set of errors that occured.</p><p><strong>Fields</strong></p><ul><li><code>errors</code> a <code>Vector</code> of <code>&lt;:Exceptions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e443dec27aa2e5cabcf9efbe83a05dd6184a6a03/src/errors.jl#L19-L27">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-AbsilMahonySepulchre2008"><a class="tag is-link" href="#citeref-AbsilMahonySepulchre2008">AbsilMahonySepulchre2008</a><blockquote><p>Absil, P.-A., Mahony, R. and Sepulchre R., <em>Optimization Algorithms on Matrix Manifolds</em> Princeton University Press, 2008, doi: <a href="https://doi.org/10.1515/9781400830244">10.1515/9781400830244</a> <a href="http://press.princeton.edu/chapters/absil/">open access</a></p></blockquote></li><li class="footnote" id="footnote-LorenziPennec2014"><a class="tag is-link" href="#citeref-LorenziPennec2014">LorenziPennec2014</a><blockquote><p>Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild’s to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5–17 doi <a href="https://doi.org/10.1007/s10851-013-0470-3">10.1007/s10851-013-0470-3</a>, hal: <a href="https://hal.inria.fr/hal-00870489">hal-00870489</a></p></blockquote></li><li class="footnote" id="footnote-Pennec2018"><a class="tag is-link" href="#citeref-Pennec2018">Pennec2018</a><blockquote><p>Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: <a href="https://arxiv.org/abs/1805.11436">1805.11436</a></p></blockquote></li><li class="footnote" id="footnote-SatoIwai2013"><a class="tag is-link" href="#citeref-SatoIwai2013">SatoIwai2013</a><blockquote><p>Sato, H., Iwai, T.: <em>A new, globally convergent Riemannian conjugate gradient method</em>, Optimization, 2013, Volume 64(4), pp. 1011–1031. doi: <a href="https://doi.org/10.1080/02331934.2013.836650">10.1080/02331934.2013.836650</a>, arXiv: <a href="https://arxiv.org/abs/1302.0125">1302.0125</a>.</p></blockquote></li><li class="footnote" id="footnote-EhlersPiraniSchild1972"><a class="tag is-link" href="#citeref-EhlersPiraniSchild1972">EhlersPiraniSchild1972</a><blockquote><p>Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O’Raifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63–84. Clarendon Press, Oxford (1972). reprint doi: <a href="https://doi.org/10.1007/s10714-012-1353-4">10.1007/s10714-012-1353-4</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="manifold.html">« The manifold</a><a class="docs-footer-nextpage" href="retractions.html">Retractions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 3 January 2022 21:02">Monday 3 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
