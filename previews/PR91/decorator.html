<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Manifolds ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to write a manifold</a></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="manifold.html">The manifold</a></li><li><a class="tocitem" href="functions.html">Basic functions</a></li><li><a class="tocitem" href="metamanifolds.html">Meta manifolds</a></li><li class="is-active"><a class="tocitem" href="decorator.html">Extending Manifolds</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="decorator.html">Extending Manifolds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="decorator.html">Extending Manifolds</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/decorator.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Decorator-for-manifolds"><a class="docs-heading-anchor" href="#A-Decorator-for-manifolds">A Decorator for manifolds</a><a id="A-Decorator-for-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#A-Decorator-for-manifolds" title="Permalink"></a></h1><p>A decorator manifold extends the functionality of a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> in a semi-transparent way. It internally stores the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> it extends and by default for functions defined in <code>ManifoldsBase.jl</code> it acts transparently in the sense that it passes all functions through to the base except those that it actually affects. For example, because the <a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> affects nearly all functions, it overwrites nearly all functions, except a few like <a href="functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>.</p><p>By default, i.e. for a plain new decorator, all functions are transparent, i.e. passed down to the manifold the <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> decorates. To implement a method for a decorator that behaves differently from the method of the same function for the internal manifold, two steps are required. Let&#39;s assume the function is called <code>f(M, arg1, arg2)</code>, and our decorator manifold <code>DM</code> of type <code>OurDecoratorManifold</code> decorates <code>M</code>. Then</p><ol><li>set <code>decorator_transparent_dispatch(f, M::OurDecoratorManifold, args...) = Val(:intransparent)</code></li><li>implement <code>f(DM::OurDecoratorManifold, arg1, arg2)</code></li></ol><p>This makes it possible to extend a manifold or all manifolds with a feature or replace a feature of the original manifold.</p><p>A final technical note ‚Äì if several manifolds have similar transparency rules concerning functions from the interface, the last parameter <code>T</code> of the <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a><code>{ùîΩ,T&lt;:</code><a href="decorator.html#ManifoldsBase.AbstractDecoratorType"><code>AbstractDecoratorType</code></a><code>}</code> can be used to dispatch on different transparency schemes.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractDecoratorManifold" href="#ManifoldsBase.AbstractDecoratorManifold"><code>ManifoldsBase.AbstractDecoratorManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratorManifold{ùîΩ,T&lt;:AbstractDecoratorType} &lt;: AbstractManifold{ùîΩ}</code></pre><p>An <code>AbstractDecoratorManifold</code> indicates that to some extent a manifold subtype decorates another <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> in the sense that it either</p><ul><li>it extends the functionality of a manifold with further features</li><li>it defines a new manifold that internally uses functions from the decorated manifold</li></ul><p>with the main intent that several or most functions of <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> are transparently passed through to the manifold that is decorated. This way a function implemented for a decorator acts transparent on all other decorators, i.e. they just pass them through. If the decorator the function is implemented for is not among the decorators, an error is issued. By default all base manifold functions, for example <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> and <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> are transparent for all decorators.</p><p>Transparency of functions with respect to decorators can be specified using the macros <a href="decorator.html#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>@decorator_transparent_fallback</code></a>, <a href="decorator.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> and <a href="decorator.html#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>@decorator_transparent_signature</code></a>.</p><p>There are currently three modes given a new <code>AbstractDecoratorManifold</code> <code>M</code></p><ul><li><code>:intransparent</code> ‚Äì this function has to be implmented for the new manifold <code>M</code></li><li><code>:transparent</code> ‚Äì this function is transparent, in the sense that the function is invoked on the decorated <code>M.manifold</code>. This is the default, when introducing a function or signature.</li><li><code>:parent</code> specifies that (unless implemented) for this function, the classical inheritance is issued, i.e. the function is invoked on <code>M</code>s supertype.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L106-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractDecoratorType" href="#ManifoldsBase.AbstractDecoratorType"><code>ManifoldsBase.AbstractDecoratorType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractDecoratorType</code></pre><p>Decorator types can be used to specify a basic transparency for an <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>. This can be seen as an initial (rough) transparency pattern to start a type with.</p><p>Note that for a function <code>f</code> and it&#39;s mutating variant <code>f!</code></p><ul><li>The function <code>f</code> is set to <code>:parent</code> to first invoke allocation and call of <code>f!</code></li><li>The mutating function <code>f!</code> is set to <code>transparent</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L84-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultDecoratorType" href="#ManifoldsBase.DefaultDecoratorType"><code>ManifoldsBase.DefaultDecoratorType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultDecoratorType &lt;: AbstractDecoratorType</code></pre><p>A default decorator type, where all new functions are transparent by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_fallback-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_fallback</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_fallback(ex)
@decorator_transparent_fallback(fallback_case = :intransparent, ex)</code></pre><p>This macro introduces an additional implementation for a certain additional case. This can especially be used if for an already transparent function and an abstract intermediate type a change in the default is required. For implementing a concrete type, neither this nor any other trick is necessary. One just implements the function as before. Note that a decorator that <a href="decorator.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause. It does not allow for parameters with default values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@decorator_transparent_fallback function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_fallback :transparent function log!(M::AbstractGroupManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L138-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_function-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_function</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_function(ex)
@decorator_transparent_function(fallback_case = :intransparent, ex)</code></pre><p>Introduce the function specified by <code>ex</code> to act transparently with respect to <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>s. This introduces the possibility to modify the kind of transparency the implementation is done for. This optional first argument, the <code>Symbol</code> within <code>fallback_case</code>. This macro can be used to define a function and introduce it as transparent to other decorators. Note that a decorator that <a href="decorator.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a> still dispatches to the transparent case.</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued. Since this macro provides such an implementation, this is the default.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold. Passing is performed using the <code>invoke</code> function where the type of manifold is replaced by its supertype.</li></ul><p>Innkoline-definitions are not yet covered ‚Äì the function signature however may contain keyword arguments and a where clause.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">@decorator_transparent_function log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end
@decorator_transparent_function :parent log!(M::AbstractDecoratorManifold, X, p, q)
    log!(decorated_manifold(M), X, p, Q)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L196-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.@decorator_transparent_signature-Tuple{Any}" href="#ManifoldsBase.@decorator_transparent_signature-Tuple{Any}"><code>ManifoldsBase.@decorator_transparent_signature</code></a> ‚Äî <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@decorator_transparent_signature(ex)</code></pre><p>Introduces a given function to be transparent with respect to all decorators. The function is adressed by its signature in <code>ex</code>.</p><p>Supports standard, keyword arguments and <code>where</code> clauses. Doesn&#39;t support parameters with default values. It introduces a dispatch on several transparency modes</p><p>The cases of transparency are</p><ul><li><code>:transparent</code> states, that the function is transparently passed on to the manifold that is decorated by the <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> <code>M</code>, which is determined using the function <a href="decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>decorated_manifold</code></a>. This is the default.</li><li><code>:intransparent</code> states that an implementation for this decorator is required, and if none of the types provides one, an error is issued.</li><li><code>:parent</code> states, that this function passes on to the supertype instead of to the decorated manifold.</li></ul><p>Inline definitions are not supported. The function signature however may contain keyword arguments and a where clause.</p><p>The dispatch kind can later still be set to something different, see <a href="decorator.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>decorator_transparent_dispatch</code></a></p><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">@decorator_transparent_signature log!(M::AbstractDecoratorManifold, X, p, q)
@decorator_transparent_signature log!(M::TD, X, p, q) where {TD&lt;:AbstractDecoratorManifold}
@decorator_transparent_signature isapprox(M::AbstractDecoratorManifold, p, q; kwargs...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L343-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}" href="#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}"><code>ManifoldsBase.decorated_manifold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decorated_manifold(M::AbstractDecoratorManifold)</code></pre><p>Return the manifold decorated by the decorator <code>M</code>. Defaults to <code>M.manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any}}" href="#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>ManifoldsBase.decorator_transparent_dispatch</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decorator_transparent_dispatch(f, M::AbstractManifold, args...) -&gt; Val</code></pre><p>Given a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and a function <code>f(M,args...)</code>, indicate, whether a function is <code>Val(:transparent)</code> or <code>Val(:intransparent)</code> for the (decorated) <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Another possibility is, that for <code>M</code> and given <code>args...</code> the function <code>f</code> should invoke <code>M</code>s <code>Val(:parent)</code> implementation, see <a href="decorator.html#ManifoldsBase.@decorator_transparent_function-Tuple{Any}"><code>@decorator_transparent_function</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L490-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}" href="#ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}"><code>ManifoldsBase.default_decorator_dispatch</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_decorator_dispatch(M) -&gt; Val</code></pre><p>Return whether by default to dispatch the the inner manifold of a decorator (<code>Val(true)</code>) or not (<code>Val(false</code>). For more details see <a href="decorator.html#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>is_decorator_transparent</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L464-L470">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any}}" href="#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>ManifoldsBase.is_decorator_transparent</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_decorator_transparent(f, M::AbstractManifold, args...) -&gt; Bool</code></pre><p>Given a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and a function <code>f(M, args...)</code>, indicate, whether an <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> acts transparently for <code>f</code>. This means, it just passes through down to the internally stored manifold. Transparency is only defined for decorator manifolds and by default all decorators are transparent. A function that is affected by the decorator indicates this by returning <code>false</code>. To change this behaviour, see <a href="decorator.html#ManifoldsBase.decorator_transparent_dispatch-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>decorator_transparent_dispatch</code></a>.</p><p>If a decorator manifold is not in general transparent, it might still pass down for the case that a decorator is the default decorator, see <a href="decorator.html#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>is_default_decorator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L473-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}" href="#ManifoldsBase.is_default_decorator-Tuple{AbstractManifold}"><code>ManifoldsBase.is_default_decorator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_default_decorator(M) -&gt; Bool</code></pre><p>For any manifold that is a subtype of <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>, this function indicates whether a certain manifold <code>M</code> acts as a default decorator.</p><p>This yields that <em>all</em> functions are passed through to the decorated <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> if <code>M</code> is indicated as default. This overwrites all <a href="decorator.html#ManifoldsBase.is_decorator_transparent-Tuple{Any, AbstractManifold, Vararg{Any}}"><code>is_decorator_transparent</code></a> values.</p><p>This yields the following advantange: For a manifold one usually implicitly assumes for example a metric. To avoid reimplementation of this metric when introducing a second metric, the first metric can be set to be the default, i.e. its implementaion is already given by the undecorated case.</p><p>Value returned by this function is determined by <a href="decorator.html#ManifoldsBase.default_decorator_dispatch-Tuple{AbstractManifold}"><code>default_decorator_dispatch</code></a>, which returns a <code>Val</code>-wrapped boolean for type stability of certain functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/ab189168ae7835addb9381095c68ba28931c00db/src/DecoratorManifold.jl#L444-L461">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="metamanifolds.html">¬´ Meta manifolds</a><a class="docs-footer-nextpage" href="bases.html">Bases for tangent spaces ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 19 December 2021 21:28">Sunday 19 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
