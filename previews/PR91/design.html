<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design principles · ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to write a manifold</a></li><li class="is-active"><a class="tocitem" href="design.html">Design principles</a><ul class="internal"><li><a class="tocitem" href="#General-order-of-parameters"><span>General order of parameters</span></a></li><li><a class="tocitem" href="#The-higher-level-interface-and-ease-of-use"><span>The higher level interface and ease of use</span></a></li><li><a class="tocitem" href="#The-lower-level-interface-to-gain-performance"><span>The lower level interface to gain performance</span></a></li><li><a class="tocitem" href="#Mutating-and-allocating-functions"><span>Mutating and allocating functions</span></a></li><li><a class="tocitem" href="#Appendix"><span>Appendix</span></a></li></ul></li><li><a class="tocitem" href="manifold.html">The manifold</a></li><li><a class="tocitem" href="functions.html">Basic functions</a></li><li><a class="tocitem" href="metamanifolds.html">Meta manifolds</a></li><li><a class="tocitem" href="decorator.html">Extending Manifolds</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="design.html">Design principles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="design.html">Design principles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/design.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Main-Design-Principles"><a class="docs-heading-anchor" href="#Main-Design-Principles">Main Design Principles</a><a id="Main-Design-Principles-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Design-Principles" title="Permalink"></a></h1><p>The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from <a href="https://manoptjl.org"><code>Manopt.jl</code></a> can be implemented on <em>arbitrary</em> manifolds.</p><p>The main design criteria for the interface are:</p><ul><li>Aims to also provide <em>efficient</em> <em>global state-free</em>, both <em>in-place</em> and <em>out-of-place</em> computations whenever possible.</li><li>Provide a high level interface that is easy to use.</li></ul><p>Therefore this interface has 3 main features, that we will explain using two (related) concepts, the <a href="https://en.wikipedia.org/wiki/Exponential_map_(Riemannian_geometry)">exponential map</a> that maps a tangent vector <span>$X$</span> at a point <span>$p$</span> to a point <span>$q$</span> or mathematically <span>$\exp_p:T_p\mathcal M \to \mathcal M$</span> and its generalisation, a <a href="functions.html#ManifoldsBase.retract-Tuple{AbstractManifold, Any, Any}"><code>retract</code></a>ion <span>$\operatorname{retr}_p$</span> with same domain and range.</p><p>You do not need to know their exact definition at this point, just that there is <em>one</em> exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (sometime called exponential retraction for completeness). Every retraction has its own subtype of the <a href="functions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> that uniquely defines it.</p><p>The following three design patterns aim to fulfill the criteria from above, while also avoiding ambiguities in multiple dispatch using the <a href="https://docs.julialang.org/en/v1/manual/methods/#Dispatch-on-one-argument-at-a-time">dispatch on one argument at a time</a> approach.</p><h2 id="General-order-of-parameters"><a class="docs-heading-anchor" href="#General-order-of-parameters">General order of parameters</a><a id="General-order-of-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#General-order-of-parameters" title="Permalink"></a></h2><p>Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for mutating functions.</p><h2 id="The-higher-level-interface-and-ease-of-use"><a class="docs-heading-anchor" href="#The-higher-level-interface-and-ease-of-use">The higher level interface and ease of use</a><a id="The-higher-level-interface-and-ease-of-use-1"></a><a class="docs-heading-anchor-permalink" href="#The-higher-level-interface-and-ease-of-use" title="Permalink"></a></h2><p>The higher level interface should aim for a convenience layer that resolves defaults and creates fallbacks for certain input parameters, that have these properties. It usually should not dispatch on a certain manifold nor on certain point or (co- or tangent) vector types.</p><p>This layer should also not resolve/dispatch from the allocating to the mutating variant.</p><p>This is maybe best illustrated by two examples of the expponential map and a retraction:</p><p>The exponential map usually has a long form, where one can specify a fraction (of <code>X</code>) where the evaluation should be. This is generically implemented a</p><pre><code class="language-julia hljs">  exp(M::AbstractManifold, p, X, t::Real) = exp(M, p, t * X)</code></pre><p>On this level neither the manifold <em>nor</em> the points should be too strictly typed, points and vectors should – for best of cases – never be types.</p><p>For the retraction, a default retraction (usually exp) is specified/defined via <a href="functions.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}"><code>default_retraction_method</code></a>. This also means, that the last parameter of</p><pre><code class="language-julia hljs">retract(M::AbstractManifold, p, X, ::AbstractRetractionMethod=default_retraction_method(M))</code></pre><p>is optional and for a concrete type the dispatch on a certain retraction is done next. To avoid ambiguities, this concrete type should always be the first argument we dispatch on: The <code>ExponentialRetractionMethod</code> calls <code>exp</code>, any other retraction calls a function of different name without this last parameter, for example the <code>PolarRetractionMethod</code> by default calls <code>retract_polar(M,p,X)</code>, which is actualy a function from the lower level, see next section. See the <a href="design.html#subsec_appendix_retr">appendix</a> for an overview.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The documentation should be attached to the high level functions, since this again fosters ease of use. If yuo implement a polar retraction, you should write a function <code>polar_retract</code> but the doc string should be attached to <code>retract(::M, ::P, ::V, ::PolarRetraction)</code> for your types <code>::M, ::P, ::V</code> of the manifold, points and vectors, respectively.</p></div></div><h2 id="The-lower-level-interface-to-gain-performance"><a class="docs-heading-anchor" href="#The-lower-level-interface-to-gain-performance">The lower level interface to gain performance</a><a id="The-lower-level-interface-to-gain-performance-1"></a><a class="docs-heading-anchor-permalink" href="#The-lower-level-interface-to-gain-performance" title="Permalink"></a></h2><p>This lower level aims for performance, that is, any function should have as few as possible optional and keyword arguments and be typed as concrete as possible/necessary. This means</p><ul><li>the function name should be similar to its high level parent (for example <code>retract</code> and <code>retract_polar</code>from above)</li><li>The manifold type in method signature should always be as narrow as possible.</li><li>the points/vectors should either be untyped (for the default representation of if there is only one) or provide all types concretely.</li></ul><p>The first thing to do on this level is the aforementioned default to pass from allocating to mutating functions.</p><p>Note that not all of these functions are exported.</p><h2 id="Mutating-and-allocating-functions"><a class="docs-heading-anchor" href="#Mutating-and-allocating-functions">Mutating and allocating functions</a><a id="Mutating-and-allocating-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-and-allocating-functions" title="Permalink"></a></h2><p>Every function, where this is applicable should provide a mutating and an allocating variant. For example for the exponential map <code>exp(M,p,x)</code> returns a <em>new</em> point <code>q</code> where the result is computed in. On the other hand <code>exp!(M, q, p, X)</code> computes the result in place of <code>q</code>, where the design of the implementation should keep in mind that also <code>exp!(M,p,p,X)</code> should correctly overwrite <code>p</code>.</p><p>The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> is to allocate the resulting memory and call <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>it might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the mutating variants.</p></div></div><p>Non-mutating functions in <code>ManifoldsBase.jl</code> are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:</p><p>The <a href="functions.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> function behaves like <code>similar</code> for simple representations of points and vectors (for example <code>Array{Float64}</code>). For more complex types, such as nested representations of <a href="metamanifolds.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> (see <a href="metamanifolds.html#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a>), checked types like <a href="metamanifolds.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a> and more it operates differently. While <code>similar</code> only concerns itself with the higher level of nested structures, <code>allocate</code> maps itself through all levels of nesting until a simple array of numbers is reached and then calls <code>similar</code>. The difference can be most easily seen in the following example:</p><pre><code class="language-julia hljs">julia&gt; x = similar([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 #undef
 #undef

julia&gt; y = allocate([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 [6.90031725726027e-310]
 [6.9003678131654e-310]

julia&gt; x[1]
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744
 [2] top-level scope at REPL[12]:1

julia&gt; y[1]
1-element Array{Float64,1}:
 6.90031725726027e-310</code></pre><p>The function <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> allocates a correct return value. It takes into account the possibility that different arguments may have different numeric <a href="functions.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a> types thorough the <a href="functions.html#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>allocate_result_type</code></a> function. The most prominent example of the usage of this function is the logarithmic function <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> when used with typed points. Lets assume on a manifold <code>M</code> the have points of type <code>P</code> and corresponding tangent vector types <code>V</code>. then the logarithmic map has the signature</p><pre><code class="language-julia hljs">log(::M, ::P, ::P)</code></pre><p>but the return type would be <span>$V$</span>, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by omplementing a <code>allocate_result(::M, ::typeof(log), ::P, ::P)</code>that returns the concrete variable for the return. This way, even with specific types, one just has to implement <code>log!</code> and the one line for the allocation.</p><h2 id="Appendix"><a class="docs-heading-anchor" href="#Appendix">Appendix</a><a id="Appendix-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix" title="Permalink"></a></h2><h3 id="Validations"><a class="docs-heading-anchor" href="#Validations">Validations</a><a id="Validations-1"></a><a class="docs-heading-anchor-permalink" href="#Validations" title="Permalink"></a></h3><p>The function <a href="functions.html#ManifoldsBase.is_point"><code>is_point</code></a> internally calls the lower level function <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a>. Similarly <a href="functions.html#ManifoldsBase.is_vector"><code>is_vector</code></a> calls <a href="functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a>, which assumes that the (base) point is correct.</p><h3 id="subsec_appendix_inv_retr"><a class="docs-heading-anchor" href="#subsec_appendix_inv_retr">Inverse Retractions</a><a id="subsec_appendix_inv_retr-1"></a><a class="docs-heading-anchor-permalink" href="#subsec_appendix_inv_retr" title="Permalink"></a></h3><p>The high level function <code>inverse_retract(::M, p, X, m::AbstractInverseRetractionMethod)</code> as well as its mutating variant first dispatch on the lower level, before the non-mutating variant (of the name below) allocates memory and calls its mutating variant.</p><p>The following table provides an overview of the currently available types and their lower level functions.</p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">default lower level function</th><th style="text-align: left">comment</th></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.PolarInverseRetraction"><code>PolarInverseRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_polar</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.ProjectionInverseRetraction"><code>ProjectionInverseRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_project</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.QRInverseRetraction"><code>QRInverseRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_qr</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.NLsolveInverseRetraction"><code>NLsolveInverseRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_nlsolve</code></td><td style="text-align: left">the <code>m</code> is also passed on here.</td></tr></table><h3 id="subsec_appendix_retr"><a class="docs-heading-anchor" href="#subsec_appendix_retr">Retractions</a><a id="subsec_appendix_retr-1"></a><a class="docs-heading-anchor-permalink" href="#subsec_appendix_retr" title="Permalink"></a></h3><p>The high level function <code>retract(::M, p, X, m::AbstractRetractionMethod)</code> as well as its mutating variant first dispatch on the lower level, before the non-mutating variant (of the name below) allocates memory and calls its mutating variant.</p><p>The following table provides an overview of the currently available types and their lower level functions.</p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">default lower level function</th><th style="text-align: left">comment</th></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.PolarRetraction"><code>PolarRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_polar</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.ProjectionRetraction"><code>ProjectionRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_project</code></td><td style="text-align: left"></td></tr><tr><td style="text-align: left"><a href="functions.html#ManifoldsBase.QRRetraction"><code>QRRetraction</code></a></td><td style="text-align: left"><code>inverse_retract_qr</code></td><td style="text-align: left"></td></tr></table></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="example.html">« How to write a manifold</a><a class="docs-footer-nextpage" href="manifold.html">The manifold »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Sunday 19 December 2021 21:28">Sunday 19 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
