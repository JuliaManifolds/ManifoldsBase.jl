<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meta manifolds ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to write a manifold</a></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="manifold.html">The manifold</a></li><li><a class="tocitem" href="functions.html">Basic functions</a></li><li class="is-active"><a class="tocitem" href="metamanifolds.html">Meta manifolds</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Power-Manifold"><span>Abstract Power Manifold</span></a></li><li><a class="tocitem" href="#ValidationManifold"><span>ValidationManifold</span></a></li><li><a class="tocitem" href="#EmbeddedmanifoldSec"><span>EmbeddedManifold</span></a></li><li><a class="tocitem" href="#DefaultManifold"><span>DefaultManifold</span></a></li><li><a class="tocitem" href="#Error-Messages"><span>Error Messages</span></a></li></ul></li><li><a class="tocitem" href="decorator.html">Extending Manifolds</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="metamanifolds.html">Meta manifolds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="metamanifolds.html">Meta manifolds</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/metamanifolds.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manifolds"><a class="docs-heading-anchor" href="#Manifolds">Manifolds</a><a id="Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Manifolds" title="Permalink"></a></h1><p>While the interface <code>ManifoldsBase.jl</code> does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds</p><h2 id="Abstract-Power-Manifold"><a class="docs-heading-anchor" href="#Abstract-Power-Manifold">Abstract Power Manifold</a><a id="Abstract-Power-Manifold-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Power-Manifold" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerManifold" href="#ManifoldsBase.AbstractPowerManifold"><code>ManifoldsBase.AbstractPowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerManifold{ùîΩ,M,TPR} &lt;: AbstractManifold{ùîΩ}</code></pre><p>An abstract <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to represent manifolds that are build as powers of another <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with representation type <code>TPR</code>, a subtype of <a href="metamanifolds.html#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerRepresentation" href="#ManifoldsBase.AbstractPowerRepresentation"><code>ManifoldsBase.AbstractPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerRepresentation</code></pre><p>An abstract representation type of points and tangent vectors on a power manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.InversePowerRetraction" href="#ManifoldsBase.InversePowerRetraction"><code>ManifoldsBase.InversePowerRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InversePowerRetraction{TR&lt;:AbstractInverseRetractionMethod} &lt;: AbstractInverseRetractionMethod</code></pre><p>The <code>InversePowerRetraction</code> avoids ambiguities between dispatching on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="functions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="functions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">InversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L132-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedPowerRepresentation" href="#ManifoldsBase.NestedPowerRepresentation"><code>ManifoldsBase.NestedPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="metamanifolds.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is modified in-place, differently than in <a href="metamanifolds.html#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedReplacingPowerRepresentation" href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>ManifoldsBase.NestedReplacingPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedReplacingPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="metamanifolds.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for <a href="metamanifolds.html#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerBasisData" href="#ManifoldsBase.PowerBasisData"><code>ManifoldsBase.PowerBasisData</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerBasisData{TB&lt;:AbstractArray}</code></pre><p>Data storage for an array of basis data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L169-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerManifold" href="#ManifoldsBase.PowerManifold"><code>ManifoldsBase.PowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerManifold{ùîΩ,TM&lt;:AbstractManifold,TSize&lt;:Tuple,TPR&lt;:AbstractPowerRepresentation} &lt;: AbstractPowerManifold{ùîΩ,TM}</code></pre><p>The power manifold <span>$\mathcal M^{n_1√ó n_2 √ó ‚Ä¶ √ó n_d}$</span> with power geometry  <code>TSize</code> statically defines the number of elements along each axis.</p><p>For example, a manifold-valued time series would be represented by a power manifold with <span>$d$</span> equal to 1 and <span>$n_1$</span> equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (<span>$d=2$</span>) with <span>$n_1$</span> and <span>$n_2$</span> equal to width and height of the image.</p><p>While the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)
PowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)
M^(N_1, N_2, ..., N_d)</code></pre><p>Generate the power manifold <span>$M^{N_1 √ó N_2 √ó ‚Ä¶ √ó N_d}$</span>. By default, a [<code>PowerManifold</code>](@ref} is expanded further, i.e. for <code>M=PowerManifold(N,3)</code> <code>PowerManifold(M,2)</code> is equivalend to <code>PowerManifold(N,3,2)</code>. Points are then 3√ó2 matrices of points on <code>N</code>. Providing a <a href="metamanifolds.html#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a> as the second argument to the constructor can be used to nest manifold, i.e. <code>PowerManifold(M,NestedPowerRepresentation(),2)</code> represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.</p><p>Since there is no default <a href="metamanifolds.html#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a> within this interface, the <code>^</code> operator is only available for <code>PowerManifold</code>s and concatenates dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L45-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerRetraction" href="#ManifoldsBase.PowerRetraction"><code>ManifoldsBase.PowerRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerRetraction{TR&lt;:AbstractRetractionMethod} &lt;: AbstractRetractionMethod</code></pre><p>The <code>PowerRetraction</code> avoids ambiguities between dispatching on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="functions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="functions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerRetraction(retraction::AbstractRetractionMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L115-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerVectorTransport" href="#ManifoldsBase.PowerVectorTransport"><code>ManifoldsBase.PowerVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerVectorTransport{TR&lt;:AbstractVectorTransportMethod} &lt;:
   AbstractVectorTransportMethod</code></pre><p>The <code>PowerVectorTransport</code> avoids ambiguities between dispatching on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> and dispatching on the <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> should define a way how to treat its <a href="functions.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>s.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerVectorTransport(method::AbstractVectorTransportMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L150-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, Y, p, X)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, B, a, A)</code> for all elements <code>A</code>, <code>a</code> and <code>B</code> of <code>X</code>, <code>p</code>, and <code>Y</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L317-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, q, p)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, b, a)</code> for all elements <code>a</code> and <code>b</code> of <code>p</code> and <code>q</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L303-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the exponential map from <code>p</code> in direction <code>X</code> on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds exponential map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
p[M::AbstractPowerManifold, i...]</code></pre><p>Access the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L555-L562">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the logarithmic map from <code>p</code> to <code>q</code> on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds logarithmic map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L691-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.setindex!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
q[M::AbstractPowerManifold, i...] = p</code></pre><p>Set the element(s) at index <code>[i...]</code> of a point <code>q</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing to <code>q</code>. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L906-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.view</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)</code></pre><p>Get the view of the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L1092-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the norm of <code>X</code> from the tangent space of <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. from the element wise norms the Frobenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L756-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractPowerManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. each element of <code>p</code> has to be a valid point on the base manifold. If <code>p</code> is not a point on <code>M</code> a <a href="metamanifolds.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L249-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractPowerManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> an the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. atfer <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a><code>(M, p)</code>, and all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="metamanifolds.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L272-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the distance between <code>q</code> and <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>, i.e. from the element wise distances the Forbenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L336-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}" href="#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}"><code>ManifoldsBase.get_component</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(M::AbstractPowerManifold, p, idx...)</code></pre><p>Get the component of a point <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L397-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractPowerManifold[, p])</code></pre><p>the injectivity radius on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is for the global case equal to the one of its base manifold. For a given point <code>p</code> it&#39;s equal to the minimum of all radii in the array entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L571-L577">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractPowerManifold, p, X, Y)</code></pre><p>Compute the inner product of <code>X</code> and <code>Y</code> from the tangent space at <code>p</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. for each arrays entry the tangent vector entries from <code>X</code> and <code>Y</code> are in the tangent space of the corresponding element from <code>p</code>. The inner product is then the sum of the elementwise inner products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L598-L606">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractPowerManifold, p, q, m::InversePowerRetraction)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using an <a href="metamanifolds.html#ManifoldsBase.InversePowerRetraction"><code>InversePowerRetraction</code></a>, which by default encapsulates a inverse retraction of the base manifold. Then this method is performed elementwise, so the encapsulated inverse retraction method has to be one that is available on the base <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L649-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}" href="#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::PowerManifold)</code></pre><p>Returns the manifold-dimension of an <a href="metamanifolds.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> <span>$=\mathcal N = (\mathcal M)^{n_1,‚Ä¶,n_d}$</span>, i.e. with <span>$n=(n_1,‚Ä¶,n_d)$</span> the array size of the power manifold and <span>$d_{\mathcal M}$</span> the dimension of the base manifold <span>$\mathcal M$</span>, the manifold is of dimension</p><p class="math-container">\[\dim(\mathcal N) = \dim(\mathcal M)\prod_{i=1}^d n_i = n_1n_2\cdot‚Ä¶\cdot n_d \dim(\mathcal M).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L719-L730">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}" href="#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}"><code>ManifoldsBase.power_dimensions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_dimensions(M::PowerManifold)</code></pre><p>return the power of <code>M</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L773-L777">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p, X)</code></pre><p>Project the point <code>X</code> onto the tangent space at <code>p</code> on the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L805-L810">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p)</code></pre><p>Project the point <code>p</code> from the embedding onto the <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L782-L787">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::AbstractPowerManifold, p, X, method::PowerRetraction)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using a <a href="metamanifolds.html#ManifoldsBase.PowerRetraction"><code>PowerRetraction</code></a>, which by default encapsulates a retraction of the base manifold. Then this method is performed elementwise, so the encapsulated retraction method has to be one that is available on the base <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L857-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}" href="#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}"><code>ManifoldsBase.set_component!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_component!(M::AbstractPowerManifold, q, p, idx...)</code></pre><p>Set the component of a point <code>q</code> on an <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code> to <code>p</code>, which itself is a point on the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> the power manifold is build on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L893-L898">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, PowerVectorTransport}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, PowerVectorTransport}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractPowerManifold, p, X, q, method::PowerVectorTransport)</code></pre><p>Compute the vector transport the tangent vector <code>X</code>at <code>p</code> to <code>q</code> on the <a href="metamanifolds.html#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> using an <a href="metamanifolds.html#ManifoldsBase.PowerVectorTransport"><code>PowerVectorTransport</code></a> <code>m</code>. This method is performed elementwise, i.e. the method <code>m</code> has to be implemented on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/PowerManifold.jl#L1030-L1037">source</a></section></article><h2 id="ValidationManifold"><a class="docs-heading-anchor" href="#ValidationManifold">ValidationManifold</a><a id="ValidationManifold-1"></a><a class="docs-heading-anchor-permalink" href="#ValidationManifold" title="Permalink"></a></h2><p><a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> is a simple decorator using the <a href="@ref"><code>AbstractDecoratorManifold</code></a> that ‚Äúdecorates‚Äù a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling <a href="functions.html#ManifoldsBase.is_point"><code>is_point</code></a> or <a href="functions.html#ManifoldsBase.is_vector"><code>is_vector</code></a> whenever applicable.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationCoTVector" href="#ManifoldsBase.ValidationCoTVector"><code>ManifoldsBase.ValidationCoTVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}</code></pre><p>Represent a cotangent vector to a point on an <a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="metamanifolds.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationFibreVector" href="#ManifoldsBase.ValidationFibreVector"><code>ManifoldsBase.ValidationFibreVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationFibreVector{TType&lt;:VectorSpaceType} &lt;: AbstractFibreVector{TType}</code></pre><p>Represent a tangent vector to a point on an <a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="metamanifolds.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationMPoint" href="#ManifoldsBase.ValidationMPoint"><code>ManifoldsBase.ValidationMPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationMPoint &lt;: AbstractManifoldPoint</code></pre><p>Represent a point on an <a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="metamanifolds.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>s and <a href="metamanifolds.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationManifold" href="#ManifoldsBase.ValidationManifold"><code>ManifoldsBase.ValidationManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationManifold{ùîΩ,M&lt;:AbstractManifold{ùîΩ}} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A manifold to encapsulate manifolds working on array representations of <a href="manifold.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a>s and <a href="bases.html#ManifoldsBase.TVector"><code>TVector</code></a>s in a transparent way, such that for these manifolds it&#39;s not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.</p><p>This manifold is a decorator for a manifold, i.e. it decorates a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with types points, vectors, and covectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationTVector" href="#ManifoldsBase.ValidationTVector"><code>ManifoldsBase.ValidationTVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationTVector = ValidationFibreVector{TangentSpaceType}</code></pre><p>Represent a tangent vector to a point on an <a href="metamanifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="metamanifolds.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.array_value-Tuple{AbstractArray}" href="#ManifoldsBase.array_value-Tuple{AbstractArray}"><code>ManifoldsBase.array_value</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array_value(p)</code></pre><p>Return the internal array value of an <a href="metamanifolds.html#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="metamanifolds.html#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>, or <a href="metamanifolds.html#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a> if the value <code>p</code> is encapsulated as such. Return <code>p</code> if it is already an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/ValidationManifold.jl#L63-L69">source</a></section></article><h2 id="EmbeddedmanifoldSec"><a class="docs-heading-anchor" href="#EmbeddedmanifoldSec">EmbeddedManifold</a><a id="EmbeddedmanifoldSec-1"></a><a class="docs-heading-anchor-permalink" href="#EmbeddedmanifoldSec" title="Permalink"></a></h2><p>Some manifolds can easily be defined by using a certain embedding. For example the sphere <span>$\mathbb S$</span> is embedded in <span>$\mathbb R^{n+1}$</span>. An embedding is often implicitly assumed. We introduce the embedded manifolds hence as an <a href="@ref"><code>AbstractDecoratorManifold</code></a>.</p><p>This decorator enables to use such an embedding in an transparent way. Different types of embeddings can be distinguished using the <a href="@ref"><code>AbstractEmbeddingType</code></a>, which is an <a href="@ref"><code>AbstractDecoratorType</code></a>.</p><h3 id="Isometric-Embeddings"><a class="docs-heading-anchor" href="#Isometric-Embeddings">Isometric Embeddings</a><a id="Isometric-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Isometric-Embeddings" title="Permalink"></a></h3><p>For isometric embeddings the type <a href="@ref"><code>AbstractIsometricEmbeddingType</code></a> can be used to avoid reimplementing the metric. Here, the exponential map, the logarithmic map, the retraction and its inverse are set to <code>:intransparent</code>, i.e. they have to be implemented.</p><p>Furthermore, the <a href="@ref"><code>TransparentIsometricEmbedding</code></a> type even states that the exponential and logarithmic maps as well as retractions and vector transports of the embedding can be used for the embedded manifold as well.</p><p>In both cases of course <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and <a href="functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a> have to be implemented.</p><h3 id="Further-Embeddings"><a class="docs-heading-anchor" href="#Further-Embeddings">Further Embeddings</a><a id="Further-Embeddings-1"></a><a class="docs-heading-anchor-permalink" href="#Further-Embeddings" title="Permalink"></a></h3><p>A first embedding can also just be given implementing <a href="functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> ann <a href="functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a> for a manifold. This is considered to be the most usual or default embedding.</p><p>If you have two different embeddings for your manifold, a second one can be specified using the <a href="metamanifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, a type that ‚Äúcouples‚Äù two manifolds, more precisely a manifold and its embedding, to define embedding and projection functions between these two manifolds.</p><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.EmbeddedManifold" href="#ManifoldsBase.EmbeddedManifold"><code>ManifoldsBase.EmbeddedManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmbeddedManifold{ùîΩ, MT &lt;: AbstractManifold, NT &lt;: AbstractManifold} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A type to represent an explicit embedding of a <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> of type <code>MT</code> embedded into a manifold <code>N</code> of type <code>NT</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This type is not required if a manifold <code>M</code> is to be embedded in one specific manifold <code>N</code>. One can then just implement <a href="functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> and <a href="functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a>. Only for a second ‚Äìmaybe considered non-default‚Äì embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings <code>N</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>manifold</code> the manifold that is an embedded manifold</li><li><code>embedding</code> a second manifold, the first one is embedded into</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EmbeddedManifold(M, N)</code></pre><p>Generate the <code>EmbeddedManifold</code> of the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/EmbeddedManifold.jl#L1-L24">source</a></section></article><h3 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold, Val{N}}} where N" href="#ManifoldsBase.base_manifold-Union{Tuple{EmbeddedManifold}, Tuple{N}, Tuple{EmbeddedManifold, Val{N}}} where N"><code>ManifoldsBase.base_manifold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the base manifold of <code>M</code> that is enhanced with its embedding. For this specific type the internally stored enhanced manifold <code>M.manifold</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/EmbeddedManifold.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{AbstractManifold}" href="#ManifoldsBase.get_embedding-Tuple{AbstractManifold}"><code>ManifoldsBase.get_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_embedding(M::AbstractEmbeddedManifold)</code></pre><p>Return the embedding <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code> of <code>M</code>, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/EmbeddedManifold.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_embedding(M::EmbeddedManifold)</code></pre><p>Return the <a href="manifold.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code> an <a href="metamanifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> is embedded into.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/EmbeddedManifold.jl#L62-L66">source</a></section></article><h2 id="DefaultManifold"><a class="docs-heading-anchor" href="#DefaultManifold">DefaultManifold</a><a id="DefaultManifold-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultManifold" title="Permalink"></a></h2><p><a href="metamanifolds.html#ManifoldsBase.DefaultManifold"><code>DefaultManifold</code></a> is a simplified version of <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using <code>Manifolds.jl</code> the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> is available, the <code>DefaultManifold</code> itself is not exported.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultManifold" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultManifold &lt;: AbstractManifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/DefaultManifold.jl#L1-L11">source</a></section></article><h2 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h2><p>especially to collect and display errors on <a href="metamanifolds.html#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>s the following component and collection error messages are available.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComponentManifoldError" href="#ManifoldsBase.ComponentManifoldError"><code>ManifoldsBase.ComponentManifoldError</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompnentError{I,E} &lt;: Exception</code></pre><p>Store an error that occured in a component, where the additional <code>index</code> is stored.</p><p><strong>Fields</strong></p><ul><li><code>index</code> index where the error occured`</li><li><code>error</code> error that occured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/errors.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CompositeManifoldError" href="#ManifoldsBase.CompositeManifoldError"><code>ManifoldsBase.CompositeManifoldError</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeManifoldError{T} &lt;: Exception</code></pre><p>A composite type to collect a set of errors that occured. Mainly used in conjunction with <a href="metamanifolds.html#ManifoldsBase.ComponentManifoldError"><code>ComponentManifoldError</code></a> to store a set of errors that occured.</p><p><strong>Fields</strong></p><ul><li><code>errors</code> a <code>Vector</code> of <code>&lt;:Exceptions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/e202e61d0d51593434575d7063f39300be6c8f56/src/errors.jl#L19-L27">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="functions.html">¬´ Basic functions</a><a class="docs-footer-nextpage" href="decorator.html">Extending Manifolds ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 23 December 2021 18:50">Thursday 23 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
