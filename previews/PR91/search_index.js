var documenterSearchIndex = {"docs":
[{"location":"manifold_type.html#The-Manifold-Type","page":"The manifold type","title":"The Manifold Type","text":"","category":"section"},{"location":"manifold_type.html#Number-systems","page":"The manifold type","title":"Number systems","text":"","category":"section"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"Modules = [ManifoldsBase]\nPages = [\"numbers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifold_type.html#ManifoldsBase.AbstractNumbers","page":"The manifold type","title":"ManifoldsBase.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (‚Ñù for short) and ComplexNumbers (‚ÑÇ).\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html#ManifoldsBase.ComplexNumbers","page":"The manifold type","title":"ManifoldsBase.ComplexNumbers","text":"ComplexNumbers <: AbstractNumbers\n‚ÑÇ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html#ManifoldsBase.QuaternionNumbers","page":"The manifold type","title":"ManifoldsBase.QuaternionNumbers","text":"QuaternionNumbers <: AbstractNumbers\n‚Ñç = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html#ManifoldsBase.RealNumbers","page":"The manifold type","title":"ManifoldsBase.RealNumbers","text":"RealNumbers <: AbstractNumbers\n‚Ñù = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html#ManifoldsBase._unify_number_systems-Tuple{ManifoldsBase.AbstractNumbers, Vararg{ManifoldsBase.AbstractNumbers}}","page":"The manifold type","title":"ManifoldsBase._unify_number_systems","text":"_unify_number_systems(ùîΩs::AbstractNumbers...)\n\nCompute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.\n\n\n\n\n\n","category":"method"},{"location":"manifold_type.html#ManifoldsBase.number_system-Union{Tuple{AbstractManifold{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"The manifold type","title":"ManifoldsBase.number_system","text":"number_system(M::AbstractManifold{ùîΩ})\n\nReturn the number system the manifold M is based on, i.e. the parameter ùîΩ.\n\n\n\n\n\n","category":"method"},{"location":"manifold_type.html#ManifoldsBase.real_dimension-Tuple{ManifoldsBase.AbstractNumbers}","page":"The manifold type","title":"ManifoldsBase.real_dimension","text":"real_dimension(ùîΩ::AbstractNumbers)\n\nReturn the real dimension dim_‚Ñù ùîΩ of the AbstractNumbers system ùîΩ. The real dimension is the dimension of a real vector space with which a number in ùîΩ can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n\n\n","category":"method"},{"location":"manifold_type.html#The-main-type:-The-AbstractManifold","page":"The manifold type","title":"The main type: The AbstractManifold","text":"","category":"section"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"The main type is the AbstractManifold. It represents the manifold per se. During the documentation we will use the Euclidean Space and the Sphere (both implemented in Manifolds.jl) as easy examples to often illustrate properties and features of this interface","category":"page"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"Modules = [ManifoldsBase]\nPages = [\"maintypes.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifold_type.html#ManifoldsBase.AbstractManifold","page":"The manifold type","title":"ManifoldsBase.AbstractManifold","text":"AbstractManifold{F}\n\nA manifold type. The AbstractManifold is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the exponential and logarithmic maps as well as more general functions that are built on them like the geodesic.\n\nThe manifold is parametrized by an AbstractNumbers to distinguish for example real (‚Ñù) and complex (‚ÑÇ) manifolds.\n\nFor subtypes the preferred order of parameters is: size and simple value parameters, followed by the AbstractNumbers field, followed by data type parameters, which might depend on the abstract number field type.\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html#ManifoldsBase.AbstractManifoldPoint","page":"The manifold type","title":"ManifoldsBase.AbstractManifoldPoint","text":"AbstractManifoldPoint\n\nType for a point on a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used either\n\nfor more complicated representations,\nsemantic verification, or\neven dispatch for different representations of points on a manifold.\n\nSince semantic verification and different representations usually might still only store a matrix internally, it is possible to use @manifold_element_forwards and @default_manifold_fallbacks to reduce implementation overhead.\n\n\n\n\n\n","category":"type"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"which should store information about the manifold, for example parameters inherent to the manifold.","category":"page"},{"location":"manifold_type.html#Points-and-Tangent-Vectors","page":"The manifold type","title":"Points and Tangent Vectors","text":"","category":"section"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"Points and tangent vectors do not necessarily have to be typed. Usually one can just use any type. When a manifold has multiple representations, these should be distinguished by point and vector types. Then it might be that types just encapsulate a vector value. This is taken into account by the following macros, that forward several actions just to this field. Most prominently vector operations for the tangent vectors. If there is still a default case, a macro sets this type to be equivalent to calling the manifold functions just with the types field that carries the value.","category":"page"},{"location":"manifold_type.html","page":"The manifold type","title":"The manifold type","text":"Modules = [ManifoldsBase]\nPages = [\"point_vector_fallbacks.jl\"]\nOrder = [:type, :function, :macro]","category":"page"},{"location":"manifold_type.html#ManifoldsBase.@default_manifold_fallbacks-Tuple{Any, Any, Any, Symbol, Symbol}","page":"The manifold type","title":"ManifoldsBase.@default_manifold_fallbacks","text":"default_manifold_fallbacks(TM, TP, TV, pfield::Symbol, vfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on manifolds, for manifold of type TM, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and vfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"manifold_type.html#ManifoldsBase.@manifold_element_forwards-Tuple{Any, Symbol}","page":"The manifold type","title":"ManifoldsBase.@manifold_element_forwards","text":"manifold_element_forwards(T, field::Symbol)\nmanifold_element_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T (which can be a subtype of Twhere) that represents points or vectors for a manifold. Fallbacks will work by forwarding to the field passed in field`\n\nList of forwarded functions:\n\nallocate,\ncopy,\ncopyto!,\nnumber_eltype (only for values, not the type itself),\nsimilar,\n==.\n\n\n\n\n\n","category":"macro"},{"location":"manifold_type.html#ManifoldsBase.@manifold_vector_forwards-Tuple{Any, Symbol}","page":"The manifold type","title":"ManifoldsBase.@manifold_vector_forwards","text":"manifold_vector_forwards(T, field::Symbol)\nmanifold_vector_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T that represents vectors from a vector bundle for a manifold. Twhere is put into where clause of each method. Fallbacks work by forwarding to field passed as field.\n\nList of forwarded functions:\n\nbasic arithmetic (*, /, \\, +, -),\nall things from @manifold_element_forwards,\nbroadcasting support.\n\nexample\n\n@eval @manifold_vector_forwards ValidationFibreVector{TType} TType value\n\n\n\n\n\n","category":"macro"},{"location":"functions.html#Functions-on-manifolds","page":"Basic functions","title":"Functions on manifolds","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"This page collects several basic functions on manifolds.","category":"page"},{"location":"functions.html#exp-and-log","page":"Basic functions","title":"The exponential map, the logarithmic map, and geodesics","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector ‚Äúpoints towards‚Äù the other point.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"exp_log_geo.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.exp","text":"exp(M::AbstractManifold, p, X)\nexp(M::AbstractManifold, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M, i.e.\n\nexp_p X = Œ≥_pX(1)\n\nwhere Œ≥_pX is the unique geodesic starting in Œ≥(0)=p such that dot Œ≥(0) = X.\n\nSee also shortest_geodesic, retract.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.log-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.log","text":"log(M::AbstractManifold, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The logarithmic map is the inverse of the exponential map. Note that the logarithmic map might not be globally defined.\n\nSee also inverse_retract.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.exp!","text":"exp!(M::AbstractManifold, q, p, X)\nexp!(M::AbstractManifold, q, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M. The result is saved to q.\n\nSee also exp.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.\n\nThis function returns a function of (time) t.\n\ngeodesic(M::AbstractManifold, p, X, t::Real)\ngeodesic(M::AbstractManifold, p, X, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.log!","text":"log!(M::AbstractManifold, X, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The result is saved to X. The logarithmic map is the inverse of the exp!onential map. Note that the logarithmic map might not be globally defined.\n\nsee also log and inverse_retract!,\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\nshortest_geodesic(M::AabstractManifold, p, q, t::Real)\nshortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#subsec-parallel-transport","page":"Basic functions","title":"Parallel transport","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"While moving vectors from one base point to another is the identity in the Euclidean space ‚Äì¬†or in other words all tangent spaces (directions one can ‚Äúwalk‚Äù into) are the same. This is different on a manifold.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"If we have two points pq  mathcal M, we take a c 01  mathcal M connecting the two points, i.e. c(0) = p and c(1) = q. this could be a (or the) geodesic. If we further consider a vector field X 01  Tmathcal M, i.e. where X(t)  T_c(t)mathcal M. Then the vector field is called parallel if its covariant derivative fracmathrmDmathrmdtX(t) = 0 for all t 01.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"If we now impose a value for X=X(0)  T_pmathcal M, we obtain an ODE with an initial condition. The resulting value X(1)  T_qmathcal M is called the parallel transport of X along c or in case of a geodesic the _parallel transport of X from p to q.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"parallel_transport.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions.html#ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_along","text":"Y = parallel_transport_along(M::AbstractManifold, p, X, c)\n\nCompute the parallel transport of the vector X from the tangent space at p along the curve c.\n\nTo be precise let c(t) be a curve c(0)=p for vector_transport_along mathcal P^cY\n\nTHen In the result Yin T_pmathcal M is the vector X from the tangent space at p=c(0) to the tangent space at c(1).\n\nLet Zcolon 01 to Tmathcal M, Z(t)in T_c(t)mathcal M be a smooth vector field along the curve c with Z(0) = Y, such that Z is parallel, i.e. its covariant derivative fracmathrmDmathrmdtZ is zero. Note that such a Z always exists and is unique.\n\nThen the parallel transport is given by Z(1).\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::AbstractManifold, p, X, d)\n\nCompute the parallel_transport_along the curve c(t) = Œ≥_pq(t), i.e. the * the unique geodesic c(t)=Œ≥_pX(t) from Œ≥_pd(0)=p into direction dot Œ≥_pd(0)=d, of the tangent vector X.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractManifold, p, X, q)\n\nCompute the parallel_transport_along the curve c(t) = Œ≥_pq(t), i.e. the (assumed to be unique) geodesic connecting p and q, of the tangent vector X.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Further-functions-on-manifolds","page":"Basic functions","title":"Further functions on manifolds","text":"","category":"section"},{"location":"functions.html#General-functions-provided-by-the-interface","page":"Basic functions","title":"General functions provided by the interface","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]\nPublic=true\nPrivate=false","category":"page"},{"location":"functions.html#ManifoldsBase.OutOfInjectivityRadiusError","page":"Basic functions","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#Base.angle-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.angle","text":"angle(M::AbstractManifold, p, X, Y)\n\nCompute the angle between tangent vectors X and Y at point p from the AbstractManifold M with respect to the inner product from inner.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copy-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M, p, X)\n\nCopy the value(s) from the tangent vector X at a point p on the AbstractManifold M into a new tangent vector. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copy-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M, p)\n\nCopy the value(s) from the point p on the AbstractManifold M into a new point. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, Y, p, X)\n\nCopy the value(s) from X to Y, where both are tangent vectors from the tangent space at p on the AbstractManifold M. This function defaults to calling copyto!(Y, X), but it might be useful to overwrite the function at the level, where also information from p and M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, q, p)\n\nCopy the value(s) from p to q, where both are points on the AbstractManifold M. This function defaults to calling copyto!(q, p), but it might be useful to overwrite the function at the level, where also information from M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, X, Y; kwargs...)\n\nCheck if vectors X and Y tangent at p from AbstractManifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, q; kwargs...)\n\nCheck if points p and q from AbstractManifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"LinearAlgebra.norm","text":"norm(M::AbstractManifold, p, X)\n\nCompute the norm of tangent vector X at point p from a AbstractManifold M. By default this is computed using inner.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Integer...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Integer...)\nallocate(a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.base_manifold","page":"Basic functions","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::AbstractManifold, depth = Val(-1))\n\nReturn the internally stored AbstractManifold for decorated manifold M and the base manifold for vector bundles or power manifolds. The optional parameter depth can be used to remove only the first depth many decorators and return the AbstractManifold from that level, whether its decorated or not. Any negative value deactivates this depth limit.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q)\n\nShortest distance between the points p and q on the AbstractManifold M, i.e.\n\nd(pq) = inf_Œ≥ L(Œ≥)\n\nwhere the infimum is over all piecewise smooth curves Œ≥ ab to mathcal M connecting Œ≥(a)=p and Œ≥(b)=q and\n\nL(Œ≥) = displaystyleint_a^b lVert dotŒ≥(t)rVert_Œ≥(t) mathrmdt\n\nis the length of the curve Œ≥.\n\nIf mathcal M is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be .\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, Y, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into the ambient space and return the result in Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, q, p)\n\nEmbed point p from the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, embed might include changing data representation, if applicable, i.e. if points on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your point p is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).\n\nAdditionally, embed might include changing data representation, if applicable, i.e. if tangent vectors on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your tangent vector X is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p)\n\nEmbed point p from the AbstractManifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractManifold, p)\n\nReturn the distance d such that exp(M, p, X) is injective for all tangent vectors shorter than d (i.e. has an inverse).\n\ninjectivity_radius(M::AbstractManifold)\n\nInfimum of the injectivity radius of all manifold points.\n\ninjectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)\ninjectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)\n\nDistance d such that retract(M, p, X, method) is injective for all tangent vectors shorter than d (i.e. has an inverse) for point p if provided or all manifold points otherwise.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.inner","text":"inner(M::AbstractManifold, p, X, Y)\n\nCompute the inner product of tangent vectors X and Y at point p from the AbstractManifold M.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.is_point","page":"Basic functions","title":"ManifoldsBase.is_point","text":"is_point(M::AbstractManifold, p, throw_error = false; kwargs...)\n\nReturn whether p is a valid point on the AbstractManifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_point and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.is_vector","page":"Basic functions","title":"ManifoldsBase.is_vector","text":"is_vector(M::AbstractManifold, p, X, throw_error = false; check_base_point=true, kwargs...)\n\nReturn whether X is a valid tangent vector at point p on the AbstractManifold M. Returns either true or false.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_vector and checks whether the returned value is nothing or an error.\n\nIf check_base_point is true, then the point p will be first checked using the check_point function.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractManifold)\n\nThe dimension n=dim_mathcal M of real space mathbb R^n to which the neighborhood of each point of the AbstractManifold M is homeomorphic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point!","text":"mid_point!(M::AbstractManifold, q, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp!. Saves the result in q.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point","text":"mid_point(M::AbstractManifold, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.number_eltype-Tuple{Any}","page":"Basic functions","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractManifold)\n\nThe size of an array representing a point on AbstractManifold M. Returns nothing by default indicating that points are not represented using an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector!","text":"zero_vector!(M::AbstractManifold, X, p)\n\nSave to X the tangent vector from the tangent space T_pmathcal M at p that represents the zero vector, i.e. such that retracting X to the AbstractManifold M at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::AbstractManifold, p)\n\nReturn the tangent vector from the tangent space T_pmathcal M at p on the AbstractManifold M, that represents the zero vector, i.e. such that a retraction at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Internal-functions","page":"Basic functions","title":"Internal functions","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"While you should always add your documentation to functions from the last section, some of the functions dispatch onto functions on the lower layer. These are the ones you usually implement for your manifold ‚Äì unless there is no lower level function called, like for the manifold_dimension.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:function]\nPublic=false\nPrivate=true","category":"page"},{"location":"functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::AbstractManifold, f, x...)\n\nAllocate an array for the result of function f on AbstractManifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}","page":"Basic functions","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f and the AbstractManifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractManifold, p; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when p is a point on the AbstractManifold M. Otherwise, return an error with description why the point does not belong to manifold M.\n\nBy default, check_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the AbstractManifoldPoint type.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_size","text":"check_size(M::AbstractManifold, p)\ncheck_size(M::AbstractManifold, p, X)\n\nCheck whether p has the right representation_size for a AbstractManifold M. Additionally if a tangent vector is given, both p and X are checked to be of corresponding correct representation sizes for points and tangent vectors on M.\n\nBy default, check_size returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractManifold, p, X; kwargs...) -> Union{Nothing,String}\n\nCheck whether X is a valid tangent vector in the tangent space of p on the AbstractManifold M. An implementation does not have to validate the point p. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S<:Tuple","page":"Basic functions","title":"ManifoldsBase.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Error-Messages","page":"Basic functions","title":"Error Messages","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"especially to collect and display errors on AbstractPowerManifolds the following component and collection error messages are available.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"errors.jl\"]\nOrder = [:type]","category":"page"},{"location":"functions.html#ManifoldsBase.ComponentManifoldError","page":"Basic functions","title":"ManifoldsBase.ComponentManifoldError","text":"CompnentError{I,E} <: Exception\n\nStore an error that occured in a component, where the additional index is stored.\n\nFields\n\nindex index where the error occured`\nerror error that occured.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.CompositeManifoldError","page":"Basic functions","title":"ManifoldsBase.CompositeManifoldError","text":"CompositeManifoldError{T} <: Exception\n\nA composite type to collect a set of errors that occured. Mainly used in conjunction with ComponentManifoldError to store a set of errors that occured.\n\nFields\n\nerrors a Vector of <:Exceptions.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#A-Decorator-for-manifolds","page":"Extending Manifolds","title":"A Decorator for manifolds","text":"","category":"section"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Several properties of a manifold are often implicitly assumed, for example the choice of the (Riemannian) metric, the group structure or the embedding. The latter shall serve as an example how to either implicitly or explicitly specify the embedding to avoid re-implementations and/or distinguish different embeddings.","category":"page"},{"location":"decorator.html#The-abstract-decorator","page":"Extending Manifolds","title":"The abstract decorator","text":"","category":"section"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"When first implementing a manifold, it might be beneficial to dispatch certain computations to already existing manifolds. For an embedded manifold that is isometrically embedded this might be the inner the manifold inherits in each tangent space from its embedding.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"This means we dispatch the default implementation of a function to some other manifold. We refer to this as implicit decoration, since one can not ‚Äúsee‚Äù explicitly that a certain manifold inherits this property. As a small example consider the Sphere, which in every tangent space inherits its metric from the embedding. Since in the default implementation in Manifolds.jl points are represented by unit vectors and tangent vectors as vectors orthogonal to a point, we can just dispatch the inner product to the embedding without having to re-implement this. The manifold using such an implicit dispatch just has to have AbstractDecoratorManifold as its super type.","category":"page"},{"location":"decorator.html#Traits-with-a-inheritance-hierarchy","page":"Extending Manifolds","title":"Traits with a inheritance hierarchy","text":"","category":"section"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"The properties mentioned above might form a hierarchy. For embedded manifolds, again, we might have just a manifold whose points are represented in some embedding. If the manifold is even isometrically embedded, it is embedded but also inherits the Riemannian metric (by restriction). But it also inherits the functions form the plain embedding. If it is even a submanifold, also further functions are inherited.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"We use a variation of Tim Holy's Traits Trick (THTT) which takes into account this nestedness of traits","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"nested_trait.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"decorator.html#ManifoldsBase.AbstractDecoratorManifold","page":"Extending Manifolds","title":"ManifoldsBase.AbstractDecoratorManifold","text":"AbstractDecoratorManifold{ùîΩ} <: AbstractManifold{ùîΩ}\n\nDeclare a manifold to be an abstract decorator. A manifold which is a subtype of is a decorated manifold, i.e. has\n\ncertain additional properties or\ndelegates certain properties to other manifolds.\n\nMost prominently, a manifold might be an embedded manifold, i.e. points on a manifold mathcal M are represented by (some, maybe not all) points on another manifold mathcal N. Depending on the type of embedding, several functions are dedicated to the embedding. For example if the embedding is isometric, then the inner does not have to be implemented for mathcal M but can be automatically implemented by deligation to mathcal N.\n\nThis is modelled by the AbstractDecoratorManifold and traits. These are mapped to functions, which determine the types of transparencies.\n\nA dault function to implement determines the generic manifold that is added (decorates the manifold), see decorated_manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.AbstractTrait","page":"Extending Manifolds","title":"ManifoldsBase.AbstractTrait","text":"AbstractTrait\n\nAn abstract trait type to build a sequence of traits\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.EmptyTrait","page":"Extending Manifolds","title":"ManifoldsBase.EmptyTrait","text":"EmptyTrait <: AbstractTrait\n\nA Trait indicating that no feature is present.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.NestedTrait","page":"Extending Manifolds","title":"ManifoldsBase.NestedTrait","text":"NestedTrait <: AbstractTrait\n\nCombine two traits into a combined trait.  Note that this introduces a preceedence. the first of the traits takes preceedence if a trait is implemented for both functions.\n\nConstructor\n\nNestedTrait(head::AbstractTrait, tail::AbstractTrait)\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.active_traits-Tuple","page":"Extending Manifolds","title":"ManifoldsBase.active_traits","text":"active_traits(args...)\n\nReturn the list of traits applicable to the given function call. This function should be overloaded for specific function calls.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.expand_trait-Tuple{AbstractTrait}","page":"Extending Manifolds","title":"ManifoldsBase.expand_trait","text":"expand_trait(t::AbstractTrait)\n\nExpand given trait into an ordered NestedTrait list of traits with their parent traits obtained using parent_trait.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.merge_traits-Tuple{}","page":"Extending Manifolds","title":"ManifoldsBase.merge_traits","text":"merge_traits(t1, t2, trest...)\n\nMerge two traits into a nested list of traits. Note that this takes trait preceedence into account, i.e. t1 takes preceedence over t2 is any operations. It always returns either ab EmptyTrait or a NestedTrait.\n\nThis means that for\n\none argument it just returns the trait itself if it is list-like, or wraps the trait in a   single-element list otherwise,\ntwo arguments that are list-like, it merges them,\ntwo arguments of which only the first one is list-like and the second one is not,   it appends the second argument to the list,\ntwo arguments of which only the second one is list-like, it prepends the first one to   the list,\ntwo arguments of which none is list-like, it creates a two-element list.\nmore than two arguments it recursively performs a left-assiciative recursive reduction   on arguments, that is for example merge_traits(t1, t2, t3) is equivalent to   merge_traits(merge_traits(t1, t2), t3)\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.next_trait-Tuple{AbstractTrait}","page":"Extending Manifolds","title":"ManifoldsBase.next_trait","text":"next_trait(t::AbstractTrait)\n\nReturn the next trait to be considered after t.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.parent_trait-Tuple{AbstractTrait}","page":"Extending Manifolds","title":"ManifoldsBase.parent_trait","text":"parent_trait(t::AbstractTrait)\n\nReturn the parent trait for trait t, that is the more general trait whose behaviour it inherits as a fallback.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Then the following functions and macros introduce the decorator traits","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"decorator_trait.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"decorator.html#ManifoldsBase.IsEmbeddedManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsEmbeddedManifold","text":"IsEmbeddedManifold <: AbstractTrait\n\nA trait to declare an AbstractManifold as an embedded manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.IsEmbeddedSubmanifoldManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsEmbeddedSubmanifoldManifold","text":"IsEmbeddedSubmanifold <: AbstractTrait\n\nA trait to determine whether an AbstractDecoratorManifold M is an embedded submanifold. It is a special case of the IsIsometricEmbeddedManifold trait, i.e. it has all properties of this trait.\n\nIn this trait, additionally to the isometric embedded manifold, all retractions, inverse retractions, and vectors transports, especially exp, log, and parallel_transport_to are passed to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.IsIsometricEmbeddedManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsIsometricEmbeddedManifold","text":"IsIsometricManifoldEmbeddedManifold <: AbstractTrait\n\nA Trait to determine whether an AbstractDecoratorManifold M is an isometrically embedded manifold. It is a special case of the IsEmbeddedManifold trait, i.e. it has all properties of this trait.\n\nHere, additionally, netric related functions like inner and norm are passed to the embedding\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractDecoratorManifold}","page":"Extending Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::AbstractDecoratorManifold)\n\nFor a manifold M that is decorated with properties (for example an embedding N) this function returns the manifold that is attached (as a decorator). Hence for the embedding example this is N.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractManifold}","page":"Extending Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold}","page":"Extending Manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::AbstractDecoratorManifold)\n\nSpecify the embedding of a manifold that has abstract decorators.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"For an example see the (implicit) embedded manifold.","category":"page"},{"location":"vector_transports.html#Vector-transport","page":"Vector Transports","title":"Vector transport","text":"","category":"section"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Similar to the exponential and logarithmic map also the parallel transport might be costly to compute, especially when there is no closed form solution known and it has to be approximated with numerical methods.","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Similar to the retraction and its inverse the generalisation of the parallel transport can be phrased as follows","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"A vector transport is a way to transport a vector between two tangent spaces. Let pq  mathcal M be given, c the curve along which we want to transport (cf. parallel transport, for example a geodesic or a geodesic or curve given by a retraction, and X  T_pmathcal M be a tangent vector. Then T_pqX is a vector transport if","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Consistency. T_pp is the identiy on T_pmathcal M.\nUnderlying curve T_pc(t)X  T_c(t)mathcal M for t01\nLinearity. T_pq(X+Y)=T_pqX + T_pqY","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"hold.","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Currently the following types of vector transport are defined in ManifoldsBase.jl.","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:function]\nPublic=true\nPrivate=false","category":"page"},{"location":"vector_transports.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}","page":"Vector Transports","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::AbstractManifold)\n\nThe AbstractVectorTransportMethod that is used when calling vector_transport_along, vector_transport_to, or vector_transport_direction without specifying the vector transport method. By default, this is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_along","page":"Vector Transports","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::AbstractManifold, p, X, c)\nvector_transport_along(M::AbstractManifold, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_along!","page":"Vector Transports","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::AbstractManifold, Y, p, X, c)\nvector_transport_along!(M::AbstractManifold, Y, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, AbstractVectorTransportMethod}","page":"Vector Transports","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::AbstractVectorTransportMethod\n) where {T}\n\nCompute the vector transport along a discretized curve c using an AbstractVectorTransportMethod method succesively along the sampled curve.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_direction","page":"Vector Transports","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::AbstractManifold, p, X, d)\nvector_transport_direction(M::AbstractManifold, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the method, which defaults to default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_direction!","page":"Vector Transports","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::AbstractManifold, Y, p, X, d)\nvector_transport_direction!(M::AbstractManifold, Y, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the method, which defaults to default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_to","page":"Vector Transports","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractManifold, p, X, q)\nvector_transport_to(M::AbstractManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.vector_transport_to!","page":"Vector Transports","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::AbstractManifold, Y, p, X, q)\nvector_transport_to!(M::AbstractManifold, Y, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#Types-of-Retractions","page":"Vector Transports","title":"Types of Retractions","text":"","category":"section"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"To distinguish different types of retractions, the last argument of the (inverse) retraction specifies a type. The following ones are available.","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:type]","category":"page"},{"location":"vector_transports.html#ManifoldsBase.AbstractLinearVectorTransportMethod","page":"Vector Transports","title":"ManifoldsBase.AbstractLinearVectorTransportMethod","text":"AbstractLinearVectorTransportMethod <: AbstractVectorTransportMethod\n\nAbstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod","page":"Vector Transports","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod\n\nAbstract type for methods for transporting vectors. Such vector transports are not necessarily linear.\n\nSee also\n\nAbstractLinearVectorTransportMethod\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.DifferentiatedRetractionVectorTransport","page":"Vector Transports","title":"ManifoldsBase.DifferentiatedRetractionVectorTransport","text":"DifferentiatedRetractionVectorTransport{R<:AbstractRetractionMethod} <:\n    AbstractVectorTransportMethod\n\nA type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let mathcal M be a Riemannian manifold, pinmathcal M a point, and XYin T_pmathcal M denote two tangent vectors at p.\n\nGiven a retraction (cf. AbstractRetractionMethod) operatornameretr, the vector transport of X in direction Y (cf. vector_transport_direction) by differentiation this retraction, is given by\n\nmathcal T^operatornameretr_pYX\n= D_Yoperatornameretr_p(Y)X\n= fracmathrmdmathrmdtoperatornameretr_p(Y+tX)Bigr_t=0\n\nsee [AbsilMahonySepulchre2008], Section 8.1.2 for more details.\n\nThis can be phrased similarly as a vector_transport_to by introducing q=operatornameretr_pX and defining\n\nmathcal T^operatornameretr_q gets pX = mathcal T^operatornameretr_pYX\n\nwhich in practice usually requires the inverse_retract to exists in order to compute Y = operatornameretr_p^-1q.\n\nConstructor\n\nDifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)\n\n[AbsilMahonySepulchre2008]: Absil, P.-A., Mahony, R. and Sepulchre R., Optimization Algorithms on Matrix Manifolds Princeton University Press, 2008, doi: 10.1515/9781400830244 open access\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.ParallelTransport","page":"Vector Transports","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nCompute the vector transport by parallel transport, see parallel_transport_to\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.PoleLadderTransport","page":"Vector Transports","title":"ManifoldsBase.PoleLadderTransport","text":"PoleLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use pole_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then x = exp_pX is used to call y =pole_ladder(M, p, x, q) and the resulting vector is obtained by computing Y = -log_qy.\n\nThe PoleLadderTransport posesses two advantages compared to SchildsLadderTransport:\n\nit is cheaper to evaluate, if you want to transport several vectors, since the mid point c then stays unchanged.\nwhile both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds[Pennec2018]\n\nThe pole ladder was was proposed in [LorenziPennec2014]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.\n\nConstructor\n\nPoleLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical pole ladder that employs exp and log, i.e. as proposed in[LorenziPennec2014]. For an even cheaper transport the inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[LorenziPennec2014]: Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild‚Äôs to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5‚Äì17 doi 10.1007/s10851-013-0470-3, hal: hal-00870489\n\n[Pennec2018]: Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: 1805.11436\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.ProjectionTransport","page":"Vector Transports","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along. See project for details.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.ScaledVectorTransport","page":"Vector Transports","title":"ManifoldsBase.ScaledVectorTransport","text":"ScaledVectorTransport{T} <: AbstractVectorTransportMethod\n\nIntroduce a scaled variant of any AbstractVectorTransportMethod T, as introduced in [SatoIwai2013] for some Xin T_pmathcal M as\n\n    mathcal T^mathrmS(X) = fraclVert XrVert_plVert mathcal T(X)rVert_qmathcal T(X)\n\nNote that the resulting point q has to be known, i.e. for vector_transport_direction the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the vector_transport_to\n\nConstructor\n\nScaledVectorTransport(m::AbstractVectorTransportMethod)\n\n[SatoIwai2013]: Sato, H., Iwai, T.: A new, globally convergent Riemannian conjugate gradient method, Optimization, 2013, Volume 64(4), pp. 1011‚Äì1031. doi: 10.1080/02331934.2013.836650, arXiv: 1302.0125.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#ManifoldsBase.SchildsLadderTransport","page":"Vector Transports","title":"ManifoldsBase.SchildsLadderTransport","text":"SchildsLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use schilds_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then\n\nP^mathrmS_qgets p(X) =\n    log_qbigl( operatornameretr_p ( 2operatornameretr_p^-1c ) bigr)\n\nwhere c is the mid point between q and d=exp_pX.\n\nThis method employs the internal function schilds_ladder(M, p, d, q) that avoids leaving the manifold.\n\nThe name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [EhlersPiraniSchild1972].\n\nConstructor\n\nSchildsLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical Schilds ladder that employs exp and log, i.e. as proposed in[EhlersPiraniSchild1972]. For an even cheaper transport these inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[EhlersPiraniSchild1972]: Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O‚ÄôRaifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63‚Äì84. Clarendon Press, Oxford (1972). reprint doi: 10.1007/s10714-012-1353-4\n\n\n\n\n\n","category":"type"},{"location":"vector_transports.html#The-lower-layer-functions","page":"Vector Transports","title":"The lower layer functions","text":"","category":"section"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"While you should always add your documentation to the first layer vector transport methods above when implementing new manifolds, the actual implementation happens on the following functions on the lower layer.","category":"page"},{"location":"vector_transports.html","page":"Vector Transports","title":"Vector Transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:function]\nPublic = false\nPrivate = true","category":"page"},{"location":"vector_transports.html#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}","page":"Vector Transports","title":"ManifoldsBase._vector_transport_along!","text":"function vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::PoleLadderTransport\n)\n\nCompute the vector transport along a discretized curve using PoleLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, SchildsLadderTransport}","page":"Vector Transports","title":"ManifoldsBase._vector_transport_along!","text":"vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::SchildsLadderTransport\n)\n\nCompute the vector transport along a discretized curve using SchildsLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}","page":"Vector Transports","title":"ManifoldsBase._vector_transport_to!","text":"_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::PoleLadderTransport)\n\nPerform a vector transport by using PoleLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}","page":"Vector Transports","title":"ManifoldsBase._vector_transport_to!","text":"_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::SchildsLadderTransport)\n\nPerform a vector transport by using SchildsLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports.html#ManifoldsBase.pole_ladder","page":"Vector Transports","title":"ManifoldsBase.pole_ladder","text":"pole_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q);\n    retraction=default_retraction_method(M),\n    inverse_retraction=default_inverse_retraction_method(M)\n)\n\nCompute an inner step of the pole ladder, that can be used as a vector_transport_to. Let c = gamma_pq(frac12) mid point between p and q, then the pole ladder is given by\n\n    operatornamePl(pdq) = operatornameretr_d (2operatornameretr_d^-1c)\n\nWhere the classical pole ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nWhen you have X=log_pd and Y = -log_q operatornamePl(pdq), you will obtain the PoleLadderTransport. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after n successive steps the tangent vector reads Y_n = (-1)^nlog_q operatornamePl(p_n-1d_n-1p_n).\n\nIt is cheaper to evaluate than schilds_ladder, sinc if you want to form multiple ladder steps between p and q, but with different d, there is just one evaluation of a geodesic each., since the center c can be reused.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.pole_ladder!","page":"Vector Transports","title":"ManifoldsBase.pole_ladder!","text":"pole_ladder(\n    M,\n    pl,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nCompute the pole_ladder, i.e. the result is saved in pl. X is used for storing intermediate inverse retraction.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.schilds_ladder","page":"Vector Transports","title":"ManifoldsBase.schilds_ladder","text":"schilds_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nPerform an inner step of schilds ladder, which can be used as a vector_transport_to, see SchildsLadderTransport. Let c = gamma_qd(frac12) denote the mid point on the shortest geodesic connecting q and the point d. Then Schild's ladder reads as\n\noperatornameSl(pdq) = operatornameretr_x( 2operatornameretr_p^-1 c)\n\nWhere the classical Schilds ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nIn consistency with pole_ladder you can change the way the mid point is computed using the optional parameter c, but note that here it's the mid point between q and d.\n\nWhen you have X=log_pd and Y = log_q operatornameSl(pdq), you will obtain the PoleLadderTransport. Then the approximation to the transported vector is given by log_qoperatornameSl(pdq).\n\nWhen performing multiple steps, this method avoidsd the switching to the tangent space. Hence after n successive steps the tangent vector reads Y_n = log_q operatornamePl(p_n-1d_n-1p_n).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports.html#ManifoldsBase.schilds_ladder!","page":"Vector Transports","title":"ManifoldsBase.schilds_ladder!","text":"schilds_ladder!(\n    M,\n    sl\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nCompute schilds_ladder and return the value in the parameter sl. If the required mid point c was computed before, it can be passed using c, and the allocation of new memory can be avoided providing a tangent vector X for the interims result.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#sec-retractions","page":"Retractions","title":"Retractions and inverse Retractions","text":"","category":"section"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"The exponential and logarithmic map might be too expensive to evaluate or not be available in a very stable numerical way. Retractions provide a possibly cheap, fast and stable alternative.","category":"page"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"The following figure compares the exponential map exp(M, p, X) on the Circle (‚ÑÇ) (or Sphere(1) embedded in ‚Ñù^2 with one possible retraction, the one based on projections. Note especially that mathrmdist(pq)=lVert XrVert_p while this is not the case for q.","category":"page"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"(Image: A comparson of the exponential map and a retraction on the Circle.)","category":"page"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\"]\nOrder = [:function]\nPrivate = false\nPublic = true","category":"page"},{"location":"retractions.html#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::AbstractManifold)\n\nThe AbstractInverseRetractionMethod that is used when calling inverse_retract without specifying the inverse retraction method. By default, this is the LogarithmicInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::AbstractManifold)\n\nThe AbstractRetractionMethod that is used when calling retract without specifying the retraction method. By default, this is the ExponentialRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract","page":"Retractions","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractManifold, p, q)\ninverse_retract(M::AbstractManifold, p, q, method::AbstractInverseRetractionMethod\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). For available inverse retractions on certain manifolds see the documentation on the corresponding manifold.\n\nSee also retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract!","page":"Retractions","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::AbstractManifold, X, p, q[, method::AbstractInverseRetractionMethod])\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M. Result is saved to X.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee also retract!.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract","page":"Retractions","title":"ManifoldsBase.retract","text":"retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod=default_retraction_method(M))\nretract(M::AbstractManifold, p, X, t::Real=1, method::AbstractRetractionMethod=default_retraction_method(M))\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold M.\n\nA retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfills\n\noperatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M to T_pmathcal M is the identity map, i.e. Doperatornameretr_p(0)X=X,\n\nwhere Doperatornameretr_p denotes the differential of the retraction\n\nThe retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). For further available retractions see the documentation of respective manifolds.\n\nLocally, the retraction is invertible. For the inverse operation, see inverse_retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract!","page":"Retractions","title":"ManifoldsBase.retract!","text":"retract!(M::AbstractManifold, q, p, X)\nretract!(M::AbstractManifold, q, p, X, t::Real=1)\nretract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod)\nretract!(M::AbstractManifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold manifold M. Result is saved to q.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee retract for more details.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_polar!","page":"Retractions","title":"ManifoldsBase.retract_polar!","text":"retract_polar!(M::AbstractManifold, q, p, X)\n\ncomputes the mutating variant of the PolarRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_polar","text":"retract_polar(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PolarRetraction, which by default allocates and calls retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_project!","page":"Retractions","title":"ManifoldsBase.retract_project!","text":"retract_project!(M::AbstractManifold, q, p, X)\n\ncomputes the mutating variant of the ProjectionRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_project-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_project","text":"retract_polar(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PolarRetraction, which by default allocates and calls retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_qr!","page":"Retractions","title":"ManifoldsBase.retract_qr!","text":"retract_qr!(M::AbstractManifold, q, p, X)\n\ncomputes the mutating variant of the QRRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_qr-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_qr","text":"retract_polar(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PolarRetraction, which by default allocates and calls retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#Types-of-Retractions","page":"Retractions","title":"Types of Retractions","text":"","category":"section"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"To distinguish different types of retractions, the last argument of the (inverse) retraction specifies a type. The following ones are available.","category":"page"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\"]\nOrder = [:type]","category":"page"},{"location":"retractions.html#ManifoldsBase.AbstractInverseRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.AbstractRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ApproximateInverseRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateInverseRetraction","text":"ApproximateInverseRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate inverse retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ApproximateRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateRetraction","text":"ApproximateRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.CayleyRetraction","page":"Retractions","title":"ManifoldsBase.CayleyRetraction","text":"CayleyRetraction <: AbstractRetractionMethod\n\nA retraction based on the Cayley transform, which is realized by using the PadeRetraction{1}.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.EmbeddedInverseRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedInverseRetraction","text":"EmbeddedInverseRetraction{T<:AbstractInverseRetractionMethod} <: AbstractInverseRetractionMethod\n\nCompute an inverse retraction by using the inverse retraction of type T in the embedding and projecting the result\n\nConstructor\n\nEmbeddedInverseRetraction(r::AbstractInverseRetractionMethod)\n\nGenerate the inverse retraction with inverse retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.EmbeddedRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedRetraction","text":"EmbeddedRetraction{T<:AbstractRetractionMethod} <: AbstractRetractionMethod\n\nCompute a retraction by using the retraction of type T in the embedding and projecting the result.\n\nConstructor\n\nEmbeddedRetraction(r::AbstractRetractionMethod)\n\nGenerate the retraction with retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ExponentialRetraction","page":"Retractions","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction <: AbstractRetractionMethod\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.LogarithmicInverseRetraction","page":"Retractions","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.NLSolveInverseRetraction","page":"Retractions","title":"ManifoldsBase.NLSolveInverseRetraction","text":"NLSolveInverseRetraction{T<:AbstractRetractionMethod,TV,TK} <:\n    ApproximateInverseRetraction\n\nAn inverse retraction method for approximating the inverse of a retraction using NLsolve.\n\nConstructor\n\nNLSolveInverseRetraction(\n    method::AbstractRetractionMethod[, X0];\n    project_tangent=false,\n    project_point=false,\n    nlsolve_kwargs...,\n)\n\nConstructs an approximate inverse retraction for the retraction method with initial guess X0, defaulting to the zero vector. If project_tangent is true, then the tangent vector is projected before the retraction using project. If project_point is true, then the resulting point is projected after the retraction. nlsolve_kwargs are keyword arguments passed to NLsolve.nlsolve.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ODEExponentialRetraction","page":"Retractions","title":"ManifoldsBase.ODEExponentialRetraction","text":"ODEExponentialRetraction{T<:AbstractRetractionMethod, B<:AbstractBasis} <: AbstractRetractionMethod\n\nApproximate the exponential map on the manifold by evaluating the ODE descripting the geodesic at 1, assuming the default connection of the given manifold by solving the ordinary differential equation\n\nfracd^2dt^2 p^k + Œì^k_ij fracddt p_i fracddt p_j = 0\n\nwhere Œì^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed.\n\nConstructor\n\nODEExponentialRetraction(\n    r::AbstractRetractionMethod,\n    b::AbstractBasis=DefaultOrthogonalBasis(),\n)\n\nGenerate the retraction with a retraction to use internally (for some approaches) and a basis for the tangent space(s).\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.PadeRetraction","page":"Retractions","title":"ManifoldsBase.PadeRetraction","text":"PadeRetraction{m} <: AbstractRetractionMethod\n\nA retraction based on the Pad√© approximation of order m\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.PolarInverseRetraction","page":"Retractions","title":"ManifoldsBase.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.PolarRetraction","page":"Retractions","title":"ManifoldsBase.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ProjectionInverseRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.ProjectionRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.QRInverseRetraction","page":"Retractions","title":"ManifoldsBase.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.QRRetraction","page":"Retractions","title":"ManifoldsBase.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.SoftmaxInverseRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxInverseRetraction","text":"SoftmaxInverseRetraction <: AbstractInverseRetractionMethod\n\nDescribes an inverse retraction that is based on the softmax function.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#ManifoldsBase.SoftmaxRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxRetraction","text":"SoftmaxRetraction <: AbstractRetractionMethod\n\nDescribes a retraction that is based on the softmax function.\n\n\n\n\n\n","category":"type"},{"location":"retractions.html#The-lower-layer-functions","page":"Retractions","title":"The lower layer functions","text":"","category":"section"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"While you should always add your documentation to retract or retract! when implementing new manifolds, the actual implementation happens on the following functions on the lower layer.","category":"page"},{"location":"retractions.html","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\"]\nOrder = [:function]\nPublic = false\nPrivate = true","category":"page"},{"location":"retractions.html#ManifoldsBase.inverse_retract_embedded!-Tuple{AbstractManifold, Any, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_embedded!","text":"inverse_retract_embedded!(M::AbstractManifold, X, p, q, m)\n\ncomputes the mutating variant of the EmbeddedInverseRetraction using the AbstractInverseRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_embedded-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_embedded","text":"inverse_retract_embedded(M::AbstractManifold, p, q, m)\n\ncomputes the allocating variant of the EmbeddedInverseRetraction using the AbstractInverseRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_nlsolve!","page":"Retractions","title":"ManifoldsBase.inverse_retract_nlsolve!","text":"inverse_retract_nlsolve!(M::AbstractManifold, X, p, q, m)\n\ncomputes the mutating variant of the NLSolveInverseRetraction m.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract_nlsolve-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_nlsolve","text":"inverse_retract_nlsolve(M::AbstractManifold, p, q, m)\n\ncomputes the allocating variant of the NLSolveInverseRetraction m, which by default allocates and calls inverse_retract_nlsolve!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_polar!","page":"Retractions","title":"ManifoldsBase.inverse_retract_polar!","text":"inverse_retract_polar!(M::AbstractManifold, X, p, q)\n\ncomputes the mutating variant of the PolarInverseRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract_polar-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_polar","text":"inverse_retract_polar(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PolarInverseRetraction, which by default allocates and calls inverse_retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_project!","page":"Retractions","title":"ManifoldsBase.inverse_retract_project!","text":"inverse_retract_project!(M::AbstractManifold, X, p, q)\n\ncomputes the mutating variant of the ProjectionInverseRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract_project-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_project","text":"inverse_retract_project(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the ProjectionInverseRetraction, which by default allocates and calls inverse_retract_project!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_qr!","page":"Retractions","title":"ManifoldsBase.inverse_retract_qr!","text":"inverse_retract_qr!(M::AbstractManifold, X, p, q)\n\ncomputes the mutating variant of the QRInverseRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract_qr-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_qr","text":"inverse_retract_qr(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the QRInverseRetraction, which by default allocates and calls inverse_retract_qr!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.inverse_retract_softmax!","page":"Retractions","title":"ManifoldsBase.inverse_retract_softmax!","text":"inverse_retract_softmax!(M::AbstractManifold, X, p, q)\n\ncomputes the mutating variant of the SoftmaxInverseRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.inverse_retract_softmax-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_softmax","text":"inverse_retract_softmax(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the SoftmaxInverseRetraction, which by default allocates and calls inverse_retract_softmax!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_embedding!-Tuple{AbstractManifold, Any, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_embedding!","text":"retract_embedded!(M::AbstractManifold, X, p, q, m)\n\ncomputes the mutating variant of the EmbeddedRetraction using the AbstractRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_embedding-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_embedding","text":"retract_embedded(M::AbstractManifold, p, X, m)\n\ncomputes the allocating variant of the EmbeddedRetraction using the AbstractRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_exp_ode!","page":"Retractions","title":"ManifoldsBase.retract_exp_ode!","text":"retract_exp_ode!(M::AbstractManifold, q, p, X, m, B)\n\ncomputes the mutating variant of the ODEExponentialRetraction(m, B).\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_exp_ode-Tuple{AbstractManifold, Any, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_exp_ode","text":"retract_polar(M::AbstractManifold, p, q, m, B)\n\ncomputes the allocating variant of the EmbeddedRetraction(m,B), which by default allocates and calls retract_exp_ode!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_pade!","page":"Retractions","title":"ManifoldsBase.retract_pade!","text":"retract_pade!(M::AbstractManifold, q, p, n)\n\ncomputes the mutating variant of the PadeRetraction(n).\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_pade-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_pade","text":"retract_pade(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PadeRetraction(n), which by default allocates and calls retract_pade!.\n\n\n\n\n\n","category":"method"},{"location":"retractions.html#ManifoldsBase.retract_softmax!","page":"Retractions","title":"ManifoldsBase.retract_softmax!","text":"retract_softmax!(M::AbstractManifold, q, p, X)\n\ncomputes the mutating variant of the SoftmaxRetraction.\n\n\n\n\n\n","category":"function"},{"location":"retractions.html#ManifoldsBase.retract_softmax-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_softmax","text":"retract_softmax(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the SoftmaxRetraction, which by default allocates and calls retract_softmax!.\n\n\n\n\n\n","category":"method"},{"location":"design.html#Main-Design-Principles","page":"Design principles","title":"Main Design Principles","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from Manopt.jl can be implemented on arbitrary manifolds.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The main design criteria for the interface are:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Aims to also provide efficient global state-free, both in-place and out-of-place computations whenever possible.\nProvide a high level interface that is easy to use.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Therefore this interface has 3 main features, that we will explain using two (related) concepts, the exponential map that maps a tangent vector X at a point p to a point q or mathematically exp_pT_pmathcal M to mathcal M and its generalization, a retraction operatornameretr_p with same domain and range.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"You do not need to know their exact definition at this point, just that there is one exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (sometime called exponential retraction for completeness). Every retraction has its own subtype of the AbstractRetractionMethod that uniquely defines it.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The following three design patterns aim to fulfill the criteria from above, while also avoiding ambiguities in multiple dispatch using the dispatch on one argument at a time approach.","category":"page"},{"location":"design.html#General-order-of-parameters","page":"Design principles","title":"General order of parameters","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for mutating functions. Then the classical parametzers of a function (for example a point and a tangent vector for the retraction) follow and the final part are parameters to further dispatch on, which usually have their defaults.","category":"page"},{"location":"design.html#A-3-Layer-architecture-for-dispatch","page":"Design principles","title":"A 3-Layer architecture for dispatch","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The general architecture consists of three layers","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The high level interface for ease of use ‚Äì and to dispatch on other manifolds\nan interims layer to dispatch on different parameters in the last section\nthe lowest layer with a specific manifold and no optional parameters for performance","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"These three layers are described in more detail in the following. The main motivation to introduce this separation is reduction of method ambiguity problems.","category":"page"},{"location":"design.html#design-layer1","page":"Design principles","title":"Layer I: The high level interface and ease of use","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"THe highest layer for convenience of decorators. A usual scheme is, that a manifold might assume several things implicitly, for example the default implementation of the sphere mathbb S^n using unit vectors in mathbb R^n+1. The embedding can be explicitly used to avoid re-implementations ‚Äì the inner product can be ‚Äúpassed on‚Äù to its embedding.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To do so, we ‚Äúdecorate‚Äù the manifold by making it an AbstractDecoratorManifold and activating the right traits see the example.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The explicit case of the EmbeddedManifold can be used to distinguish different embeddings of a manifold, but also their dispatch (onto the manifold or its embedding, depending on the type of embedding) happens here.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Note that all other parameters of a function should be as unspecific as possible on this layer.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"With respect to the dispatch on one argument at a time paradigm, this layer dispatches the manifold first, but here we stay oon an abstract type level.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This layer ends usually in calling the same functions like retract but prefixed with a _ to enter Layer II.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nUsually only functions from this layer are exported from the interface, since these are the ones one should use for generic implementations. If you implement your own manifold, import the necessary lower layer functions as needed.","category":"page"},{"location":"design.html#design-layer2","page":"Design principles","title":"Layer II: An internal dispatch interface for parameters","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This layer is an interims layer to dispatch on the (optional/default) parameters of a function like the retraction: retract has a last parameter that determines the type. The last function in the previous layer calls _retract, which is an internal function.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"On this layer, e.g. for _retract only these last parameters should be typed, the manifold should stay at the AbstractManifold level. It dispatches on different functions per existing parameter type (and might pass this one further on, if it has fields).","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Note that this layer is an internal one. It is automatically called for functions with parameters to dispatch on.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"It should only be extended when introducing new such parameter types, for example when introducing a new type of a retraction.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The functions from this layer should never be called directly, are hence also not exported and carry the _ prefix. They should only be called as the final step in the previous layer.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"If the default parameters are not dispatched per type, using _ might be skipped. The following resolution might even be seen as a last step in layer I or the resolution here in layer II.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"exp(M::AbstractManifold, p, X, t::Real) = exp(M, p, t * X)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"When there is no dispatch for different types of the optional parameter (here t), the _ might be skipped. One could hence see the last code line as a definition on Layer I that passes directly to Layer III, since there are not parameter to dispatch on.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To close this section, let‚Äòs look at an example. The high level (or level I) definition of the retraction is given by","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"retract(M::AbstractManifold, p, X, m::AbstractRetractionMethod=default_retraction_method(M)) = _retract(M,p,X,m)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This level now dispatches on different retraction types. It usually passes to specific functions implemented in Layer III, here for example","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"_retract(M::AbstractManifold, p, X, m::Exponentialretraction) = exp(M,p,X)\n_retract(M::AbstractManifold, p, X, m::PolarRetraction) = retract_polar(M,p,X)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"or the PolarRetraction which dispatches to retract_polar.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"For further details and dispatches, see retractions and inverse retractions for an overview.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nThe documentation should be attached to the high level functions, since this again fosters ease of use. If yuo implement a polar retraction, you should write a function polar_retract but the doc string should be attached to retract(::M, ::P, ::V, ::PolarRetraction) for your types ::M, ::P, ::V of the manifold, points and vectors, respectively.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the (optional) parameters second.","category":"page"},{"location":"design.html#design-layer3","page":"Design principles","title":"Layer III: The base layer with focus on implementations","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This lower level aims for the actual implementation of the function avoiding ambiguities. It should have as few as possible optional parameters and as concrete as possible types. This means","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"the function name should be similar to its high level parent (for example retract and retract_polar  above)\nThe manifold type in method signature should always be as narrow as possible.\nthe points/vectors should either be untyped (for the default representation of if there is only one implementation) or provide all types concretely (for second representations or when using AbstractManifoldPoint and TVector).","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The first step that might happen on this level is, that an allocating function allocates memory and calls the mutating function. If faster, it might also implement the function at hand itself.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Usually functions from this layer are not exported, when they have an analogue on the first layer. For example the function retract_polar(M, p, X) is not exported, since when using the interface one would use the PolarRetraction or to be precise call retract(M, p, X, PolarRetraction()). When implementing your own manifold, you have to import functions like these anyways.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the concrete manifold and point/vector types last.","category":"page"},{"location":"design.html#Mutating-and-allocating-functions","page":"Design principles","title":"Mutating and allocating functions","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Every function, where this is applicable should provide a mutating and an allocating variant. For example for the exponential map exp(M,p,x) returns a new point q where the result is computed in. On the other hand exp!(M, q, p, X) computes the result in place of q, where the design of the implementation should keep in mind that also exp!(M,p,p,X) should correctly overwrite p.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like exp is to allocate the resulting memory and call exp!.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nit might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the mutating variants.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Non-mutating functions in ManifoldsBase.jl are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The allocate function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), checked types like ValidationMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The function allocate_result allocates a correct return value. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the allocate_result_type function. The most prominent example of the usage of this function is the logarithmic function log when used with typed points. Lets assume on a manifold M the have points of type P and corresponding tangent vector types V. then the logarithmic map has the signature","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"log(::M, ::P, ::P)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"but the return type would be V, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by omplementing a allocate_result(::M, ::typeof(log), ::P, ::P)that returns the concrete variable for the return. This way, even with specific types, one just has to implement log! and the one line for the allocation.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nThis dispatch from the allocating to the mutating variant happens in Layer III, that is, functions like exp or retract_polar (but not retract itself) allocate their result (using ::typeof(retract) for the second function) and call the mutating variant exp! and retract_polar! afterwards.","category":"page"},{"location":"manifolds.html#Manifolds","page":"Manifolds","title":"Manifolds","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"While the interface ManifoldsBase.jl does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds","category":"page"},{"location":"manifolds.html#sec-power-manifold","page":"Manifolds","title":"(Abstract) Power Manifold","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"A power manifold is constructed like higher dimensional vector spaces are formed from the real line, just that for every point p = (p_1ldotsp_n)  mathcal M^n on the power manifold mathcal M^n the entries of p are points p_1ldotsp_n  mathcal M on some manifold mathcal M.","category":"page"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"src/PowerManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"manifolds.html#ManifoldsBase.AbstractPowerManifold","page":"Manifolds","title":"ManifoldsBase.AbstractPowerManifold","text":"AbstractPowerManifold{ùîΩ,M,TPR} <: AbstractManifold{ùîΩ}\n\nAn abstract AbstractManifold to represent manifolds that are build as powers of another AbstractManifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.AbstractPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.NestedPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is modified in-place, differently than in NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.NestedReplacingPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.NestedReplacingPowerRepresentation","text":"NestedReplacingPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.PowerBasisData","page":"Manifolds","title":"ManifoldsBase.PowerBasisData","text":"PowerBasisData{TB<:AbstractArray}\n\nData storage for an array of basis data.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.PowerManifold","page":"Manifolds","title":"ManifoldsBase.PowerManifold","text":"PowerManifold{ùîΩ,TM<:AbstractManifold,TSize<:Tuple,TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{ùîΩ,TM}\n\nThe power manifold mathcal M^n_1 n_2    n_d with power geometry  TSize statically defines the number of elements along each axis.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.\n\nConstructor\n\nPowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)\nPowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)\nM^(N_1, N_2, ..., N_d)\n\nGenerate the power manifold M^N_1  N_2    N_d. By default, a [PowerManifold](@ref} is expanded further, i.e. for M=PowerManifold(N,3) PowerManifold(M,2) is equivalend to PowerManifold(N,3,2). Points are then 3√ó2 matrices of points on N. Providing a NestedPowerRepresentation as the second argument to the constructor can be used to nest manifold, i.e. PowerManifold(M,NestedPowerRepresentation(),2) represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.\n\nSince there is no default AbstractPowerRepresentation within this interface, the ^ operator is only available for PowerManifolds and concatenates dimensions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}","page":"Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, Y, p, X)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, B, a, A) for all elements A, a and B of X, p, and Y, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}","page":"Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, q, p)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, b, a) for all elements a and b of p and q, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"Base.exp","text":"exp(M::AbstractPowerManifold, p, X)\n\nCompute the exponential map from p in direction X on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.getindex","text":"getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\np[M::AbstractPowerManifold, i...]\n\nAccess the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"Base.log","text":"log(M::AbstractPowerManifold, p, q)\n\nCompute the logarithmic map from p to q on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.setindex!","text":"setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\nq[M::AbstractPowerManifold, i...] = p\n\nSet the element(s) at index [i...] of a point q on an AbstractPowerManifold M by linear or multidimensional indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.view","text":"view(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\n\nGet the view of the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, p, X)\n\nCompute the norm of X from the tangent space of p on an AbstractPowerManifold M, i.e. from the element wise norms the Frobenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractPowerManifold, p; kwargs...)\n\nCheck whether p is a valid point on an AbstractPowerManifold M, i.e. each element of p has to be a valid point on the base manifold. If p is not a point on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractPowerManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p an the AbstractPowerManifold M, i.e. atfer check_point(M, p), and all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q)\n\nCompute the distance between q and p on an AbstractPowerManifold, i.e. from the element wise distances the Forbenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.get_component","text":"get_component(M::AbstractPowerManifold, p, idx...)\n\nGet the component of a point p on an AbstractPowerManifold M at index idx.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, p])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point p it's equal to the minimum of all radii in the array entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Manifolds","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from X and Y are in the tangent space of the corresponding element from p. The inner product is then the sum of the elementwise inner products.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the inverse retraction from p with respect to q on an AbstractPowerManifold M using an AbstractInverseRetractionMethod. Then this method is performed elementwise, so the inverse retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}","page":"Manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1n_d, i.e. with n=(n_1n_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\ndim(mathcal N) = dim(mathcal M)prod_i=1^d n_i = n_1n_2cdotcdot n_d dim(mathcal M)\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}","page":"Manifolds","title":"ManifoldsBase.power_dimensions","text":"power_dimensions(M::PowerManifold)\n\nreturn the power of M,\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p, X)\n\nProject the point X onto the tangent space at p on the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p)\n\nProject the point p from the embedding onto the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, p, X, method::AbstractRetractionMethod)\n\nCompute the retraction from p with tangent vector X on an AbstractPowerManifold M using a AbstractRetractionMethod. Then this method is performed elementwise, so the retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.set_component!","text":"set_component!(M::AbstractPowerManifold, q, p, idx...)\n\nSet the component of a point q on an AbstractPowerManifold M at index idx to p, which itself is a point on the AbstractManifold the power manifold is build on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}","page":"Manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nCompute the vector transport the tangent vector Xat p to q on the PowerManifold M using an AbstractVectorTransportMethod m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ValidationManifold","page":"Manifolds","title":"ValidationManifold","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"ValidationManifold is a simple decorator using the AbstractDecoratorManifold that ‚Äúdecorates‚Äù a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling is_point or is_vector whenever applicable.","category":"page"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"ValidationManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"manifolds.html#ManifoldsBase.ValidationCoTVector","page":"Manifolds","title":"ManifoldsBase.ValidationCoTVector","text":"ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}\n\nRepresent a cotangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.ValidationFibreVector","page":"Manifolds","title":"ManifoldsBase.ValidationFibreVector","text":"ValidationFibreVector{TType<:VectorSpaceType} <: AbstractFibreVector{TType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.ValidationMPoint","page":"Manifolds","title":"ManifoldsBase.ValidationMPoint","text":"ValidationMPoint <: AbstractManifoldPoint\n\nRepresent a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationTVectors and ValidationCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.ValidationManifold","page":"Manifolds","title":"ManifoldsBase.ValidationManifold","text":"ValidationManifold{ùîΩ,M<:AbstractManifold{ùîΩ}} <: AbstractDecoratorManifold{ùîΩ}\n\nA manifold to encapsulate manifolds working on array representations of AbstractManifoldPoints and TVectors in a transparent way, such that for these manifolds it's not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a AbstractManifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.ValidationTVector","page":"Manifolds","title":"ManifoldsBase.ValidationTVector","text":"ValidationTVector = ValidationFibreVector{TangentSpaceType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"Manifolds","title":"ManifoldsBase.array_value","text":"array_value(p)\n\nReturn the internal array value of an ValidationMPoint, ValidationTVector, or ValidationCoTVector if the value p is encapsulated as such. Return p if it is already an array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#DefaultManifold","page":"Manifolds","title":"DefaultManifold","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using Manifolds.jl the Euclidean is available, the DefaultManifold itself is not exported.","category":"page"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"ManifoldsBase.DefaultManifold","category":"page"},{"location":"manifolds.html#ManifoldsBase.DefaultManifold","page":"Manifolds","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: AbstractManifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#sec-embedded-manifold","page":"Manifolds","title":"EmbeddedManifold","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"The embedded manifold is a manifold mathcal N which is modelled explicitly mentioning its embedding mathcal N in which the points and tangent vectors are represented. Most prominently is_point and is_vector of an embedded manifold are implemented to check whether the point is a valid point in the embedding. This can of course still be extended by further tests. ManifoldsBase.jl provides two possibilities of easily introducing this in order to dispatch some functions to the embedding.","category":"page"},{"location":"manifolds.html#subsec-implicit-embedded","page":"Manifolds","title":"Implicit case: the IsEmbeddedManifold Trait","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"For the implicti case, your manifold has to be a subtype of the AbstractDecoratorManifold. Setting the active_traits function to the AbstractTrait IsEmbeddedManifold, makes a manifold an embedded manifold. you just have to also define get_embedding such that functions are passed on to that embedding. This is the implicit case, since the manifold type itself does not carry any information about the embedding, just the trait and the function definition do.","category":"page"},{"location":"manifolds.html#subsec-explicit-embedded","page":"Manifolds","title":"Explicit case: the EmbeddedManifold","text":"","category":"section"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"The EmbeddedManifold itself is an AbstractDecoratorManifold so it is a case of the implicit embedding itself, but internally stores both the original manifold and the embedding. They are also parameters of the type. This way, additional embeddings can be modelled. That is, if the manifold is implemented using the implicit embedding approach from before but can also be implemented using a different embedding, then this method should be chosen, since you can dispatch functions that you want to implement in this embedding then on the type which explicitly has the manifold and its embedding as parameters.","category":"page"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"Hence this case should be used for any further embedding after the first or if the default implementation works without an embedding and the alternative needs one.","category":"page"},{"location":"manifolds.html","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"manifolds.html#ManifoldsBase.EmbeddedManifold","page":"Manifolds","title":"ManifoldsBase.EmbeddedManifold","text":"EmbeddedManifold{ùîΩ, MT <: AbstractManifold, NT <: AbstractManifold} <: AbstractDecoratorManifold{ùîΩ}\n\nA type to represent an explicit embedding of a AbstractManifold M of type MT embedded into a manifold N of type NT. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold.\n\nnote: Note\nThis type is not required if a manifold M is to be embedded in one specific manifold N.  One can then just implement embed! and project!. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an AbstractDecoratorManifold. Only for a second ‚Äìmaybe considered non-default‚Äì embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings N.\n\nFields\n\nmanifold the manifold that is an embedded manifold\nembedding a second manifold, the first one is embedded into\n\nConstructor\n\nEmbeddedManifold(M, N)\n\nGenerate the EmbeddedManifold of the AbstractManifold M into the AbstractManifold N.\n\n\n\n\n\n","category":"type"},{"location":"manifolds.html#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the manifold of M that is decorated with its embedding. For this specific type the internally stored enhanced manifold M.manifold is returned.\n\nSee also base_manifold, where this is used to (potentially) completely undecorate the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds.html#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::EmbeddedManifold)\n\nReturn the embedding AbstractManifold N of M, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#Bases-for-tangent-spaces","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"","category":"section"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The following functions and types provide support for bases of the tangent space of different manifolds. Moreover, bases of the cotangent space are also supported, though this description focuses on the tangent space. An orthonormal basis of the tangent space T_p mathcal M of (real) dimension n has a real-coefficient basis e_1 e_2  e_n if mathrmRe(g_p(e_i e_j)) = Œ¥_ij for each ij  1 2  n where g_p is the Riemannian metric at point p. A vector X from the tangent space T_p mathcal M can be expressed in Einstein notation as a sum X = X^i e_i, where (real) coefficients X^i are calculated as X^i = mathrmRe(g_p(X e_i)).","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main types are:","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"DefaultOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nCachedBasis, which stores (explicitly or implicitly) a precomputed basis at a certain point.","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main functions are:","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"Modules = [ManifoldsBase]\nPages = [\"bases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bases.html#ManifoldsBase.AbstractBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractBasis","text":"AbstractBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents a basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.AbstractOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthogonalBasis","text":"AbstractOrthogonalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.AbstractOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.CachedBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.CachedBasis","text":"CachedBasis{ùîΩ,V,<:AbstractBasis{ùîΩ}} <: AbstractBasis{ùîΩ}\n\nA cached version of the given basis with precomputed basis vectors. The basis vectors are stored in data, either explicitly (like in cached variants of ProjectedOrthonormalBasis) or implicitly.\n\nConstructor\n\nCachedBasis(basis::AbstractBasis, data)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultBasis","text":"DefaultBasis{ùîΩ,VST<:VectorSpaceType}\n\nAn arbitrary basis of vector space of type VST on a manifold. This will usually be the fastest basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthogonalBasis","text":"DefaultOrthogonalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAn arbitrary orthogonal basis of vector space of type VST on a manifold. This will usually be the fastest orthogonal basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthonormalBasis","text":"DefaultOrthonormalBasis(ùîΩ::AbstractNumbers = ‚Ñù, vs::VectorSpaceType = TangentSpace)\n\nAn arbitrary orthonormal basis of vector space of type VST on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DiagonalizingOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis{ùîΩ,TV} <: AbstractOrthonormalBasis{ùîΩ,TangentSpaceType}\n\nAn orthonormal basis Œû as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction frame_direction v has curvature 0.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nConstructor\n\nDiagonalizingOrthonormalBasis(frame_direction, ùîΩ::AbstractNumbers = ‚Ñù)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.GramSchmidtOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.GramSchmidtOrthonormalBasis","text":"GramSchmidtOrthonormalBasis{ùîΩ} <: AbstractOrthonormalBasis{ùîΩ}\n\nAn orthonormal basis obtained from a basis.\n\nConstructor\n\nGramSchmidtOrthonormalBasis(ùîΩ::AbstractNumbers = ‚Ñù)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.ProjectedOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, ùîΩ::AbstractNumbers = ‚Ñù)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.VectorSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space fiber is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector(fiber, p) to construct zero vectors at point p,\nallocate(X) and allocate(X, T) for vector X and type T,\ncopyto!(X, Y) for vectors X and Y,\nnumber_eltype(v) for vector v,\nvector_space_dimension.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject (for embedded vector spaces),\nrepresentation_size,\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.allocate_coordinates-Tuple{AbstractManifold, Any, Any, Int64}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocate_coordinates","text":"allocate_coordinates(M::AbstractManifold, p, T, n::Int)\n\nAllocate vector of coordinates of length n of type T of a vector at point p on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocation_promotion_function","text":"allocation_promotion_function(M::AbstractManifold, f, args::Tuple)\n\nDetermine the function that must be used to ensure that the allocated representation is of the right type. This is needed for get_vector when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.dual_basis","text":"dual_basis(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the dual basis to B, a basis of a vector space at point p from manifold M.\n\nThe dual to the ith vector v_i from basis B is a vector v^i from the dual space such that v^i(v_j) = Œ¥^i_j, where Œ¥^i_j is the Kronecker delta symbol:\n\nŒ¥^i_j = begincases\n1  text if  i=j \n0  text otherwise\nendcases\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_basis","text":"get_basis(M::AbstractManifold, p, B::AbstractBasis; kwargs...) -> CachedBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by p.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractManifold, p, X, B::AbstractBasis)\nget_coordinates(M::AbstractManifold, p, X, B::CachedBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector X at point denoted by p on manifold M in basis B.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve. If a CachedBasis is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.\n\nFor the CachedBasis keep in mind that the reconstruction with get_vector requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vector","text":"X = get_vector(M::AbstractManifold, p, c, B::AbstractBasis)\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at p on manifold M to a tangent vector X at p.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve.\n\nFor the CachedBasis keep in mind that the reconstruction from get_coordinates requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_coordinates, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vectors","text":"get_vectors(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the basis vectors of basis B of the tangent space at point p.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.gram_schmidt-Union{Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, Any, ManifoldsBase.AbstractBasis{ùîΩ}}} where ùîΩ","page":"Bases for tangent spaces","title":"ManifoldsBase.gram_schmidt","text":"gram_schmidt(M::AbstractManifold{ùîΩ}, p, B::AbstractBasis{ùîΩ}) where {ùîΩ}\ngram_schmidt(M::AbstractManifold, p, V::AbstractVector)\n\nCompute an ONB in the tangent space at p on the [AbstractManifold](@ref} M from either an AbstractBasis basis ¬¥B¬¥ or a set of (at most) manifold_dimension(M) many vectors. Note that this method requires the manifold and basis to work on the same AbstractNumbers ùîΩ, i.e. with real coefficients.\n\nThe method always returns a basis, i.e. linearly dependent vectors are removed.\n\nKeyword arguments\n\nwarn_linearly_dependent (false) ‚Äì warn if the basis vectors are not linearly independent\nskip_linearly_dependent (false) ‚Äì whether to just skip (true) a vector that is linearly dependent to the previous ones or to stop (false, default) at that point\nreturn_incomplete_set (false) ‚Äì throw an error if the resulting set of vectors is not a basis but contains less vectors\n\nfurther keyword arguments can be passed to set the accuracy of the independence test. Especially atol is raised slightly by default to atol = 5*1e-16.\n\nReturn value\n\nWhen a set of vectors is orthonormalized a set of vectors is returned. When an AbstractBasis is orthonormalized, a CachedBasis is returned.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.hat","text":"hat(M::AbstractManifold, p, X‚Å±)\n\nGiven a basis e_i on the tangent space at a point p and tangent component vector X^i, compute the equivalent vector representation X=X^i e_i, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.number_of_coordinates-Union{Tuple{ùîæ}, Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, ManifoldsBase.AbstractBasis{ùîæ}}} where {ùîΩ, ùîæ}","page":"Bases for tangent spaces","title":"ManifoldsBase.number_of_coordinates","text":"number_of_coordinates(M::AbstractManifold{ùîΩ}, B::AbstractBasis)\nnumber_of_coordinates(M::AbstractManifold{ùîΩ}, ::ùîæ)\n\nCompute the number of coordinates in basis of field type ùîæ on a manifold M. This also corresponds to the number of vectors represented by B, or stored within B in case of a CachedBasis.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"Bases for tangent spaces","title":"ManifoldsBase.number_system","text":"number_system(::AbstractBasis)\n\nThe number system for the vectors of the given basis.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.vee","text":"vee(M::AbstractManifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"Modules = [ManifoldsBase]\nPages = [\"vector_spaces.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bases.html#ManifoldsBase.AbstractFibreVector","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractFibreVector","text":"AbstractFibreVector{TType<:VectorSpaceType}\n\nType for a vector from a vector space (fibre of a vector bundle) of type TType of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\nYou may use macro @manifold_vector_forwards to introduce commonly used method definitions for your subtype of AbstractFibreVector.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.CoTVector","page":"Bases for tangent spaces","title":"ManifoldsBase.CoTVector","text":"CoTVector = AbstractFibreVector{CotangentSpaceType}\n\nType for a cotangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.FVector","page":"Bases for tangent spaces","title":"ManifoldsBase.FVector","text":"FVector(type::VectorSpaceType, data, basis::AbstractBasis)\n\nDecorator indicating that the vector data contains coordinates of a vector from a fiber of a vector bundle of type type. basis is an object describing the basis of that space in which the coordinates are given.\n\nConversion between FVector representation and the default representation of an object (for example a tangent vector) for a manifold should be done using get_coordinates and get_vector.\n\nExamples\n\njulia> using Manifolds\n\njulia> M = Sphere(2)\nSphere(2, ‚Ñù)\n\njulia> p = [1.0, 0.0, 0.0]\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> X = [0.0, 2.0, -1.0]\n3-element Vector{Float64}:\n  0.0\n  2.0\n -1.0\n\njulia> B = DefaultOrthonormalBasis()\nDefaultOrthonormalBasis(‚Ñù)\n\njulia> fX = TFVector(get_coordinates(M, p, X, B), B)\nTFVector([2.0, -1.0], DefaultOrthonormalBasis(‚Ñù))\n\njulia> X_back = get_vector(M, p, fX.data, fX.basis)\n3-element Vector{Float64}:\n -0.0\n  2.0\n -1.0\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.TVector","page":"Bases for tangent spaces","title":"ManifoldsBase.TVector","text":"TVector = AbstractFibreVector{TangentSpaceType}\n\nType for a tangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, ManifoldsBase.VectorSpaceType}","page":"Bases for tangent spaces","title":"ManifoldsBase.vector_space_dimension","text":"vector_space_dimension(M::AbstractManifold, V::VectorSpaceType)\n\nDimension of the vector space of type V on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#ManifoldsBase.jl","page":"Home","title":"ManifoldsBase.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ManifoldsBase.jl is a lightweight interface for manifolds.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"This package provides an interface, so you probably either want to add it as a dependency to your project/package to work on manifold generically or implement a new manifold. A package that (only) depends on ManifoldsBase.jl, see Manopt.jl, which implements optimization algorithms on manifolds using this interface, i.e. they can be used with any manifold based on ManifoldsBase.jl. A library of manifolds implemented using this interface is provided see Manifolds.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Your package is using ManifoldsBase? Give us a note and we add you here.","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use ManifoldsBase.jl in your work, please cite the following paper, which covers both the basic interface as well as the performance for Manifolds.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@online{2106.08777,\n    Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann and Krzysztof Rzecki},\n    Title = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    Year = {2021},\n    Eprint = {2106.08777},\n    Eprinttype = {arXiv},\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the citation is in BibLaTeX format.","category":"page"},{"location":"projections.html#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"projections.html","page":"Projections","title":"Projections","text":"A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex Circle is embedded in the complex plane. Let‚Äòs keep the circle in mind in the following as a simple example. For the general case see of explicitly stating an embedding and/or distinguising several, different embeddings, see Embedded Manifolds below.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"To make this a little more concrete, let‚Äòs assume we have a manifold mathcal M which is embedded in some manifold mathcal N and the image i(mathcal M) of the embedding function i is a closed set (with respect to the topology on mathcal N). Then we can do two kinds of projections.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"To make this concrete in an example for the Circle mathcal M=mathcal C =  p  ‚ÑÇ¬† p = 1 the embedding can be chosen to be the manifold N = ‚ÑÇ and due to our representation of mathcal C as complex numbers already, we have i(p) = p the identity as the embedding function.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"Given a point pmathcal N we can look for the closest point on the manifold mathcal M formally as","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"  operatorname*argmin_qin mathcal M d_mathcal N(i(q)p)","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"And this resulting q we call the projection of p onto the manifold mathcal M.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"Given a point pmathcal M and a vector in XinT_i(p)mathcal N in the embedding we can similarly look for the closest point to Y T_pmathcal M using the pushforward mathrmdi_p of the embedding.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"  operatorname*argmin_Yin T_pmathcal M lVert mathrmdi(p)Y - X rVert_i(p)","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"And we call the resulting Y the projection of X onto the tangent space T_pmathcal M at p.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"Let‚Äòs look at the little more concrete example of the complex Circle again. Here, the closest point of p  ‚ÑÇ is just the projection onto the circle, or in other words q = fracplvert p rvert. A tangent space T_pmathcal C in the embedding is the line orthogonal to a point pmathcal C through the origin. This can be better visualized by looking at p+T_pmathcal C which is actually the line tangent to p. Note that this shift does not change the resulting projection relative to the origin of the tangent space.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"Here the projection can be computed as the classical projection onto the line, i.e.  Y = X - XpX.","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"this is illustrated in the following figure","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"(Image: An example illustrating the two kinds of projections on the Circle.)","category":"page"},{"location":"projections.html","page":"Projections","title":"Projections","text":"Modules = [ManifoldsBase]\nPages = [\"projections.jl\"]\nOrder = [:function]","category":"page"},{"location":"projections.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, Y, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. The result is saved in vector Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, q, p)\n\nProject point p from the ambient space onto the AbstractManifold M. The result is storedin q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"projections.html#ManifoldsBase.project-Tuple{AbstractManifold, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p)\n\nProject point p from the ambient space of the AbstractManifold M to M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"example.html#manifold-tutorial","page":"How to write a manifold","title":"How to implement your own manifold","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"CurrentModule = ManifoldsBase","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"This tutorial demonstrates how to easily set your own manifold up within Manifolds.jl.","category":"page"},{"location":"example.html#Introduction","page":"How to write a manifold","title":"Introduction","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"This tutorial demonstrates that you can get your first own manifold quite fast and you only have to implement the functions you actually need. This tutorial assumes that you heard of the exponential map, tangent vectors and the dimension of a manifold. If not, please read for example [do Carmo, 1992], Chapter 3, first.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In general you need just a datatype (struct) that inherits from AbstractManifold to define a manifold. No function is per se required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example check_point and check_vector, as we do in this tutorial.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"We start with two technical preliminaries. If you want to start directly, you can skip this paragraph and revisit it for two of the implementation details.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"After that, we will","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"model the manifold\nimplement two tests, so that points and tangent vectors can be checked for validity, for example also within ValidationManifold,\nimplement two functions, the exponential map and the manifold dimension.","category":"page"},{"location":"example.html#manifold-tutorial-prel","page":"How to write a manifold","title":"Technical preliminaries","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"There are only two small technical things we need to explain at this point. First of all our AbstractManifold{ùîΩ} has a parameter ùîΩ. This parameter indicates the number_system the manifold is based on, for example ‚Ñù for real manifolds. It is important primarily for defining bases of tangent spaces.","category":"page"},{"location":"example.html#manifold-tutorial-startup","page":"How to write a manifold","title":"Startup","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"As a start, let's load ManifoldsBase.jl and import the functions we consider throughout this tutorial. For implementing a manifold, loading the interface should suffice for quite some time.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"using ManifoldsBase, LinearAlgebra, Test\nimport ManifoldsBase: check_point, check_vector, manifold_dimension, exp!","category":"page"},{"location":"example.html#manifold-tutorial-task","page":"How to write a manifold","title":"Goal","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"As an example, let's implement the sphere, but with a radius r. Since this radius is a property inherent to the manifold, it will become a field of the manifold. The second information, we want to store is the dimension of the sphere, for example whether it's the 1-sphere, i.e. the circle, represented by vectors pinmathbb R^2 or the 2-sphere in mathbb R^3. Since the latter might be something we want to dispatch on, we model it as a parameter of the type.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In general the struct of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is ‚Äì most prominently ‚Äì a way to determine the manifold dimension.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For our example we define","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"\"\"\"\n    MySphere{N} <: AbstractManifold{‚Ñù}\n\nDefine an `n`-sphere of radius `r`. Construct by `MySphere(radius,n)`\n\"\"\"\nstruct MySphere{N} <: AbstractManifold{ManifoldsBase.‚Ñù} where {N}\n    radius::Float64\nend\nMySphere(radius, n) = MySphere{n}(radius)\nBase.show(io::IO, M::MySphere{n}) where {n} = print(io, \"MySphere($(M.radius),$n)\")\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Here, the last line just provides a nicer print of a variable of that type Now we can already initialize our manifold that we will use later, the 2-sphere of radius 15.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"S = MySphere(1.5, 2)","category":"page"},{"location":"example.html#manifold-tutorial-checks","page":"How to write a manifold","title":"Checking points and tangents","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"If we have now a point, represented as an array, we would first like to check, that it is a valid point on the manifold. For this one can use the easy interface is_point. This internally uses check_point. This is what we want to implement. We have to return the error if p is not on M and nothing otherwise.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"We have to check two things: that a point p is a vector with N+1 entries and its norm is the desired radius. To spare a few lines, we can use short-circuit evaluation instead of if statements. If something has to only hold up to precision, we can pass that down, too using the kwargs....","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function check_point(M::MySphere{N}, p; kwargs...) where {N}\n    (size(p)) == (N+1,) || return DomainError(size(p),\"The size of $p is not $((N+1,)).\")\n    if !isapprox(norm(p), M.radius; kwargs...)\n        return DomainError(norm(p), \"The norm of $p is not $(M.radius).\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Similarly, we can verify, whether a tangent vector X is valid. It has to fulfill the same size requirements and it has to be orthogonal to p. We can again use the kwargs, but also provide a way to check p, too.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function check_vector(M::MySphere, p, X; kwargs...)\n    size(X) != size(p) && return DomainError(size(X), \"The size of $X is not $(size(p)).\")\n    if !isapprox(dot(p,X), 0.0; kwargs...)\n        return DomainError(dot(p,X), \"The tangent $X is not orthogonal to $p.\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"to test points we can now use","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"is_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false\n@test_throws DomainError is_point(S, [1.5,0.0], true) # only on R^2, throws an error.\np = [1.5,0.0,0.0]\nX = [0.0,1.0,0.0]\n# The following two tests return true\n[ is_point(S, p); is_vector(S,p,X) ]","category":"page"},{"location":"example.html#manifold-tutorial-fn","page":"How to write a manifold","title":"Functions on the manifold","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For the manifold_dimension we have to just return the N parameter","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"manifold_dimension(::MySphere{N}) where {N} = N\nmanifold_dimension(S)","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"To implement the exponential map, we have to implement the formula for great arcs, given a start point p and a direction X on the n-sphere of radius r the formula reads","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"exp_p X = cos(frac1rlVert X rVert)p + sin(frac1rlVert X rVert)fracrlVert X rVertX","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Note that with this choice we for example implicitly assume a certain metric. This is completely fine. We only have to think about specifying a metric explicitly, when we have (at least) two different metrics on the same manifold.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"An implementation of the mutation version, see the technical note, reads","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function exp!(M::MySphere{N}, q, p, X) where {N}\n    nX = norm(X)\n    if nX == 0\n        q .= p\n    else\n        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (X./nX)\n    end\n    return q\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"A first easy check can be done taking p from above and any vector X of length 1.5œÄ from its tangent space. The resulting point is opposite of p, i.e. -p","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"q = exp(S,p, [0.0,1.5œÄ,0.0])\n[isapprox(p,-q); is_point(S,q)]","category":"page"},{"location":"example.html#manifold-tutorial-outlook","page":"How to write a manifold","title":"Conclusion","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"You can now just continue implementing further functions from ManifoldsBase.jl. but with just exp! you for example already have","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"geodesic the (not necessarily shortest) geodesic emanating from p in direction X.\nthe ExponentialRetraction, that the retract function uses by default.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For the shortest_geodesic the implementation of a logarithm log, again better a log! is necessary.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Sometimes a default implementation is provided; for example if you implemented inner, the norm is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With log! and inner you get the distance, and so.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from Manifolds.jl requires another function to be specifically implemented, you get a reasonable error message.","category":"page"},{"location":"example.html#Literature","page":"How to write a manifold","title":"Literature","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"<ul>\n<li id=\"doCarmo1992\">\n    [<a>doCarmo, 1992</a>]\n    M. P. do Carmo,\n    <emph>Riemannian Geometry</emph>,\n    Birkh√§user Boston, 1992,\n    ISBN: 0-8176-3490-8.\n</li>\n</ul>","category":"page"}]
}
