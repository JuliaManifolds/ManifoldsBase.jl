var documenterSearchIndex = {"docs":
[{"location":"functions.html#Functions-on-manifolds","page":"Basic functions","title":"Functions on manifolds","text":"","category":"section"},{"location":"functions.html#The-exponential-and-the-logarithmic-map,-and-geodesics","page":"Basic functions","title":"The exponential and the logarithmic map, and geodesics","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector “points towards” the other point.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"exp_log_geo.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.exp","text":"exp(M::AbstractManifold, p, X)\nexp(M::AbstractManifold, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M, i.e.\n\nexp_p X = γ_pX(1)\n\nwhere γ_pX is the unique geodesic starting in γ(0)=p such that dot γ(0) = X.\n\nSee also shortest_geodesic, retract.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.log-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.log","text":"log(M::AbstractManifold, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The logarithmic map is the inverse of the exponential map. Note that the logarithmic map might not be globally defined.\n\nSee also inverse_retract.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.exp!","text":"exp!(M::AbstractManifold, q, p, X)\nexp!(M::AbstractManifold, q, p, X, t::Real = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M. The result is saved to q.\n\nSee also exp.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve γ_pX I  mathcal M, with γ_pX(0) = p and dot γ_pX(0) = X a geodesic further fulfills\n\n_dot γ_pX(t) dot γ_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.\n\nThis function returns a function of (time) t.\n\ngeodesic(M::AbstractManifold, p, X, t::Real)\ngeodesic(M::AbstractManifold, p, X, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.log!","text":"log!(M::AbstractManifold, X, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The result is saved to X. The logarithmic map is the inverse of the exp!onential map. Note that the logarithmic map might not be globally defined.\n\nsee also log and inverse_retract!,\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic γ_pq(t) whose length is the shortest path between the points pand q, where γ_pq(0)=p and γ_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\nshortest_geodesic(M::AabstractManifold, p, q, t::Real)\nshortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -> AbstractVector\n\nReturn the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Retractions-and-inverse-Retractions","page":"Basic functions","title":"Retractions and inverse Retractions","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"The exponential and logarithmic map might be too expensive to evaluate or not be available in a very stable numerical way. Retractions provide a possibly cheap, fast and stable alternative.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"The following figure compares the exponential map exp(M, p, X) on the Circle (ℂ) (or Sphere(1) embedded in ℝ^2 with one possible retraction, the one based on projections. Note especially that mathrmdist(pq)=lVert XrVert_p while this is not the case for q.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"(Image: A comparson of the exponential map and a retraction on the Circle.)","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions.html#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::AbstractManifold)\n\nThe AbstractInverseRetractionMethod that is used when calling inverse_retract without specifying the inverse retraction method. By default, this is the LogarithmicInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::AbstractManifold)\n\nThe AbstractRetractionMethod that is used when calling retract without specifying the retraction method. By default, this is the ExponentialRetraction.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.inverse_retract","page":"Basic functions","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractManifold, p, q)\ninverse_retract(M::AbstractManifold, p, q, method::AbstractInverseRetractionMethod\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). For available inverse retractions on certain manifolds see the documentation on the corresponding manifold.\n\nSee also retract.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.inverse_retract!","page":"Basic functions","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::AbstractManifold, X, p, q[, method::AbstractInverseRetractionMethod])\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M. Result is saved to X.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee also retract!.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.retract","page":"Basic functions","title":"ManifoldsBase.retract","text":"retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod=default_retraction_method(M))\nretract(M::AbstractManifold, p, X, t::Real=1, method::AbstractRetractionMethod=default_retraction_method(M))\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold M.\n\nA retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfills\n\noperatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M to T_pmathcal M is the identity map, i.e. Doperatornameretr_p(0)X=X,\n\nwhere Doperatornameretr_p denotes the differential of the retraction\n\nThe retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). For further available retractions see the documentation of respective manifolds.\n\nLocally, the retraction is invertible. For the inverse operation, see inverse_retract.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.retract!","page":"Basic functions","title":"ManifoldsBase.retract!","text":"retract!(M::AbstractManifold, q, p, X)\nretract!(M::AbstractManifold, q, p, X, t::Real=1)\nretract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod)\nretract!(M::AbstractManifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold manifold M. Result is saved to q.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee retract for more details.\n\n\n\n\n\n","category":"function"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"To distinguish different types of retractions, the last argument of the (inverse) retraction specifies a type. The following ones are available.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\"]\nOrder = [:type]","category":"page"},{"location":"functions.html#ManifoldsBase.AbstractInverseRetractionMethod","page":"Basic functions","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.AbstractRetractionMethod","page":"Basic functions","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ApproximateInverseRetraction","page":"Basic functions","title":"ManifoldsBase.ApproximateInverseRetraction","text":"ApproximateInverseRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate inverse retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ApproximateRetraction","page":"Basic functions","title":"ManifoldsBase.ApproximateRetraction","text":"ApproximateRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ExponentialRetraction","page":"Basic functions","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.LogarithmicInverseRetraction","page":"Basic functions","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.NLsolveInverseRetraction","page":"Basic functions","title":"ManifoldsBase.NLsolveInverseRetraction","text":"NLsolveInverseRetraction{T<:AbstractRetractionMethod,TV,TK} <:\n    ApproximateInverseRetraction\n\nAn inverse retraction method for approximating the inverse of a retraction using NLsolve.\n\nConstructor\n\nNLsolveInverseRetraction(\n    method::AbstractRetractionMethod[, X0];\n    project_tangent=false,\n    project_point=false,\n    nlsolve_kwargs...,\n)\n\nConstructs an approximate inverse retraction for the retraction method with initial guess X0, defaulting to the zero vector. If project_tangent is true, then the tangent vector is projected before the retraction using project. If project_point is true, then the resulting point is projected after the retraction. nlsolve_kwargs are keyword arguments passed to NLsolve.nlsolve.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.PolarInverseRetraction","page":"Basic functions","title":"ManifoldsBase.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.PolarRetraction","page":"Basic functions","title":"ManifoldsBase.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ProjectionInverseRetraction","page":"Basic functions","title":"ManifoldsBase.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ProjectionRetraction","page":"Basic functions","title":"ManifoldsBase.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.QRInverseRetraction","page":"Basic functions","title":"ManifoldsBase.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.QRRetraction","page":"Basic functions","title":"ManifoldsBase.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\n\n\n\n\n","category":"type"},{"location":"functions.html#Vector-transport","page":"Basic functions","title":"Vector transport","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"There are three main functions for vector transport:","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"vector_transport_along\nvector_transport_direction\nvector_transport_to","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Different types of vector transport are implemented using subtypes of AbstractVectorTransportMethod:","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"ParallelTransport\nPoleLadderTransport\nProjectionTransport\nSchildsLadderTransport","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"functions.html#ManifoldsBase.AbstractLinearVectorTransportMethod","page":"Basic functions","title":"ManifoldsBase.AbstractLinearVectorTransportMethod","text":"AbstractLinearVectorTransportMethod <: AbstractVectorTransportMethod\n\nAbstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.AbstractVectorTransportMethod","page":"Basic functions","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod\n\nAbstract type for methods for transporting vectors. Such vector transports are not necessarily linear.\n\nSee also\n\nAbstractLinearVectorTransportMethod\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.DifferentiatedRetractionVectorTransport","page":"Basic functions","title":"ManifoldsBase.DifferentiatedRetractionVectorTransport","text":"DifferentiatedRetractionVectorTransport{R<:AbstractRetractionMethod} <:\n    AbstractVectorTransportMethod\n\nA type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let mathcal M be a Riemannian manifold, pinmathcal M a point, and XYin T_pmathcal M denote two tangent vectors at p.\n\nGiven a retraction (cf. AbstractRetractionMethod) operatornameretr, the vector transport of X in direction Y (cf. vector_transport_direction) by differentiation this retraction, is given by\n\nmathcal T^operatornameretr_pYX\n= D_Yoperatornameretr_p(Y)X\n= fracmathrmdmathrmdtoperatornameretr_p(Y+tX)Bigr_t=0\n\nsee [AbsilMahonySepulchre2008], Section 8.1.2 for more details.\n\nThis can be phrased similarly as a vector_transport_to by introducing q=operatornameretr_pX and defining\n\nmathcal T^operatornameretr_q gets pX = mathcal T^operatornameretr_pYX\n\nwhich in practice usually requires the inverse_retract to exists in order to compute Y = operatornameretr_p^-1q.\n\nConstructor\n\nDifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)\n\n[AbsilMahonySepulchre2008]: Absil, P.-A., Mahony, R. and Sepulchre R., Optimization Algorithms on Matrix Manifolds Princeton University Press, 2008, doi: 10.1515/9781400830244 open access\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ParallelTransport","page":"Basic functions","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nSpecify to use parallel transport vector transport method.\n\nTo be precise let c(t) be a curve depending on the method\n\nthe (assumed to be unique) geodesic c(t) = γ_pq(t) from γ_pq(0)=p to γ_pq(1)=q for vector_transport_to mathcal P_qgets pY\nthe unique geodesic c(t)=γ_pX(t) from γ_pX(0)=p into direction dot γ_pX(0)=X for vector_transport_direction mathcal P_pXY\na given curve c(0)=p for vector_transport_along mathcal P^cY\n\nIn these cases Yin T_pmathcal M is the vector that we would like to transport from the tangent space at p=c(0) to the tangent space at c(1).\n\nLet Zcolon 01 to Tmathcal M, Z(t)in T_c(t)mathcal M be a smooth vector field along the curve c with Z(0) = Y, such that Z is parallel, i.e. its covariant derivative fracmathrmDmathrmdtZ is zero. Note that such a Z always exists and is unique.\n\nThen the parallel transport is given by Z(1).\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.PoleLadderTransport","page":"Basic functions","title":"ManifoldsBase.PoleLadderTransport","text":"PoleLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use pole_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then x = exp_pX is used to call y =pole_ladder(M, p, x, q) and the resulting vector is obtained by computing Y = -log_qy.\n\nThe PoleLadderTransport posesses two advantages compared to SchildsLadderTransport:\n\nit is cheaper to evaluate, if you want to transport several vectors, since the mid point c then stays unchanged.\nwhile both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds[Pennec2018]\n\nThe pole ladder was was proposed in [LorenziPennec2014]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.\n\nConstructor\n\nPoleLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical pole ladder that employs exp and log, i.e. as proposed in[LorenziPennec2014]. For an even cheaper transport the inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[LorenziPennec2014]: Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild’s to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5–17 doi 10.1007/s10851-013-0470-3, hal: hal-00870489\n\n[Pennec2018]: Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: 1805.11436\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ProjectionTransport","page":"Basic functions","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along. See project for details.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.ScaledVectorTransport","page":"Basic functions","title":"ManifoldsBase.ScaledVectorTransport","text":"ScaledVectorTransport{T} <: AbstractVectorTransportMethod\n\nIntroduce a scaled variant of any AbstractVectorTransportMethod T, as introduced in [SatoIwai2013] for some Xin T_pmathcal M as\n\n    mathcal T^mathrmS(X) = fraclVert XrVert_plVert mathcal T(X)rVert_qmathcal T(X)\n\nNote that the resulting point q has to be known, i.e. for vector_transport_direction the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the vector_transport_to\n\nConstructor\n\nScaledVectorTransport(m::AbstractVectorTransportMethod)\n\n[SatoIwai2013]: Sato, H., Iwai, T.: A new, globally convergent Riemannian conjugate gradient method, Optimization, 2013, Volume 64(4), pp. 1011–1031. doi: 10.1080/02331934.2013.836650, arXiv: 1302.0125.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase.SchildsLadderTransport","page":"Basic functions","title":"ManifoldsBase.SchildsLadderTransport","text":"SchildsLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use schilds_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet Xin T_pmathcal M be a tangent vector at pinmathcal M and qinmathcal M the point to transport to. Then\n\nP^mathrmS_qgets p(X) =\n    log_qbigl( operatornameretr_p ( 2operatornameretr_p^-1c ) bigr)\n\nwhere c is the mid point between q and d=exp_pX.\n\nThis method employs the internal function schilds_ladder(M, p, d, q) that avoids leaving the manifold.\n\nThe name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [EhlersPiraniSchild1972].\n\nConstructor\n\nSchildsLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical Schilds ladder that employs exp and log, i.e. as proposed in[EhlersPiraniSchild1972]. For an even cheaper transport these inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[EhlersPiraniSchild1972]: Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O’Raifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63–84. Clarendon Press, Oxford (1972). reprint doi: 10.1007/s10714-012-1353-4\n\n\n\n\n\n","category":"type"},{"location":"functions.html#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}","page":"Basic functions","title":"ManifoldsBase._vector_transport_along!","text":"function vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::PoleLadderTransport\n)\n\nCompute the vector transport along a discretized curve using PoleLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase._vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, SchildsLadderTransport}","page":"Basic functions","title":"ManifoldsBase._vector_transport_along!","text":"vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::SchildsLadderTransport\n)\n\nCompute the vector transport along a discretized curve using SchildsLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, PoleLadderTransport}","page":"Basic functions","title":"ManifoldsBase._vector_transport_to!","text":"_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::PoleLadderTransport)\n\nPerform a vector transport by using PoleLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase._vector_transport_to!-Tuple{AbstractManifold, Any, Any, Any, Any, SchildsLadderTransport}","page":"Basic functions","title":"ManifoldsBase._vector_transport_to!","text":"_vector_transport_to!(M::AbstractManifold, Y, p, X, q, method::SchildsLadderTransport)\n\nPerform a vector transport by using SchildsLadderTransport.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::AbstractManifold)\n\nThe AbstractVectorTransportMethod that is used when calling vector_transport_along, vector_transport_to, or vector_transport_direction without specifying the vector transport method. By default, this is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.pole_ladder","page":"Basic functions","title":"ManifoldsBase.pole_ladder","text":"pole_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q);\n    retraction=default_retraction_method(M),\n    inverse_retraction=default_inverse_retraction_method(M)\n)\n\nCompute an inner step of the pole ladder, that can be used as a vector_transport_to. Let c = gamma_pq(frac12) mid point between p and q, then the pole ladder is given by\n\n    operatornamePl(pdq) = operatornameretr_d (2operatornameretr_d^-1c)\n\nWhere the classical pole ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nWhen you have X=log_pd and Y = -log_q operatornamePl(pdq), you will obtain the PoleLadderTransport. When performing multiple steps, this method avoidsd the switching to the tangent space. Keep in mind that after n successive steps the tangent vector reads Y_n = (-1)^nlog_q operatornamePl(p_n-1d_n-1p_n).\n\nIt is cheaper to evaluate than schilds_ladder, sinc if you want to form multiple ladder steps between p and q, but with different d, there is just one evaluation of a geodesic each., since the center c can be reused.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.pole_ladder!","page":"Basic functions","title":"ManifoldsBase.pole_ladder!","text":"pole_ladder(\n    M,\n    pl,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nCompute the pole_ladder, i.e. the result is saved in pl. X is used for storing intermediate inverse retraction.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.schilds_ladder","page":"Basic functions","title":"ManifoldsBase.schilds_ladder","text":"schilds_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nPerform an inner step of schilds ladder, which can be used as a vector_transport_to, see SchildsLadderTransport. Let c = gamma_qd(frac12) denote the mid point on the shortest geodesic connecting q and the point d. Then Schild's ladder reads as\n\noperatornameSl(pdq) = operatornameretr_x( 2operatornameretr_p^-1 c)\n\nWhere the classical Schilds ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nIn consistency with pole_ladder you can change the way the mid point is computed using the optional parameter c, but note that here it's the mid point between q and d.\n\nWhen you have X=log_pd and Y = log_q operatornameSl(pdq), you will obtain the PoleLadderTransport. Then the approximation to the transported vector is given by log_qoperatornameSl(pdq).\n\nWhen performing multiple steps, this method avoidsd the switching to the tangent space. Hence after n successive steps the tangent vector reads Y_n = log_q operatornamePl(p_n-1d_n-1p_n).\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.schilds_ladder!","page":"Basic functions","title":"ManifoldsBase.schilds_ladder!","text":"schilds_ladder!(\n    M,\n    sl\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M),\n    inverse_retraction = default_inverse_retraction_method(M),\n)\n\nCompute schilds_ladder and return the value in the parameter sl. If the required mid point c was computed before, it can be passed using c, and the allocation of new memory can be avoided providing a tangent vector X for the interims result.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_along","page":"Basic functions","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::AbstractManifold, p, X, c)\nvector_transport_along(M::AbstractManifold, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_along!","page":"Basic functions","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::AbstractManifold, Y, p, X, c)\nvector_transport_along!(M::AbstractManifold, Y, p, X, c, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_along!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, AbstractVectorTransportMethod}","page":"Basic functions","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(\n    M::AbstractManifold,\n    Y,\n    p,\n    X,\n    c::AbstractVector,\n    method::AbstractVectorTransportMethod\n) where {T}\n\nCompute the vector transport along a discretized curve c using an AbstractVectorTransportMethod method succesively along the sampled curve.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.vector_transport_direction","page":"Basic functions","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::AbstractManifold, p, X, d)\nvector_transport_direction(M::AbstractManifold, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the method, which defaults to default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_direction!","page":"Basic functions","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::AbstractManifold, Y, p, X, d)\nvector_transport_direction!(M::AbstractManifold, Y, p, X, d, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the method, which defaults to default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_to","page":"Basic functions","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractManifold, p, X, q)\nvector_transport_to(M::AbstractManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.vector_transport_to!","page":"Basic functions","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::AbstractManifold, Y, p, X, q)\nvector_transport_to!(M::AbstractManifold, Y, p, X, q, method::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the shortest_geodesic to the tangent space at another point q. By default, the AbstractVectorTransportMethod method is default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#Projections","page":"Basic functions","title":"Projections","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex Circle is embedded in the complex plane. Let‘s keep the circle in mind in the following as a simple example. For the general case see of explicitly stating an embedding and/or distinguising several, different embeddings, see Embedded Manifolds below.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"To make this a little more concrete, let‘s assume we have a manifold mathcal M which is embedded in some manifold mathcal N and the image i(mathcal M) of the embedding function i is a closed set (with respect to the topology on mathcal N). Then we can do two kinds of projections.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"To make this concrete in an example for the Circle mathcal M=mathcal C =  p  ℂ  p = 1 the embedding can be chosen to be the manifold N = ℂ and due to our representation of mathcal C as complex numbers already, we have i(p) = p the identity as the embedding function.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Given a point pmathcal N we can look for the closest point on the manifold mathcal M formally as","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"  operatorname*argmin_qin mathcal M d_mathcal N(i(q)p)","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"And this resulting q we call the projection of p onto the manifold mathcal M.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Given a point pmathcal M and a vector in XinT_i(p)mathcal N in the embedding we can similarly look for the closest point to Y T_pmathcal M using the push forward mathrmdi_p of the embedding.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"  operatorname*argmin_Yin T_pmathcal M lVert mathrmdi(p)Y - X rVert_i(p)","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"And we call the resulting Y the projection of X onto the tangent space T_pmathcal M at p.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Let‘s look at the little more concrete example of the complex Circle again. Here, the closest point of p  ℂ is just the projection onto the circle, or in other words q = fracplvert p rvert. A tangent space T_pmathcal C in the embedding is the line orthogonal to a point pmathcal C through the origin. This can be better visualized by looking at p+T_pmathcal C which is actually the line tangent to p. Note that this shift does not change the resulting projection relative to the origin of the tangent space.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Here the projection can be computed as the classical projection onto the line, i.e.  Y = X - XpX.","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"this is illustrated in the following figure","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"(Image: An example illustrating the two kinds of projections on the Circle.)","category":"page"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"projections.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, Y, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. The result is saved in vector Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, q, p)\n\nProject point p from the ambient space onto the AbstractManifold M. The result is storedin q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.project-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p)\n\nProject point p from the ambient space of the AbstractManifold M to M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Further-functions","page":"Basic functions","title":"Further functions","text":"","category":"section"},{"location":"functions.html","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"functions.html#ManifoldsBase.OutOfInjectivityRadiusError","page":"Basic functions","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"functions.html#Base.angle-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.angle","text":"angle(M::AbstractManifold, p, X, Y)\n\nCompute the angle between tangent vectors X and Y at point p from the AbstractManifold M with respect to the inner product from inner.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copy-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M, p, X)\n\nCopy the value(s) from the tangent vector X at a point p on the AbstractManifold M into a new tangent vector. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copy-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M, p)\n\nCopy the value(s) from the point p on the AbstractManifold M into a new point. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, Y, p, X)\n\nCopy the value(s) from X to Y, where both are tangent vectors from the tangent space at p on the AbstractManifold M. This function defaults to calling copyto!(Y, X), but it might be useful to overwrite the function at the level, where also information from p and M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, q, p)\n\nCopy the value(s) from p to q, where both are points on the AbstractManifold M. This function defaults to calling copyto!(q, p), but it might be useful to overwrite the function at the level, where also information from M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, X, Y; kwargs...)\n\nCheck if vectors X and Y tangent at p from AbstractManifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, q; kwargs...)\n\nCheck if points p and q from AbstractManifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"LinearAlgebra.norm","text":"norm(M::AbstractManifold, p, X)\n\nCompute the norm of tangent vector X at point p from a AbstractManifold M. By default this is computed using inner.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Integer...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Integer...)\nallocate(a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::AbstractManifold, f, x...)\n\nAllocate an array for the result of function f on AbstractManifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}","page":"Basic functions","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f and the AbstractManifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.base_manifold","page":"Basic functions","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::AbstractManifold, depth = Val(-1))\n\nReturn the internally stored AbstractManifold for decorated manifold M and the base manifold for vector bundles or power manifolds. The optional parameter depth can be used to remove only the first depth many decorators and return the AbstractManifold from that level, whether its decorated or not. Any negative value deactivates this depth limit.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractManifold, p; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when p is a point on the AbstractManifold M. Otherwise, return an error with description why the point does not belong to manifold M.\n\nBy default, check_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the AbstractManifoldPoint type.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_size","text":"check_size(M::AbstractManifold, p)\ncheck_size(M::AbstractManifold, p, X)\n\nCheck whether p has the right representation_size for a AbstractManifold M. Additionally if a tangent vector is given, both p and X are checked to be of corresponding correct representation sizes for points and tangent vectors on M.\n\nBy default, check_size returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractManifold, p, X; kwargs...) -> Union{Nothing,String}\n\nCheck whether X is a valid tangent vector in the tangent space of p on the AbstractManifold M. An implementation does not have to validate the point p. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q)\n\nShortest distance between the points p and q on the AbstractManifold M, i.e.\n\nd(pq) = inf_γ L(γ)\n\nwhere the infimum is over all piecewise smooth curves γ ab to mathcal M connecting γ(a)=p and γ(b)=q and\n\nL(γ) = displaystyleint_a^b lVert dotγ(t)rVert_γ(t) mathrmdt\n\nis the length of the curve γ.\n\nIf mathcal M is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be .\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, Y, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into the ambient space and return the result in Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, q, p)\n\nEmbed point p from the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, embed might include changing data representation, if applicable, i.e. if points on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your point p is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).\n\nAdditionally, embed might include changing data representation, if applicable, i.e. if tangent vectors on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your tangent vector X is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.embed-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p)\n\nEmbed point p from the AbstractManifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractManifold, p)\n\nReturn the distance d such that exp(M, p, X) is injective for all tangent vectors shorter than d (i.e. has an inverse).\n\ninjectivity_radius(M::AbstractManifold)\n\nInfimum of the injectivity radius of all manifold points.\n\ninjectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)\ninjectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)\n\nDistance d such that retract(M, p, X, method) is injective for all tangent vectors shorter than d (i.e. has an inverse) for point p if provided or all manifold points otherwise.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.inner","text":"inner(M::AbstractManifold, p, X, Y)\n\nCompute the inner product of tangent vectors X and Y at point p from the AbstractManifold M.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.is_point","page":"Basic functions","title":"ManifoldsBase.is_point","text":"is_point(M::AbstractManifold, p, throw_error = false; kwargs...)\n\nReturn whether p is a valid point on the AbstractManifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_point(M, p; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.is_vector","page":"Basic functions","title":"ManifoldsBase.is_vector","text":"is_vector(M::AbstractManifold, p, X, throw_error = false; check_base_point=true, kwargs...)\n\nReturn whether X is a valid tangent vector at point p on the AbstractManifold M. Returns either true or false.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_vector(M, p, X; kwargs...) and checks whether the returned value is nothing or an error.\n\nIf check_base_point is true, then the point p will be first checked using the check_point function.\n\n\n\n\n\n","category":"function"},{"location":"functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractManifold)\n\nThe dimension n=dim_mathcal M of real space mathbb R^n to which the neighborhood of each point of the AbstractManifold M is homeomorphic.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point!","text":"mid_point!(M::AbstractManifold, q, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp!. Saves the result in q.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point","text":"mid_point(M::AbstractManifold, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.number_eltype-Tuple{Any}","page":"Basic functions","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractManifold)\n\nThe size of an array representing a point on AbstractManifold M. Returns nothing by default indicating that points are not represented using an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S<:Tuple","page":"Basic functions","title":"ManifoldsBase.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector!","text":"zero_vector!(M::AbstractManifold, X, p)\n\nSave to X the tangent vector from the tangent space T_pmathcal M at p that represents the zero vector, i.e. such that retracting X to the AbstractManifold M at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::AbstractManifold, p)\n\nReturn the tangent vector from the tangent space T_pmathcal M at p on the AbstractManifold M, that represents the zero vector, i.e. such that a retraction at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#Bases-for-tangent-spaces","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"","category":"section"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The following functions and types provide support for bases of the tangent space of different manifolds. Moreover, bases of the cotangent space are also supported, though this description focuses on the tangent space. An orthonormal basis of the tangent space T_p mathcal M of (real) dimension n has a real-coefficient basis e_1 e_2  e_n if mathrmRe(g_p(e_i e_j)) = δ_ij for each ij  1 2  n where g_p is the Riemannian metric at point p. A vector X from the tangent space T_p mathcal M can be expressed in Einstein notation as a sum X = X^i e_i, where (real) coefficients X^i are calculated as X^i = mathrmRe(g_p(X e_i)).","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main types are:","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"DefaultOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nCachedBasis, which stores (explicitly or implicitly) a precomputed basis at a certain point.","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main functions are:","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.","category":"page"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"Modules = [ManifoldsBase]\nPages = [\"bases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bases.html#ManifoldsBase.AbstractBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractBasis","text":"AbstractBasis{𝔽,VST<:VectorSpaceType}\n\nAbstract type that represents a basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.AbstractOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthogonalBasis","text":"AbstractOrthogonalBasis{𝔽,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.AbstractOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{𝔽,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.CachedBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.CachedBasis","text":"CachedBasis{𝔽,V,<:AbstractBasis{𝔽}} <: AbstractBasis{𝔽}\n\nA cached version of the given basis with precomputed basis vectors. The basis vectors are stored in data, either explicitly (like in cached variants of ProjectedOrthonormalBasis) or implicitly.\n\nConstructor\n\nCachedBasis(basis::AbstractBasis, data)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultBasis","text":"DefaultBasis{𝔽,VST<:VectorSpaceType}\n\nAn arbitrary basis of vector space of type VST on a manifold. This will usually be the fastest basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthogonalBasis","text":"DefaultOrthogonalBasis{𝔽,VST<:VectorSpaceType}\n\nAn arbitrary orthogonal basis of vector space of type VST on a manifold. This will usually be the fastest orthogonal basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DefaultOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthonormalBasis","text":"DefaultOrthonormalBasis(𝔽::AbstractNumbers = ℝ, vs::VectorSpaceType = TangentSpace)\n\nAn arbitrary orthonormal basis of vector space of type VST on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.DiagonalizingOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis{𝔽,TV} <: AbstractOrthonormalBasis{𝔽,TangentSpaceType}\n\nAn orthonormal basis Ξ as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction frame_direction v has curvature 0.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nConstructor\n\nDiagonalizingOrthonormalBasis(frame_direction, 𝔽::AbstractNumbers = ℝ)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.GramSchmidtOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.GramSchmidtOrthonormalBasis","text":"GramSchmidtOrthonormalBasis{𝔽} <: AbstractOrthonormalBasis{𝔽}\n\nAn orthonormal basis obtained from a basis.\n\nConstructor\n\nGramSchmidtOrthonormalBasis(𝔽::AbstractNumbers = ℝ)\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.ProjectedOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, 𝔽::AbstractNumbers = ℝ)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter 𝔽 denotes the AbstractNumbers that will be used for the vectors elements.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.VectorSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space fiber is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector(fiber, p) to construct zero vectors at point p,\nallocate(X) and allocate(X, T) for vector X and type T,\ncopyto!(X, Y) for vectors X and Y,\nnumber_eltype(v) for vector v,\nvector_space_dimension.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject (for embedded vector spaces),\nrepresentation_size,\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.allocate_coordinates-Tuple{AbstractManifold, Any, Any, Int64}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocate_coordinates","text":"allocate_coordinates(M::AbstractManifold, p, T, n::Int)\n\nAllocate vector of coordinates of length n of type T of a vector at point p on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocation_promotion_function","text":"allocation_promotion_function(M::AbstractManifold, f, args::Tuple)\n\nDetermine the function that must be used to ensure that the allocated representation is of the right type. This is needed for get_vector when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.dual_basis","text":"dual_basis(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the dual basis to B, a basis of a vector space at point p from manifold M.\n\nThe dual to the ith vector v_i from basis B is a vector v^i from the dual space such that v^i(v_j) = δ^i_j, where δ^i_j is the Kronecker delta symbol:\n\nδ^i_j = begincases\n1  text if  i=j \n0  text otherwise\nendcases\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_basis","text":"get_basis(M::AbstractManifold, p, B::AbstractBasis; kwargs...) -> CachedBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by p.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractManifold, p, X, B::AbstractBasis)\nget_coordinates(M::AbstractManifold, p, X, B::CachedBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector X at point denoted by p on manifold M in basis B.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve. If a CachedBasis is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.\n\nFor the CachedBasis keep in mind that the reconstruction with get_vector requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vector","text":"X = get_vector(M::AbstractManifold, p, c, B::AbstractBasis)\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at p on manifold M to a tangent vector X at p.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve.\n\nFor the CachedBasis keep in mind that the reconstruction from get_coordinates requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_coordinates, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vectors","text":"get_vectors(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the basis vectors of basis B of the tangent space at point p.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.gram_schmidt-Union{Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, Any, ManifoldsBase.AbstractBasis{𝔽}}} where 𝔽","page":"Bases for tangent spaces","title":"ManifoldsBase.gram_schmidt","text":"gram_schmidt(M::AbstractManifold{𝔽}, p, B::AbstractBasis{𝔽}) where {𝔽}\ngram_schmidt(M::AbstractManifold, p, V::AbstractVector)\n\nCompute an ONB in the tangent space at p on the [AbstractManifold](@ref} M from either an AbstractBasis basis ´B´ or a set of (at most) manifold_dimension(M) many vectors. Note that this method requires the manifold and basis to work on the same AbstractNumbers 𝔽, i.e. with real coefficients.\n\nThe method always returns a basis, i.e. linearly dependent vectors are removed.\n\nKeyword arguments\n\nwarn_linearly_dependent (false) – warn if the basis vectors are not linearly independent\nskip_linearly_dependent (false) – whether to just skip (true) a vector that is linearly dependent to the previous ones or to stop (false, default) at that point\nreturn_incomplete_set (false) – throw an error if the resulting set of vectors is not a basis but contains less vectors\n\nfurther keyword arguments can be passed to set the accuracy of the independence test. Especially atol is raised slightly by default to atol = 5*1e-16.\n\nReturn value\n\nWhen a set of vectors is orthonormalized a set of vectors is returned. When an AbstractBasis is orthonormalized, a CachedBasis is returned.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.hat","text":"hat(M::AbstractManifold, p, Xⁱ)\n\nGiven a basis e_i on the tangent space at a point p and tangent component vector X^i, compute the equivalent vector representation X=X^i e_i, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.number_of_coordinates-Union{Tuple{𝔾}, Tuple{𝔽}, Tuple{AbstractManifold{𝔽}, ManifoldsBase.AbstractBasis{𝔾}}} where {𝔽, 𝔾}","page":"Bases for tangent spaces","title":"ManifoldsBase.number_of_coordinates","text":"number_of_coordinates(M::AbstractManifold{𝔽}, B::AbstractBasis)\nnumber_of_coordinates(M::AbstractManifold{𝔽}, ::𝔾)\n\nCompute the number of coordinates in basis of field type 𝔾 on a manifold M. This also corresponds to the number of vectors represented by B, or stored within B in case of a CachedBasis.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{𝔽}}, Tuple{𝔽}} where 𝔽","page":"Bases for tangent spaces","title":"ManifoldsBase.number_system","text":"number_system(::AbstractBasis)\n\nThe number system for the vectors of the given basis.\n\n\n\n\n\n","category":"method"},{"location":"bases.html#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.vee","text":"vee(M::AbstractManifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases.html","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"Modules = [ManifoldsBase]\nPages = [\"vector_spaces.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bases.html#ManifoldsBase.AbstractFibreVector","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractFibreVector","text":"AbstractFibreVector{TType<:VectorSpaceType}\n\nType for a vector from a vector space (fibre of a vector bundle) of type TType of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\nYou may use macro @manifold_vector_forwards to introduce commonly used method definitions for your subtype of AbstractFibreVector.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.CoTVector","page":"Bases for tangent spaces","title":"ManifoldsBase.CoTVector","text":"CoTVector = AbstractFibreVector{CotangentSpaceType}\n\nType for a cotangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.FVector","page":"Bases for tangent spaces","title":"ManifoldsBase.FVector","text":"FVector(type::VectorSpaceType, data, basis::AbstractBasis)\n\nDecorator indicating that the vector data contains coordinates of a vector from a fiber of a vector bundle of type type. basis is an object describing the basis of that space in which the coordinates are given.\n\nConversion between FVector representation and the default representation of an object (for example a tangent vector) for a manifold should be done using get_coordinates and get_vector.\n\nExamples\n\njulia> using Manifolds\n\njulia> M = Sphere(2)\nSphere(2, ℝ)\n\njulia> p = [1.0, 0.0, 0.0]\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> X = [0.0, 2.0, -1.0]\n3-element Vector{Float64}:\n  0.0\n  2.0\n -1.0\n\njulia> B = DefaultOrthonormalBasis()\nDefaultOrthonormalBasis(ℝ)\n\njulia> fX = TFVector(get_coordinates(M, p, X, B), B)\nTFVector([2.0, -1.0], DefaultOrthonormalBasis(ℝ))\n\njulia> X_back = get_vector(M, p, fX.data, fX.basis)\n3-element Vector{Float64}:\n -0.0\n  2.0\n -1.0\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.TVector","page":"Bases for tangent spaces","title":"ManifoldsBase.TVector","text":"TVector = AbstractFibreVector{TangentSpaceType}\n\nType for a tangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"bases.html#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, ManifoldsBase.VectorSpaceType}","page":"Bases for tangent spaces","title":"ManifoldsBase.vector_space_dimension","text":"vector_space_dimension(M::AbstractManifold, V::VectorSpaceType)\n\nDimension of the vector space of type V on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"design.html#Main-Design-Principles","page":"Design principles","title":"Main Design Principles","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from Manopt.jl can be implemented on arbitrary manifolds.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The main design criteria for the interface are:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Aims to also provide efficient global state-free, both in-place and out-of-place computations whenever possible.\nProvide a high level interface that is easy to use.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Therefore this interface has 3 main features, that we will explain using two (related) concepts, the exponential map that maps a tangent vector X at a point p to a point q or mathematically exp_pT_pmathcal M to mathcal M and its generalization, a retraction operatornameretr_p with same domain and range.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"You do not need to know their exact definition at this point, just that there is one exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (sometime called exponential retraction for completeness). Every retraction has its own subtype of the AbstractRetractionMethod that uniquely defines it.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The following three design patterns aim to fulfill the criteria from above, while also avoiding ambiguities in multiple dispatch using the dispatch on one argument at a time approach.","category":"page"},{"location":"design.html#General-order-of-parameters","page":"Design principles","title":"General order of parameters","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for mutating functions. Then the classical parametzers of a function (for example a point and a tangent vector for the retraction) follow and the final part are parameters to further dispatch on, which usually have their defaults.","category":"page"},{"location":"design.html#A-3-Layer-architecture-for-dispatch","page":"Design principles","title":"A 3-Layer architecture for dispatch","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The general architecture consists of three layers","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The high level interface for ease of use – and to dispatch on other manifolds\nan interims layer to dispatch on different parameters in the last section\nthe lowest layer with a specific manifold and no optional parameters for performance","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"These three layers are described in more detail in the following.","category":"page"},{"location":"design.html#Layer-I:-The-high-level-interface-and-ease-of-use","page":"Design principles","title":"Layer I: The high level interface and ease of use","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"THe highest layer for convenience of decorators. A usual scheme is, that a manifold might assume several things implicitly, for example the default implementation of the sphere mathbb S^n using unit vectors in mathbb R^n+1. The embedding can be explicitly used to avoid reimplementations – the inner product can be “passed on” to its embedding.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To do so, we “decorate” the manifold by making it an AbstractDecoratorManifold and activating the right traits see the example.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The explicit case of the EmbeddedManifold can be used to distinguish different embeddings of a manifold, but also their dispatch (onto the manifold or its embedding, depending on the type of embedding) happens here.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Note that all other parameters of a function should be as unspecific as possible on this layer.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"With respect to the dispatch on one argument at a time paradigm, this layer dispatches the manifold first, but here we stay oon an abstract type level.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This layer ends usually in calling the same functions like retract but prefixed with a _ to enter Layer II.","category":"page"},{"location":"design.html#Layer-II:-An-internal-dispatch-interface-for-parameters","page":"Design principles","title":"Layer II: An internal dispatch interface for parameters","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This layer is an interims layer to dispatch on the (optional/default) parameters of a function like the retraction: retract has a last parameter that determines the type. The last function in the previous layer calls _retract, which is an internal function.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"On this layer, e.g. for _retract only these last parameters should be typed, the manifold should stay at the AbstractManifold level. It dispatches on different functions per existing parameter type (and might pass this one further on, if it has fields).","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Note that this layer is an internal one. It is automatically called for functions with parameters to dispatch on.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"It should only be extended when introducing new such parameter types, for example when introducing a new type of a retraction.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The functions from this layer should never be called directly, are hence also not exported and carry the _ prefix. They should only be called as the final step in the previous layer.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"If the default parameters are not dispatched per type, using _ might be skipped. The following resolution might even be seen as a last step in layer I or the resolution here in layer II.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"exp(M::AbstractManifold, p, X, t::Real) = exp(M, p, t * X)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"When there is no dispatch for different types of the optional parameter (here t), the _ might be skipped. One could hence see the last code line as a definition on Layer I that passes directly to Layer III, since there are not parameter to dispatch on.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To close this section, let‘s look at an example. The high level (or level I) definition of the retraction is given by","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"retract(M::AbstractManifold, p, X, m::AbstractRetractionMethod=default_retraction_method(M)) = _retract(M,p,X,m)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This level now dispatches on different retraction types. It usually passes to specific functions implemented in Layer III, here for example","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"_retract(M::AbstractManifold, p, X, m::Exponentialretraction) = exp(M,p,X)\n_retract(M::AbstractManifold, p, X, m::PolarRetractionMethod) = retract_polar(M,p,X)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"or the PolarRetractionMethod which dispatches to retract_polar.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"For further details and dispatches, see the appendix for an overview.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nThe documentation should be attached to the high level functions, since this again fosters ease of use. If yuo implement a polar retraction, you should write a function polar_retract but the doc string should be attached to retract(::M, ::P, ::V, ::PolarRetraction) for your types ::M, ::P, ::V of the manifold, points and vectors, respectively.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the (optional) parameters second.","category":"page"},{"location":"design.html#Layer-III:-The-lower-level-interface-to-gain-performance","page":"Design principles","title":"Layer III: The lower level interface to gain performance","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"This lower level aims for performance, that is, any function should have as few as possible optional and keyword arguments and be typed as concrete as possible/necessary. This means","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"the function name should be similar to its high level parent (for example retract and retract_polarfrom above)\nThe manifold type in method signature should always be as narrow as possible.\nthe points/vectors should either be untyped (for the default representation of if there is only one) or provide all types concretely.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The first thing to do on this level is the aforementioned default to pass from allocating to mutating functions.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Note that not all of these functions are exported, but if you implement for example an existing retraction on a new manifold, you will have to import this function.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the concrete manifold and point/vector types last.","category":"page"},{"location":"design.html#Mutating-and-allocating-functions","page":"Design principles","title":"Mutating and allocating functions","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Every function, where this is applicable should provide a mutating and an allocating variant. For example for the exponential map exp(M,p,x) returns a new point q where the result is computed in. On the other hand exp!(M, q, p, X) computes the result in place of q, where the design of the implementation should keep in mind that also exp!(M,p,p,X) should correctly overwrite p.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like exp is to allocate the resulting memory and call exp!.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nit might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the mutating variants.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Non-mutating functions in ManifoldsBase.jl are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The allocate function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), checked types like ValidationMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The function allocate_result allocates a correct return value. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the allocate_result_type function. The most prominent example of the usage of this function is the logarithmic function log when used with typed points. Lets assume on a manifold M the have points of type P and corresponding tangent vector types V. then the logarithmic map has the signature","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"log(::M, ::P, ::P)","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"but the return type would be V, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by omplementing a allocate_result(::M, ::typeof(log), ::P, ::P)that returns the concrete variable for the return. This way, even with specific types, one just has to implement log! and the one line for the allocation.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"note: Note\nThis dispatch from the allocating to the mutating variant happens in Layer III, that is, functions like exp or retract_polar (but not retract itself) allocate their result (using ::typeof(retract) for the second function) and call the mutating variant exp! and retract_polar! afterwards.","category":"page"},{"location":"design.html#Appendix","page":"Design principles","title":"Appendix","text":"","category":"section"},{"location":"design.html#Validations","page":"Design principles","title":"Validations","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The function is_point internally calls the lower level function check_point. Similarly is_vector calls check_vector, which assumes that the (base) point is correct.","category":"page"},{"location":"design.html#subsec_appendix_inv_retr","page":"Design principles","title":"Inverse Retractions","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The high level function inverse_retract(::M, p, X, m::AbstractInverseRetractionMethod) as well as its mutating variant first dispatch on the lower level, before the non-mutating variant (of the name below) allocates memory and calls its mutating variant.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The following table provides an overview of the currently available types and their lower level functions.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Name default lower level function comment\nPolarInverseRetraction inverse_retract_polar \nProjectionInverseRetraction inverse_retract_project \nQRInverseRetraction inverse_retract_qr \nNLsolveInverseRetraction inverse_retract_nlsolve the m is also passed on here.","category":"page"},{"location":"design.html#subsec_appendix_retr","page":"Design principles","title":"Retractions","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The high level function retract(::M, p, X, m::AbstractRetractionMethod) as well as its mutating variant first dispatch on the lower level, before the non-mutating variant (of the name below) allocates memory and calls its mutating variant.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"The following table provides an overview of the currently available types and their lower level functions.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Name default lower level function comment\nPolarRetraction inverse_retract_polar \nProjectionRetraction inverse_retract_project \nQRRetraction inverse_retract_qr ","category":"page"},{"location":"design.html#Vector-transport","page":"Design principles","title":"Vector transport","text":"","category":"section"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"In the follwing table the V in the function names stand for along, to. Nte that vector_transport_direction by default uses the default retraction and to.","category":"page"},{"location":"design.html","page":"Design principles","title":"Design principles","text":"Name default lower level function comment\nDifferentiatedRetractionVectorTransport vector_transport_V_diff the inner retraction is passed on as last argument\nParallelTransport parallel_transport_V \nProjectionTransport vector_transport_V_project ","category":"page"},{"location":"manifold.html#The-Manifold-Type","page":"The manifold","title":"The Manifold Type","text":"","category":"section"},{"location":"manifold.html#Number-systems","page":"The manifold","title":"Number systems","text":"","category":"section"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"Modules = [ManifoldsBase]\nPages = [\"numbers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifold.html#ManifoldsBase.AbstractNumbers","page":"The manifold","title":"ManifoldsBase.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (ℝ for short) and ComplexNumbers (ℂ).\n\n\n\n\n\n","category":"type"},{"location":"manifold.html#ManifoldsBase.ComplexNumbers","page":"The manifold","title":"ManifoldsBase.ComplexNumbers","text":"ComplexNumbers <: AbstractNumbers\nℂ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifold.html#ManifoldsBase.QuaternionNumbers","page":"The manifold","title":"ManifoldsBase.QuaternionNumbers","text":"QuaternionNumbers <: AbstractNumbers\nℍ = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"manifold.html#ManifoldsBase.RealNumbers","page":"The manifold","title":"ManifoldsBase.RealNumbers","text":"RealNumbers <: AbstractNumbers\nℝ = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"manifold.html#ManifoldsBase._unify_number_systems-Tuple{ManifoldsBase.AbstractNumbers, Vararg{ManifoldsBase.AbstractNumbers}}","page":"The manifold","title":"ManifoldsBase._unify_number_systems","text":"_unify_number_systems(𝔽s::AbstractNumbers...)\n\nCompute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.\n\n\n\n\n\n","category":"method"},{"location":"manifold.html#ManifoldsBase.number_system-Union{Tuple{AbstractManifold{𝔽}}, Tuple{𝔽}} where 𝔽","page":"The manifold","title":"ManifoldsBase.number_system","text":"number_system(M::AbstractManifold{𝔽})\n\nReturn the number system the manifold M is based on, i.e. the parameter 𝔽.\n\n\n\n\n\n","category":"method"},{"location":"manifold.html#ManifoldsBase.real_dimension-Tuple{ManifoldsBase.AbstractNumbers}","page":"The manifold","title":"ManifoldsBase.real_dimension","text":"real_dimension(𝔽::AbstractNumbers)\n\nReturn the real dimension dim_ℝ 𝔽 of the AbstractNumbers system 𝔽. The real dimension is the dimension of a real vector space with which a number in 𝔽 can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n\n\n","category":"method"},{"location":"manifold.html#The-main-type:-The-AbstractManifold","page":"The manifold","title":"The main type: The AbstractManifold","text":"","category":"section"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"The main type is the AbstractManifold. It represents the manifold per se. During the documentation we will use the Euclidean Space and the Sphere (both implemented in Manifolds.jl) as easy examples to often illustrate properties and features of this interface","category":"page"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"Modules = [ManifoldsBase]\nPages = [\"maintypes.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifold.html#ManifoldsBase.AbstractManifold","page":"The manifold","title":"ManifoldsBase.AbstractManifold","text":"AbstractManifold{F}\n\nA manifold type. The AbstractManifold is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the exponential and logarithmic maps as well as more general functions that are built on them like the geodesic.\n\nThe manifold is parametrized by an AbstractNumbers to distinguish for example real (ℝ) and complex (ℂ) manifolds.\n\nFor subtypes the preferred order of parameters is: size and simple value parameters, followed by the AbstractNumbers field, followed by data type parameters, which might depend on the abstract number field type.\n\n\n\n\n\n","category":"type"},{"location":"manifold.html#ManifoldsBase.AbstractManifoldPoint","page":"The manifold","title":"ManifoldsBase.AbstractManifoldPoint","text":"AbstractManifoldPoint\n\nType for a point on a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used either\n\nfor more complicated representations,\nsemantic verification, or\neven dispatch for different representations of points on a manifold.\n\nSince semantic verification and different representations usually might still only store a matrix internally, it is possible to use @manifold_element_forwards and @default_manifold_fallbacks to reduce implementation overhead.\n\n\n\n\n\n","category":"type"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"which should store information about the manifold, for example parameters inherent to the manifold.","category":"page"},{"location":"manifold.html#Points-and-Tangent-Vectors","page":"The manifold","title":"Points and Tangent Vectors","text":"","category":"section"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"Points and tangent vectors do not necessarily have to be typed. Usually one can just use any type. When a manifold has multiple representations, these should be distinguished by point and vector types. Then it might be that types just encapsulate a vector value. This is taken into account by the following macros, that forward several actions just to this field. Most prominently vector operations for the tangent vectors. If there is still a default case, a macro sets this type to be equivalent to calling the manifold functions just with the types field that carries the value.","category":"page"},{"location":"manifold.html","page":"The manifold","title":"The manifold","text":"Modules = [ManifoldsBase]\nPages = [\"point_vector_fallbacks.jl\"]\nOrder = [:type, :function, :macro]","category":"page"},{"location":"manifold.html#ManifoldsBase.@default_manifold_fallbacks-Tuple{Any, Any, Any, Symbol, Symbol}","page":"The manifold","title":"ManifoldsBase.@default_manifold_fallbacks","text":"default_manifold_fallbacks(TM, TP, TV, pfield::Symbol, vfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on manifolds, for manifold of type TM, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and vfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"manifold.html#ManifoldsBase.@manifold_element_forwards-Tuple{Any, Symbol}","page":"The manifold","title":"ManifoldsBase.@manifold_element_forwards","text":"manifold_element_forwards(T, field::Symbol)\nmanifold_element_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T (which can be a subtype of Twhere) that represents points or vectors for a manifold. Fallbacks will work by forwarding to the field passed in field`\n\nList of forwarded functions:\n\nallocate,\ncopy,\ncopyto!,\nnumber_eltype (only for values, not the type itself),\nsimilar,\n==.\n\n\n\n\n\n","category":"macro"},{"location":"manifold.html#ManifoldsBase.@manifold_vector_forwards-Tuple{Any, Symbol}","page":"The manifold","title":"ManifoldsBase.@manifold_vector_forwards","text":"manifold_vector_forwards(T, field::Symbol)\nmanifold_vector_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T that represents vectors from a vector bundle for a manifold. Twhere is put into where clause of each method. Fallbacks work by forwarding to field passed as field.\n\nList of forwarded functions:\n\nbasic arithmetic (*, /, \\, +, -),\nall things from @manifold_element_forwards,\nbroadcasting support.\n\nexample\n\n@eval @manifold_vector_forwards ValidationFibreVector{TType} TType value\n\n\n\n\n\n","category":"macro"},{"location":"metamanifolds.html#Manifolds","page":"Meta manifolds","title":"Manifolds","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"While the interface ManifoldsBase.jl does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds","category":"page"},{"location":"metamanifolds.html#Abstract-Power-Manifold","page":"Meta manifolds","title":"Abstract Power Manifold","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"src/PowerManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.AbstractPowerManifold","page":"Meta manifolds","title":"ManifoldsBase.AbstractPowerManifold","text":"AbstractPowerManifold{𝔽,M,TPR} <: AbstractManifold{𝔽}\n\nAn abstract AbstractManifold to represent manifolds that are build as powers of another AbstractManifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.AbstractPowerRepresentation","page":"Meta manifolds","title":"ManifoldsBase.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.InversePowerRetraction","page":"Meta manifolds","title":"ManifoldsBase.InversePowerRetraction","text":"InversePowerRetraction{TR<:AbstractInverseRetractionMethod} <: AbstractInverseRetractionMethod\n\nThe InversePowerRetraction avoids ambiguities between dispatching on the AbstractPowerManifold and dispatching on the AbstractInverseRetractionMethod and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the AbstractPowerManifold should define a way how to treat its AbstractRetractionMethods.\n\nConstructor\n\nInversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.NestedPowerRepresentation","page":"Meta manifolds","title":"ManifoldsBase.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is modified in-place, differently than in NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.NestedReplacingPowerRepresentation","page":"Meta manifolds","title":"ManifoldsBase.NestedReplacingPowerRepresentation","text":"NestedReplacingPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.PowerBasisData","page":"Meta manifolds","title":"ManifoldsBase.PowerBasisData","text":"PowerBasisData{TB<:AbstractArray}\n\nData storage for an array of basis data.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.PowerManifold","page":"Meta manifolds","title":"ManifoldsBase.PowerManifold","text":"PowerManifold{𝔽,TM<:AbstractManifold,TSize<:Tuple,TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{𝔽,TM}\n\nThe power manifold mathcal M^n_1 n_2    n_d with power geometry  TSize statically defines the number of elements along each axis.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.\n\nConstructor\n\nPowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)\nPowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)\nM^(N_1, N_2, ..., N_d)\n\nGenerate the power manifold M^N_1  N_2    N_d. By default, a [PowerManifold](@ref} is expanded further, i.e. for M=PowerManifold(N,3) PowerManifold(M,2) is equivalend to PowerManifold(N,3,2). Points are then 3×2 matrices of points on N. Providing a NestedPowerRepresentation as the second argument to the constructor can be used to nest manifold, i.e. PowerManifold(M,NestedPowerRepresentation(),2) represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.\n\nSince there is no default AbstractPowerRepresentation within this interface, the ^ operator is only available for PowerManifolds and concatenates dimensions.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.PowerRetraction","page":"Meta manifolds","title":"ManifoldsBase.PowerRetraction","text":"PowerRetraction{TR<:AbstractRetractionMethod} <: AbstractRetractionMethod\n\nThe PowerRetraction avoids ambiguities between dispatching on the AbstractPowerManifold and dispatching on the AbstractRetractionMethod and encapsulates this. This container should only be used in rare cases outside of this package. Usually a subtype of the AbstractPowerManifold should define a way how to treat its AbstractRetractionMethods.\n\nConstructor\n\nPowerRetraction(retraction::AbstractRetractionMethod)\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#Base.copyto!-Tuple{AbstractPowerManifold{𝔽, <:AbstractManifold{𝔽}, NestedPowerRepresentation} where 𝔽, Any, Any, Any}","page":"Meta manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, Y, p, X)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, B, a, A) for all elements A, a and B of X, p, and Y, respectively.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.copyto!-Tuple{AbstractPowerManifold{𝔽, <:AbstractManifold{𝔽}, NestedPowerRepresentation} where 𝔽, Any, Any}","page":"Meta manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, q, p)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, b, a) for all elements a and b of p and q, respectively.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta manifolds","title":"Base.exp","text":"exp(M::AbstractPowerManifold, p, X)\n\nCompute the exponential map from p in direction X on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta manifolds","title":"Base.getindex","text":"getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\np[M::AbstractPowerManifold, i...]\n\nAccess the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta manifolds","title":"Base.log","text":"log(M::AbstractPowerManifold, p, q)\n\nCompute the logarithmic map from p to q on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta manifolds","title":"Base.setindex!","text":"setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\nq[M::AbstractPowerManifold, i...] = p\n\nSet the element(s) at index [i...] of a point q on an AbstractPowerManifold M by linear or multidimensional indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#Base.view-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta manifolds","title":"Base.view","text":"view(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\n\nGet the view of the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta manifolds","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, p, X)\n\nCompute the norm of X from the tangent space of p on an AbstractPowerManifold M, i.e. from the element wise norms the Frobenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}","page":"Meta manifolds","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractPowerManifold, p; kwargs...)\n\nCheck whether p is a valid point on an AbstractPowerManifold M, i.e. each element of p has to be a valid point on the base manifold. If p is not a point on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta manifolds","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractPowerManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p an the AbstractPowerManifold M, i.e. atfer check_point(M, p), and all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta manifolds","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q)\n\nCompute the distance between q and p on an AbstractPowerManifold, i.e. from the element wise distances the Forbenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}","page":"Meta manifolds","title":"ManifoldsBase.get_component","text":"get_component(M::AbstractPowerManifold, p, idx...)\n\nGet the component of a point p on an AbstractPowerManifold M at index idx.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}","page":"Meta manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, p])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point p it's equal to the minimum of all radii in the array entries.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Meta manifolds","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from X and Y are in the tangent space of the corresponding element from p. The inner product is then the sum of the elementwise inner products.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, p, q, m::InversePowerRetraction)\n\nCompute the inverse retraction from p with respect to q on an AbstractPowerManifold M using an InversePowerRetraction, which by default encapsulates a inverse retraction of the base manifold. Then this method is performed elementwise, so the encapsulated inverse retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{𝔽, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}","page":"Meta manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1n_d, i.e. with n=(n_1n_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\ndim(mathcal N) = dim(mathcal M)prod_i=1^d n_i = n_1n_2cdotcdot n_d dim(mathcal M)\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{𝔽, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{𝔽}} where {𝔽, TSize}","page":"Meta manifolds","title":"ManifoldsBase.power_dimensions","text":"power_dimensions(M::PowerManifold)\n\nreturn the power of M,\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p, X)\n\nProject the point X onto the tangent space at p on the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}","page":"Meta manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p)\n\nProject the point p from the embedding onto the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta manifolds","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, p, X, method::PowerRetraction)\n\nCompute the retraction from p with tangent vector X on an AbstractPowerManifold M using a PowerRetraction, which by default encapsulates a retraction of the base manifold. Then this method is performed elementwise, so the encapsulated retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}","page":"Meta manifolds","title":"ManifoldsBase.set_component!","text":"set_component!(M::AbstractPowerManifold, q, p, idx...)\n\nSet the component of a point q on an AbstractPowerManifold M at index idx to p, which itself is a point on the AbstractManifold the power manifold is build on.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}","page":"Meta manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nCompute the vector transport the tangent vector Xat p to q on the PowerManifold M using an AbstractVectorTransportMethod m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ValidationManifold","page":"Meta manifolds","title":"ValidationManifold","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"ValidationManifold is a simple decorator using the AbstractDecoratorManifold that “decorates” a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling is_point or is_vector whenever applicable.","category":"page"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"ValidationManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.ValidationCoTVector","page":"Meta manifolds","title":"ManifoldsBase.ValidationCoTVector","text":"ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}\n\nRepresent a cotangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.ValidationFibreVector","page":"Meta manifolds","title":"ManifoldsBase.ValidationFibreVector","text":"ValidationFibreVector{TType<:VectorSpaceType} <: AbstractFibreVector{TType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.ValidationMPoint","page":"Meta manifolds","title":"ManifoldsBase.ValidationMPoint","text":"ValidationMPoint <: AbstractManifoldPoint\n\nRepresent a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationTVectors and ValidationCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.ValidationManifold","page":"Meta manifolds","title":"ManifoldsBase.ValidationManifold","text":"ValidationManifold{𝔽,M<:AbstractManifold{𝔽}} <: AbstractDecoratorManifold{𝔽}\n\nA manifold to encapsulate manifolds working on array representations of AbstractManifoldPoints and TVectors in a transparent way, such that for these manifolds it's not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a AbstractManifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.ValidationTVector","page":"Meta manifolds","title":"ManifoldsBase.ValidationTVector","text":"ValidationTVector = ValidationFibreVector{TangentSpaceType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"Meta manifolds","title":"ManifoldsBase.array_value","text":"array_value(p)\n\nReturn the internal array value of an ValidationMPoint, ValidationTVector, or ValidationCoTVector if the value p is encapsulated as such. Return p if it is already an array.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#EmbeddedmanifoldSec","page":"Meta manifolds","title":"EmbeddedManifold","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"TODO: Update","category":"page"},{"location":"metamanifolds.html#Types","page":"Meta manifolds","title":"Types","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:type]","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.EmbeddedManifold","page":"Meta manifolds","title":"ManifoldsBase.EmbeddedManifold","text":"EmbeddedManifold{𝔽, MT <: AbstractManifold, NT <: AbstractManifold} <: AbstractDecoratorManifold{𝔽}\n\nA type to represent an explicit embedding of a AbstractManifold M of type MT embedded into a manifold N of type NT. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold, see is_isometric_embedded_manifold and is_embedded_submanifold.\n\nnote: Note\nThis type is not required if a manifold M is to be embedded in one specific manifold N.  One can then just implement embed! and project!. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an AbstractDecoratorManifold. Only for a second –maybe considered non-default– embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings N.\n\nFields\n\nmanifold the manifold that is an embedded manifold\nembedding a second manifold, the first one is embedded into\n\nConstructor\n\nEmbeddedManifold(M, N)\n\nGenerate the EmbeddedManifold of the AbstractManifold M into the AbstractManifold N.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#Functions","page":"Meta manifolds","title":"Functions","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:function]","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}","page":"Meta manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the manifold of M that is decorated with its embedding. For this specific type the internally stored enhanced manifold M.manifold is returned.\n\nSee also base_manifold, where this is used to (potentially) completely undecorate the manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}","page":"Meta manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::EmbeddedManifold)\n\nReturn the embedding AbstractManifold N of M, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds.html#DefaultManifold","page":"Meta manifolds","title":"DefaultManifold","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using Manifolds.jl the Euclidean is available, the DefaultManifold itself is not exported.","category":"page"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"ManifoldsBase.DefaultManifold","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.DefaultManifold","page":"Meta manifolds","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: AbstractManifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#Error-Messages","page":"Meta manifolds","title":"Error Messages","text":"","category":"section"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"especially to collect and display errors on AbstractPowerManifolds the following component and collection error messages are available.","category":"page"},{"location":"metamanifolds.html","page":"Meta manifolds","title":"Meta manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"errors.jl\"]\nOrder = [:type]","category":"page"},{"location":"metamanifolds.html#ManifoldsBase.ComponentManifoldError","page":"Meta manifolds","title":"ManifoldsBase.ComponentManifoldError","text":"CompnentError{I,E} <: Exception\n\nStore an error that occured in a component, where the additional index is stored.\n\nFields\n\nindex index where the error occured`\nerror error that occured.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds.html#ManifoldsBase.CompositeManifoldError","page":"Meta manifolds","title":"ManifoldsBase.CompositeManifoldError","text":"CompositeManifoldError{T} <: Exception\n\nA composite type to collect a set of errors that occured. Mainly used in conjunction with ComponentManifoldError to store a set of errors that occured.\n\nFields\n\nerrors a Vector of <:Exceptions.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#A-Decorator-for-manifolds","page":"Extending Manifolds","title":"A Decorator for manifolds","text":"","category":"section"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"A decorator for a manifold is the main scheme to either to explixitly add a property to a manifold. This can be donne for all properties by using the AbstractDecoratorManifold as a supertype.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"In general there are two scenarios, where this is used.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Dispatching a certain default property to another manifold.\nIntroducing an alternate variant of a property.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Let‘s make this more precise. For the first case imagine that a manifold mathcal M is represented by points in the embedding by default. If it is even isometrically embedded, the inner product can be inherited from the embedding. This is a case for the first approach. We provide a default coupling to another manifold to dispatch certain functions over. Which ones are passed on is regulated traits and their dispatch functions.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Assume that a manifold has two different embeddings or a default representation of its points/vectors works without an embedding and there is a second way to represent the manifold in some embedding. This is the situation for the second szenario, see EmbeddedManifold to provide a concrete “coupling” between a manifold and its embedding.","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"implicitly or explicitly add properties _","category":"page"},{"location":"decorator.html","page":"Extending Manifolds","title":"Extending Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"decorator_trait.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"decorator.html#ManifoldsBase.IsEmbeddedManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsEmbeddedManifold","text":"IsEmbeddedManifold <: AbstractTrait\n\nA trait to declare an AbstractManifold as an embedded manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.IsEmbeddedSubmanifoldManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsEmbeddedSubmanifoldManifold","text":"IsEmbeddedSubmanifold{M}\nis_embedded_submanifold(M::Type{<:AbstractDecoratorManifold})\n\nDetermine whether an AbstractDecoratorManifold M is an embedded submanifold. It is a special case of an IsIsometricEmbeddedManifold.\n\nHere, additionally, all retraction, inverse retractions and vectors transports, especially exp, log, and parallel_transport_to are passed to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.IsIsometricEmbeddedManifold","page":"Extending Manifolds","title":"ManifoldsBase.IsIsometricEmbeddedManifold","text":"IsIsometricManifoldEmbeddedManifold <: AbstractTrait\n\nDetermine whether an AbstractDecoratorManifold M is an isometrically embedded manifold. To activate this for your manifold, set is_isometric_embedded_manifold for your manifold type to true.\n\nHere, for example inner and norm are passed to the embedding\n\n\n\n\n\n","category":"type"},{"location":"decorator.html#ManifoldsBase.decorated_manifold-Tuple{AbstractDecoratorManifold}","page":"Extending Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::AbstractDecoratorManifold)\n\nFor a manifold M that is decorated with properties (for example an embedding N) this function returns the manifold that is attached (as a decorator). Hence for the embedding example this is N.\n\n\n\n\n\n","category":"method"},{"location":"decorator.html#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold}","page":"Extending Manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::AbstractDecoratorManifold)\n\nSpecify the embedding of a manifold that has abstract decorators.\n\n\n\n\n\n","category":"method"},{"location":"index.html#ManifoldsBase.jl","page":"Home","title":"ManifoldsBase.jl","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"ManifoldsBase.jl is a lightweight interface for manifolds.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"You can easily implement your algorithms and even your own manifolds just using the interface. All manifolds from the package here are also based on this interface, so any project based on the interface can benefit from all manifolds, as soon as a certain manifold provides implementations of the functions a project requires.","category":"page"},{"location":"index.html#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"If you use ManifoldsBase.jl in your work, please cite the following paper, which covers both the basic interface as well as the performance for Manifolds.jl.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"@online{2106.08777,\n    Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann and Krzysztof Rzecki},\n    Title = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    Year = {2021},\n    Eprint = {2106.08777},\n    Eprinttype = {arXiv},\n}","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Note that the citation is in BibLaTeX format.","category":"page"},{"location":"example.html#manifold-tutorial","page":"How to write a manifold","title":"How to implement your own manifold","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"CurrentModule = ManifoldsBase","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"This tutorial demonstrates how to easily set your own manifold up within Manifolds.jl.","category":"page"},{"location":"example.html#Introduction","page":"How to write a manifold","title":"Introduction","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"This tutorial demonstrates that you can get your first own manifold quite fast and you only have to implement the functions you actually need. This tutorial assumes that you heard of the exponential map, tangent vectors and the dimension of a manifold. If not, please read for example [do Carmo, 1992], Chapter 3, first.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In general you need just a datatype (struct) that inherits from AbstractManifold to define a manifold. No function is per se required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example check_point and check_vector, as we do in this tutorial.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"We start with two technical preliminaries. If you want to start directly, you can skip this paragraph and revisit it for two of the implementation details.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"After that, we will","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"model the manifold\nimplement two tests, so that points and tangent vectors can be checked for validity, for example also within ValidationManifold,\nimplement two functions, the exponential map and the manifold dimension.","category":"page"},{"location":"example.html#manifold-tutorial-prel","page":"How to write a manifold","title":"Technical preliminaries","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"There are only two small technical things we need to explain at this point. First of all our AbstractManifold{𝔽} has a parameter 𝔽. This parameter indicates the number_system the manifold is based on, for example ℝ for real manifolds. It is important primarily for defining bases of tangent spaces.","category":"page"},{"location":"example.html#manifold-tutorial-startup","page":"How to write a manifold","title":"Startup","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"As a start, let's load ManifoldsBase.jl and import the functions we consider throughout this tutorial. For implementing a manifold, loading the interface should suffice for quite some time.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"using ManifoldsBase, LinearAlgebra, Test\nimport ManifoldsBase: check_point, check_vector, manifold_dimension, exp!","category":"page"},{"location":"example.html#manifold-tutorial-task","page":"How to write a manifold","title":"Goal","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"As an example, let's implement the sphere, but with a radius r. Since this radius is a property inherent to the manifold, it will become a field of the manifold. The second information, we want to store is the dimension of the sphere, for example whether it's the 1-sphere, i.e. the circle, represented by vectors pinmathbb R^2 or the 2-sphere in mathbb R^3. Since the latter might be something we want to dispatch on, we model it as a parameter of the type.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In general the struct of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is – most prominently – a way to determine the manifold dimension.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For our example we define","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"\"\"\"\n    MySphere{N} <: AbstractManifold{ℝ}\n\nDefine an `n`-sphere of radius `r`. Construct by `MySphere(radius,n)`\n\"\"\"\nstruct MySphere{N} <: AbstractManifold{ManifoldsBase.ℝ} where {N}\n    radius::Float64\nend\nMySphere(radius, n) = MySphere{n}(radius)\nBase.show(io::IO, M::MySphere{n}) where {n} = print(io, \"MySphere($(M.radius),$n)\")\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Here, the last line just provides a nicer print of a variable of that type Now we can already initialize our manifold that we will use later, the 2-sphere of radius 15.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"S = MySphere(1.5, 2)","category":"page"},{"location":"example.html#manifold-tutorial-checks","page":"How to write a manifold","title":"Checking points and tangents","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"If we have now a point, represented as an array, we would first like to check, that it is a valid point on the manifold. For this one can use the easy interface is_point. This internally uses check_point. This is what we want to implement. We have to return the error if p is not on M and nothing otherwise.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"We have to check two things: that a point p is a vector with N+1 entries and its norm is the desired radius. To spare a few lines, we can use short-circuit evaluation instead of if statements. If something has to only hold up to precision, we can pass that down, too using the kwargs....","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function check_point(M::MySphere{N}, p; kwargs...) where {N}\n    (size(p)) == (N+1,) || return DomainError(size(p),\"The size of $p is not $((N+1,)).\")\n    if !isapprox(norm(p), M.radius; kwargs...)\n        return DomainError(norm(p), \"The norm of $p is not $(M.radius).\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Similarly, we can verify, whether a tangent vector X is valid. It has to fulfill the same size requirements and it has to be orthogonal to p. We can again use the kwargs, but also provide a way to check p, too.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function check_vector(M::MySphere, p, X; kwargs...)\n    size(X) != size(p) && return DomainError(size(X), \"The size of $X is not $(size(p)).\")\n    if !isapprox(dot(p,X), 0.0; kwargs...)\n        return DomainError(dot(p,X), \"The tangent $X is not orthogonal to $p.\")\n    end\n    return nothing\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"to test points we can now use","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"is_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false\n@test_throws DomainError is_point(S, [1.5,0.0], true) # only on R^2, throws an error.\np = [1.5,0.0,0.0]\nX = [0.0,1.0,0.0]\n# The following two tests return true\n[ is_point(S, p); is_vector(S,p,X) ]","category":"page"},{"location":"example.html#manifold-tutorial-fn","page":"How to write a manifold","title":"Functions on the manifold","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For the manifold_dimension we have to just return the N parameter","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"manifold_dimension(::MySphere{N}) where {N} = N\nmanifold_dimension(S)","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"To implement the exponential map, we have to implement the formula for great arcs, given a start point p and a direction X on the n-sphere of radius r the formula reads","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"exp_p X = cos(frac1rlVert X rVert)p + sin(frac1rlVert X rVert)fracrlVert X rVertX","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Note that with this choice we for example implicitly assume a certain metric. This is completely fine. We only have to think about specifying a metric explicitly, when we have (at least) two different metrics on the same manifold.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"An implementation of the mutation version, see the technical note, reads","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"function exp!(M::MySphere{N}, q, p, X) where {N}\n    nX = norm(X)\n    if nX == 0\n        q .= p\n    else\n        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (X./nX)\n    end\n    return q\nend\nnothing #hide","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"A first easy check can be done taking p from above and any vector X of length 1.5π from its tangent space. The resulting point is opposite of p, i.e. -p","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"q = exp(S,p, [0.0,1.5π,0.0])\n[isapprox(p,-q); is_point(S,q)]","category":"page"},{"location":"example.html#manifold-tutorial-outlook","page":"How to write a manifold","title":"Conclusion","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"You can now just continue implementing further functions from ManifoldsBase.jl. but with just exp! you for example already have","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"geodesic the (not necessarily shortest) geodesic emanating from p in direction X.\nthe ExponentialRetraction, that the retract function uses by default.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"For the shortest_geodesic the implementation of a logarithm log, again better a log! is necessary.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"Sometimes a default implementation is provided; for example if you implemented inner, the norm is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With log! and inner you get the distance, and so.","category":"page"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from Manifolds.jl requires another function to be specifically implemented, you get a reasonable error message.","category":"page"},{"location":"example.html#Literature","page":"How to write a manifold","title":"Literature","text":"","category":"section"},{"location":"example.html","page":"How to write a manifold","title":"How to write a manifold","text":"<ul>\n<li id=\"doCarmo1992\">\n    [<a>doCarmo, 1992</a>]\n    M. P. do Carmo,\n    <emph>Riemannian Geometry</emph>,\n    Birkhäuser Boston, 1992,\n    ISBN: 0-8176-3490-8.\n</li>\n</ul>","category":"page"}]
}
