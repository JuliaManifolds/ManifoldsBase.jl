<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to define a manifold ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="example.html">How to define a manifold</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#manifold-tutorial-prel"><span>Technical preliminaries</span></a></li><li><a class="tocitem" href="#manifold-tutorial-startup"><span>Startup</span></a></li><li><a class="tocitem" href="#manifold-tutorial-task"><span>The manifold</span></a></li><li><a class="tocitem" href="#manifold-tutorial-checks"><span>Checking points and tangents</span></a></li><li><a class="tocitem" href="#manifold-tutorial-fn"><span>Functions on the manifold</span></a></li><li><a class="tocitem" href="#manifold-tutorial-emb"><span>Adding an isometric embedding</span></a></li><li><a class="tocitem" href="#manifold-tutorial-outlook"><span>Conclusion</span></a></li><li><a class="tocitem" href="#Literature"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="types.html">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="functions.html">Basic functions</a></li><li><a class="tocitem" href="projections.html">Projections</a></li><li><a class="tocitem" href="retractions.html">Retractions</a></li><li><a class="tocitem" href="vector_transports.html">Vector transports</a></li></ul></li><li><a class="tocitem" href="manifolds.html">Manifolds</a></li><li><a class="tocitem" href="decorator.html">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="example.html">How to define a manifold</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="example.html">How to define a manifold</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/example.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="manifold-tutorial"><a class="docs-heading-anchor" href="#manifold-tutorial">How to implement your own manifold</a><a id="manifold-tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>This tutorial explains how to implement a manifold using the <code>ManifoldsBase.jl</code> interface. We assume that you are familiar with the basic terminology on Riemannian manifolds, especially the dimension of a manifold, the exponential map, and the inner product on tangent spaces. To read more about this you can for example check <sup class="footnote-reference"><a id="citeref-doCarmo1992" href="#footnote-doCarmo1992">[doCarmo1992]</a></sup>, Chapter 3, first.</p><p>Furthermore, we will look at a manifold that is isometrically embedded into a Euclidean space.</p><p>In general you need just a data type (<code>struct</code>) that inherits from <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to define a manifold. No function is <em>per se</em> required to be implemented. However, it is a good idea to provide functions that might be useful to others, for example <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_vector</code></a>, as we do in this tutorial.</p><p>In this tutorial we will</p><ul><li><a href="example.html#manifold-tutorial-task">model</a> the manifold</li><li><a href="example.html#manifold-tutorial-checks">implement</a> two tests, so that points and tangent vectors can be checked for validity, for example also within <a href="manifolds.html#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>,</li><li><a href="example.html#manifold-tutorial-fn">implement</a> two functions, the exponential map and the manifold dimension.</li><li><a href="example.html#manifold-tutorial-emb">decorate</a> the manifold with an embedding to gain further features.</li></ul><p>The next two sections are just a technical detail and the necessary <code>import</code>s to extend the functions defined in this interface.</p><h2 id="manifold-tutorial-prel"><a class="docs-heading-anchor" href="#manifold-tutorial-prel">Technical preliminaries</a><a id="manifold-tutorial-prel-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-prel" title="Permalink"></a></h2><p>There are only two small technical things we need to explain at this point before we get started. First of all our <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>{ùîΩ}</code> has a parameter <code>ùîΩ</code>. This parameter indicates the <a href="bases.html#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ"><code>number_system</code></a> the manifold is based on, for example <code>‚Ñù</code> for real manifolds, which is short for <a href="types.html#ManifoldsBase.RealNumbers"><code>RealNumbers</code></a><code>()</code> or <code>‚ÑÇ</code> for complex manifolds, a shorthand for <a href="types.html#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a><code>()</code>.</p><p>Second, this interface usually provides both an allocating and an in-place variant of each function, for example for the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map <a href="example.html#manifold-tutorial-fn">implemented below</a> this interface provides <code>exp(M, p, X)</code> to compute the exponential map and <code>exp!(M, q, p, X)</code> to compute the exponential map in the memory provided by <code>q</code>, mutating that input. the convention is, that the manifold is the first argument ‚Äì in both function variants ‚Äì the in-place variant then has the input to be mutated in second place, and the remaining parameters are again the same (<code>p</code>and <code>X</code> here). We usually refer to these two variants of the same function as the allocating (<code>exp</code>) function and the in-place (<code>exp!</code>) one.</p><p>The convention for this interface is to <strong>document the allocation function</strong>, which by default allocates the necessary memory and calls the in-place function. So the convention is to just <strong>implement the in-place function</strong>, unless there is a good reason to provide an implementation for both. For more details see <a href="design.html#inplace-and-noninplace">the design section on in-place and non-mutating functions</a></p><p>For performance reasons scaled variants of retractions <code>retraction!(M, q, p, X, t, m)</code> and exponential maps <code>exp!(M, q, p, X, t)</code> should be implemented. Scale is specified by an optional argument that comes after the tangent vector and by default it is equal to 1. The variant without scaling, e.g. <code>exp!(M, q, p, X)</code>, can be implemented as well if there is a good reason like performance, but the default fallback of this variant is to call the previous one with <code>t=1</code>.</p><h2 id="manifold-tutorial-startup"><a class="docs-heading-anchor" href="#manifold-tutorial-startup">Startup</a><a id="manifold-tutorial-startup-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-startup" title="Permalink"></a></h2><p>As a start, let&#39;s load <code>ManifoldsBase.jl</code> and import the functions we consider throughout this tutorial.</p><pre><code class="language-julia hljs">using ManifoldsBase, LinearAlgebra, Test
import ManifoldsBase: check_point, check_vector, manifold_dimension, exp!, inner, representation_size, get_embedding
import Base: show</code></pre><p>We load <code>LinearAlgebra</code> for some computations. <code>Test</code> is only loaded for illustrations in the examples.</p><p>We import the in-place variant of the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map, as just discussed above.</p><h2 id="manifold-tutorial-task"><a class="docs-heading-anchor" href="#manifold-tutorial-task">The manifold</a><a id="manifold-tutorial-task-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-task" title="Permalink"></a></h2><p>The manifold we want to implement here a sphere, with radius <span>$r$</span>. Since this radius is a property inherent to the manifold, it will become a field of the manifolds <code>struct</code>. The second information, we want to store is the dimension of the sphere, for example whether it&#39;s the 1-sphere, i.e. the circle, represented by vectors <span>$p\in\mathbb R^2$</span> of norm <span>$r$</span> or the 2-sphere in <span>$\mathbb R^3$</span> of radius <span>$r$</span>. Since the latter might be something we want to <a href="https://en.wikipedia.org/wiki/Multiple_dispatch">dispatch</a> on, we model it as a parameter of the type. In general the <code>struct</code> of a manifold should provide information about the manifold, which are inherent to the manifold or has to be available without a specific point or tangent vector present. This is ‚Äì most prominently ‚Äì all information required to determine the manifold dimension.</p><p>Note that this a slightly more general manifold than the <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/sphere.html">Sphere</a> in <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/index.html">Manifolds.jl</a></p><p>For our example we define the following <code>struct</code>. While a first implementation might also just take <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>{‚Ñù}</code> as supertype, we directly take <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a><code>{‚Ñù}</code>, which will be useful later on. For now it does not make a difference.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    ScaledSphere{N} &lt;: AbstractDecoratorManifold{‚Ñù}

Define an `N`-sphere of radius `r`. Construct by `ScaledSphere(radius,n)`.
&quot;&quot;&quot;
struct ScaledSphere{N} &lt;: AbstractDecoratorManifold{ManifoldsBase.‚Ñù} where {N}
    radius::Float64
end
ScaledSphere(radius, n) = ScaledSphere{n}(radius)
Base.show(io::IO, M::ScaledSphere{n}) where {n} = print(io, &quot;ScaledSphere($(M.radius),$n)&quot;)</code></pre><p>Here, the last line just provides a nicer print of a variable of that type. Now we can already initialize our manifold that we will use later, the <span>$2$</span>-sphere of radius <span>$1.5$</span>.</p><pre><code class="language-julia hljs">S = ScaledSphere(1.5, 2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ScaledSphere(1.5,2)</code></pre><h2 id="manifold-tutorial-checks"><a class="docs-heading-anchor" href="#manifold-tutorial-checks">Checking points and tangents</a><a id="manifold-tutorial-checks-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-checks" title="Permalink"></a></h2><p>Points on a manifold are usually represented as vector, matrices or more generally arrays. Since we consider vectors of a certain norm (and space dimension), our points are vectors. For an arbitrary vector we would first like to check, that it is a valid point on the manifold. For this one can use the function <a href="functions.html#ManifoldsBase.is_point"><code>is_point</code></a>. This is a function on <a href="design.html#design-layer1">layer 1</a> which handles special cases as well cases, so it should not be implemented directly by a user of this interface. The functions that have to be implemented can be found on <a href="design.html#design-layer3">layer 3</a>. Generically, for both <a href="functions.html#ManifoldsBase.is_point"><code>is_point</code></a> and  <a href="functions.html#ManifoldsBase.is_vector"><code>is_vector</code></a>, this layer contains a function to check correct size of an array, called <a href="functions.html#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>check_size</code></a> For the test of points the function to implement is <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> which we actually will implement, analogously there exists also <a href="functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a>. These functions return <code>nothing</code> if the point (vector, size) is a correct/valid and returns an error (but not throw it) otherwise. This is usually a <code>DomainError</code>.</p><p>We have to check two things: that a point <code>p</code> is a vector with <code>N+1</code> entries and its norm is the desired radius.</p><p>A first thing we have specify is how points and tangent vectors are represented, that is we have to specify their <a href="functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a></p><pre><code class="language-julia hljs">representation_size(::ScaledSphere{N}) where {N} = N+1</code></pre><p>This already finishes the size check which <a href="functions.html#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>check_size</code></a> performs by default (based on the representation size).</p><p>If something has to only hold up to precision, we can pass that down, too using the <code>kwargs...</code>, so all three <code>check_</code> functions should usually have these in their signature. For our manifold we have to check that the norm of a point <code>p</code> is approximately the specified <code>radius</code>.</p><pre><code class="language-julia hljs">function check_point(M::ScaledSphere{N}, p; kwargs...) where {N}
    if !isapprox(norm(p), M.radius; kwargs...)
        return DomainError(norm(p), &quot;The norm of $p is not $(M.radius).&quot;)
    end
    return nothing
end</code></pre><p>Similarly, we can verify, whether a tangent vector <code>X</code> is valid. Its size is again already checked using <a href="functions.html#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>check_size</code></a>, so the only remaining property to verify is, that <code>X</code> is orthogonal to <code>p</code>. We can again use the <code>kwargs</code>.</p><pre><code class="language-julia hljs">function check_vector(M::ScaledSphere, p, X; kwargs...)
    if !isapprox(dot(p,X), 0.0; kwargs...)
        return DomainError(dot(p,X), &quot;The tangent $X is not orthogonal to $p.&quot;)
    end
    return nothing
end</code></pre><p>Note that the function <a href="functions.html#ManifoldsBase.is_vector"><code>is_vector</code></a> even can check that the base point of <code>X</code> (the <code>p</code> the tangent space belongs to), can be checked for validity, see its keyword argument <code>check_base_point</code>, so within  <a href="functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a> this can be (implicitly) assumed to hold.</p><p>to test points we can now use</p><pre><code class="language-julia hljs">is_point(S, [1.0,0.0,0.0]) # norm 1, so not on S, returns false
@test_throws DomainError is_point(S, [1.5,0.0], true) # only on R^2, throws an error.
p = [1.5,0.0,0.0]
X = [0.0,1.0,0.0]
# The following two tests return true
[ is_point(S, p); is_vector(S,p,X) ]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Bool}:
 0
 0</code></pre><h2 id="manifold-tutorial-fn"><a class="docs-heading-anchor" href="#manifold-tutorial-fn">Functions on the manifold</a><a id="manifold-tutorial-fn-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-fn" title="Permalink"></a></h2><p>For the <a href="functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a> we have to just return the <code>N</code> parameter</p><pre><code class="language-julia hljs">manifold_dimension(::ScaledSphere{N}) where {N} = N
manifold_dimension(S)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><p>Note that we can even omit the variable name in the first line since we do not have to access any field or use the variable otherwise.</p><p>To implement the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map, we have to implement the formula for great arcs, given a start point <code>p</code> and a direction <code>X</code> on the <span>$n$</span>-sphere of radius <span>$r$</span> the formula reads</p><p class="math-container">\[\exp_p X = \cos\Bigl(\frac{1}{r}\lVert X \rVert\Bigr)p + \sin\Bigl(\frac{1}{r}\lVert X \rVert\Bigr)\frac{r}{\lVert X \rVert}X.\]</p><p>Note that with this choice we for example implicitly assume that the manifold is equipped with that certain metric. This is the default within this interface. To distinguish different metrics, see <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/metric.html"><code>MetricManifold</code></a> in <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/">Manifolds.jl</a> for more details. Since we here only consider one metric, we do not have to specify that.</p><p>An implementation of the mutation version, see the <a href="example.html#manifold-tutorial-prel">technical note</a> for the naming and reasoning, reads</p><pre><code class="language-julia hljs">function exp!(M::ScaledSphere{N}, q, p, X, t::Number) where {N}
    nX = abs(t) * norm(X)
    if nX == 0
        q .= p
    else
        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* t .* (X./nX)
    end
    return q
end</code></pre><p>A first easy check can be done taking <code>p</code> from above and any vector <code>X</code> of length <code>1.5œÄ</code> from its tangent space. The resulting point is opposite of <code>p</code>, i.e. <code>-p</code> and it is of course a valid point on <code>S</code>.</p><pre><code class="language- hljs">q = exp(S, p, [0.0,1.5œÄ,0.0])
[isapprox(p, -q); is_point(S, q)]</code></pre><h2 id="manifold-tutorial-emb"><a class="docs-heading-anchor" href="#manifold-tutorial-emb">Adding an isometric embedding</a><a id="manifold-tutorial-emb-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-emb" title="Permalink"></a></h2><p>Since the sphere is isometrically embedded, we do not have to implement the <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a><code>(M,p,X,Y)</code> for tangent vectors <code>X</code>, <code>Y</code> in the tangent space at <code>p</code> , but we can ‚Äúdelegate‚Äù it to the embedding. The embedding is the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html">Euclidean</a>. The same manifold with a little smaller feature set is available in <code>ManifoldsBase.jl</code> as <code>DefaultManifold</code> for testing purposes.</p><pre><code class="language-julia hljs">using ManifoldsBase: DefaultManifold, IsIsometricEmbeddedManifold
import ManifoldsBase: active_traits, get_embedding
using ManifoldsBase: merge_traits</code></pre><p>Now we can activate a decorator by specifying that the sphere has the <a href="decorator.html#ManifoldsBase.IsIsometricEmbeddedManifold"><code>IsIsometricEmbeddedManifold</code></a> trait for the functions <code>f</code> on our scaled sphere manifold by writing</p><pre><code class="language-julia hljs">active_traits(f, ::ScaledSphere, args...) = merge_traits(IsIsometricEmbeddedManifold())</code></pre><p>and then specifying that said embedding is the <code>DefaultManifold</code>.</p><pre><code class="language-julia hljs">get_embedding(::ScaledSphere{N}) where {N} = DefaultManifold(N+1)</code></pre><p>Now metric related functions are passed to this embedding, for example the inner product. It now works by using the inner product from the embedding, so we can compute the inner product by calling <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a></p><pre><code class="language-julia hljs">X = [0.0, 0.1, 3.0]
Y = [0.0, 4.0, 0.2]
# returns 1.0 by calling the inner product in DefaultManifold(3)
inner(S, p, X, Y)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1.0</code></pre><h2 id="manifold-tutorial-outlook"><a class="docs-heading-anchor" href="#manifold-tutorial-outlook">Conclusion</a><a id="manifold-tutorial-outlook-1"></a><a class="docs-heading-anchor-permalink" href="#manifold-tutorial-outlook" title="Permalink"></a></h2><p>You can now just continue implementing further functions from <code>ManifoldsBase.jl</code> but with just <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a> you for example already have</p><ul><li><a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>geodesic</code></a> the (not necessarily shortest) geodesic emanating from <code>p</code> in direction <code>X</code>.</li><li>the <a href="retractions.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>, that the <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> function uses by default.</li></ul><p>For the <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>shortest_geodesic</code></a> the implementation of a logarithm <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, or just <a href="functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>log!</code></a> is sufficient.</p><p>Sometimes a default implementation is provided; for example if you implemented <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>, the <a href="functions.html#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>norm</code></a> is defined. You should overwrite it, if you can provide a more efficient version. For a start the default should suffice. With <a href="functions.html#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>log!</code></a> and <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a> you get the <a href="functions.html#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>distance</code></a>, and so.</p><p>In summary with just these few functions you can already explore the first things on your own manifold. Whenever a function from <code>Manifolds.jl</code> requires another function to be specifically implemented, you get a reasonable error message.</p><h2 id="Literature"><a class="docs-heading-anchor" href="#Literature">Literature</a><a id="Literature-1"></a><a class="docs-heading-anchor-permalink" href="#Literature" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-doCarmo1992"><a class="tag is-link" href="#citeref-doCarmo1992">doCarmo1992</a><blockquote><p>do Carmo, Manfredo <strong>Riemannian Geometry</strong>,  Birkh√§user Boston, 1992, ISBN: 0-8176-3490-8.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">¬´ Home</a><a class="docs-footer-nextpage" href="design.html">Design principles ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 February 2023 17:27">Tuesday 14 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
