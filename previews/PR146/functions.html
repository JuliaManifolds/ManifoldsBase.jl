<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic functions · ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to define a manifold</a></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="types.html">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li class="is-active"><a class="tocitem" href="functions.html">Basic functions</a><ul class="internal"><li><a class="tocitem" href="#exp-and-log"><span>The exponential map, the logarithmic map, and geodesics</span></a></li><li><a class="tocitem" href="#subsec-parallel-transport"><span>Parallel transport</span></a></li><li><a class="tocitem" href="#Further-functions-on-manifolds"><span>Further functions on manifolds</span></a></li><li><a class="tocitem" href="#Error-Messages"><span>Error Messages</span></a></li></ul></li><li><a class="tocitem" href="projections.html">Projections</a></li><li><a class="tocitem" href="retractions.html">Retractions</a></li><li><a class="tocitem" href="vector_transports.html">Vector transports</a></li></ul></li><li><a class="tocitem" href="manifolds.html">Manifolds</a></li><li><a class="tocitem" href="decorator.html">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions on maniolds</a></li><li class="is-active"><a href="functions.html">Basic functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="functions.html">Basic functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-on-manifolds"><a class="docs-heading-anchor" href="#Functions-on-manifolds">Functions on manifolds</a><a id="Functions-on-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-manifolds" title="Permalink"></a></h1><p>This page collects several basic functions on manifolds.</p><h2 id="exp-and-log"><a class="docs-heading-anchor" href="#exp-and-log">The exponential map, the logarithmic map, and geodesics</a><a id="exp-and-log-1"></a><a class="docs-heading-anchor-permalink" href="#exp-and-log" title="Permalink"></a></h2><p>Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector “points towards” the other point.</p><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractManifold, Any, Any}" href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractManifold, p, X)
exp(M::AbstractManifold, p, X, t::Number = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[\exp_p X = γ_{p,X}(1),\]</p><p>where <span>$γ_{p,X}$</span> is the unique geodesic starting in <span>$γ(0)=p$</span> such that <span>$\dot γ(0) = X$</span>.</p><p>See also <a href="functions.html#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>shortest_geodesic</code></a>, <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractManifold, Any, Any}" href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractManifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The logarithmic map is the inverse of the <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>See also <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp!(M::AbstractManifold, q, p, X)
exp!(M::AbstractManifold, q, p, X, t::Number = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p><p>If you want to implement exponential map for your manifold, you should implement the method with <code>t</code>, that is <code>exp!(M::MyManifold, q, p, X, t::Number)</code>.</p><p>See also <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L26-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, Q, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at time points <code>t</code> fom <code>T</code> in place of <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L118-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, q, p, X, t::Real)</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at <code>t</code> in place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L103-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields that the curve has constant velocity and is locally distance-minimizing.</p><p>This function returns a function <code>(q,t)</code> of (time) <code>t</code> that mutates <code>q</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L86-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate the geodesic <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>at time points <code>t</code> from <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L72-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X, t::Real)</code></pre><p>Evaluate the geodesic <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L59-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.</p><p>This function returns a function of (time) <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L42-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log!(M::AbstractManifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>X</code>. The logarithmic map is the inverse of the <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>see also <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> and <a href="retractions.html#ManifoldsBase.inverse_retract!"><code>inverse_retract!</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L154-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at all <code>t</code> from <code>T</code> in place of <code>R</code>. When there are multiple shortest geodesics, a deterministic choice will be taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L224-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)</code></pre><p>Evaluate a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at <code>t</code> in place of <code>r</code>. When there are multiple shortest geodesics, a deterministic choice will be taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L214-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function <code>(r,t) -&gt; ...</code> of time <code>t</code> which works in place of <code>r</code>.</p><p>Further variants</p><pre><code class="nohighlight hljs">shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)
shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>mutate (and return) the point <code>r</code> and the vector of points <code>R</code>, respectively, returning the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L196-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at time points <code>T</code>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AabstractManifold, p, q, t::Real)</code></pre><p>Evaluate a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at time <code>t</code>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L176-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/exp_log_geo.jl#L166-L174">source</a></section></article><h2 id="subsec-parallel-transport"><a class="docs-heading-anchor" href="#subsec-parallel-transport">Parallel transport</a><a id="subsec-parallel-transport-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-parallel-transport" title="Permalink"></a></h2><p>While moving vectors from one base point to another is the identity in the Euclidean space – or in other words all tangent spaces (directions one can “walk” into) are the same. This is different on a manifold.</p><p>If we have two points <span>$p,q ∈ \mathcal M$</span>, we take a <span>$c: [0,1] → \mathcal M$</span> connecting the two points, i.e. <span>$c(0) = p$</span> and <span>$c(1) = q$</span>. this could be a (or the) geodesic. If we further consider a vector field <span>$X: [0,1] → T\mathcal M$</span>, i.e. where <span>$X(t) ∈ T_{c(t)}\mathcal M$</span>. Then the vector field is called <em>parallel</em> if its covariant derivative <span>$\frac{\mathrm{D}}{\mathrm{d}t}X(t) = 0$</span> for all <span>$t∈ |0,1]$</span>.</p><p>If we now impose a value for <span>$X=X(0) ∈ T_p\mathcal M$</span>, we obtain an ODE with an initial condition. The resulting value <span>$X(1) ∈ T_q\mathcal M$</span> is called the <em>parallel transport</em> of <code>X</code> along <span>$c$</span> or in case of a geodesic the _parallel transport of <code>X</code> from <code>p</code> to <code>q</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.parallel_transport_along</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Y = parallel_transport_along(M::AbstractManifold, p, X, c)</code></pre><p>Compute the parallel transport of the vector <code>X</code> from the tangent space at <code>p</code> along the curve <code>c</code>.</p><p>To be precise let <span>$c(t)$</span> be a curve <span>$c(0)=p$</span> for <a href="vector_transports.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a> <span>$\mathcal P^cY$</span></p><p>THen In the result <span>$Y\in T_p\mathcal M$</span> is the vector <span>$X$</span> from the tangent space at <span>$p=c(0)$</span> to the tangent space at <span>$c(1)$</span>.</p><p>Let <span>$Z\colon [0,1] \to T\mathcal M$</span>, <span>$Z(t)\in T_{c(t)}\mathcal M$</span> be a smooth vector field along the curve <span>$c$</span> with <span>$Z(0) = Y$</span>, such that <span>$Z$</span> is <em>parallel</em>, i.e. its covariant derivative <span>$\frac{\mathrm{D}}{\mathrm{d}t}Z$</span> is zero. Note that such a <span>$Z$</span> always exists and is unique.</p><p>Then the parallel transport is given by <span>$Z(1)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/parallel_transport.jl#L3-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.parallel_transport_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_transport_direction(M::AbstractManifold, p, X, d)</code></pre><p>Compute the <a href="functions.html#ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>parallel_transport_along</code></a> the curve <span>$c(t) = γ_{p,q}(t)$</span>, i.e. the * the unique geodesic <span>$c(t)=γ_{p,X}(t)$</span> from <span>$γ_{p,d}(0)=p$</span> into direction <span>$\dot γ_{p,d}(0)=d$</span>, of the tangent vector <code>X</code>.</p><p>By default this function calls <a href="functions.html#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_to</code></a><code>(M, p, X, q)</code>, where <span>$q=\exp_pX$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/parallel_transport.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.parallel_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_transport_to(M::AbstractManifold, p, X, q)</code></pre><p>Compute the <a href="functions.html#ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>parallel_transport_along</code></a> the curve <span>$c(t) = γ_{p,q}(t)$</span>, i.e. the (assumed to be unique) <a href="functions.html#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> connecting <code>p</code> and <code>q</code>, of the tangent vector <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/parallel_transport.jl#L43-L48">source</a></section></article><h2 id="Further-functions-on-manifolds"><a class="docs-heading-anchor" href="#Further-functions-on-manifolds">Further functions on manifolds</a><a id="Further-functions-on-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Further-functions-on-manifolds" title="Permalink"></a></h2><h3 id="General-functions-provided-by-the-interface"><a class="docs-heading-anchor" href="#General-functions-provided-by-the-interface">General functions provided by the interface</a><a id="General-functions-provided-by-the-interface-1"></a><a class="docs-heading-anchor-permalink" href="#General-functions-provided-by-the-interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.angle-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">angle(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with respect to the inner product from <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any, Any}" href="#Base.copy-Tuple{AbstractManifold, Any, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p, X)</code></pre><p>Copy the value(s) from the tangent vector <code>X</code> at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new tangent vector. See <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L277-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any}" href="#Base.copy-Tuple{AbstractManifold, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy(M, p)</code></pre><p>Copy the value(s) from the point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new point. See <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="functions.html#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L265-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, Y, p, X)</code></pre><p>Copy the value(s) from <code>X</code> to <code>Y</code>, where both are tangent vectors from the tangent space at <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(Y, X)</code>, but it might be useful to overwrite the function at the level, where also information from <code>p</code> and <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, q, p)</code></pre><p>Copy the value(s) from <code>p</code> to <code>q</code>, where both are points on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(q, p)</code>, but it might be useful to overwrite the function at the level, where also information from <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L292-L298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, X, Y; error:Symbol=:none; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>The optional positional argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported</p><ul><li><code>:error</code> - throws an error if <code>isapprox</code> evaluates to false, providing possibly a more detailed error. Note that this turns <code>isapprox</code> basically to an <code>@assert</code>.</li><li><code>:info</code> – prints the information in an <code>@info</code></li><li><code>:warn</code> – prints the information in an <code>@warn</code></li><li><code>:none</code> (default) – the function just returns <code>true</code>/<code>false</code></li></ul><p>By default these informations are collected by calling <a href="functions.html#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L561-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, q; error::Symbol=none, kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>The keyword argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported</p><ul><li><code>:error</code> - throws an error if <code>isapprox</code> evaluates to false, providing possibly a more detailed error. Note that this turns <code>isapprox</code> basically to an <code>@assert</code>.</li><li><code>:info</code> – prints the information in an <code>@info</code></li><li><code>:warn</code> – prints the information in an <code>@warn</code></li><li><code>:none</code> (default) – the function just returns <code>true</code>/<code>false</code></li></ul><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L525-L540">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{AbstractManifold}" href="#Base.rand-Tuple{AbstractManifold}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Random.rand(M::AbstractManifold, [d::Integer]; vector_at=nothing)
Random.rand(rng::AbstractRNG, M::AbstractManifold, [d::Integer]; vector_at=nothing)</code></pre><p>Generate a random point on manifold <code>M</code> (when <code>vector_at</code> is <code>nothing</code>) or a tangent vector at point <code>vector_at</code> (when it is not <code>nothing</code>).</p><p>Optionally a random number generator <code>rng</code> to be used can be specified. An optional integer <code>d</code> indicates that a vector of <code>d</code> points or tangent vectors is to be generated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Usually a uniform distribution should be expected for compact manifolds and a Gaussian-like distribution for non-compact manifolds and tangent vectors, although it is not guaranteed. The distribution may change between releases.</p><p><code>rand</code> methods for specific manifolds may take additional keyword arguments.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L817-L836">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractManifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. By default this is computed using <a href="functions.html#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L793-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}" href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate(a)
allocate(a, dims::Integer...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Integer...)
allocate(a, T::Type, dims::Tuple)
allocate(M::AbstractManifold, a)
allocate(M::AbstractManifold, a, dims::Integer...)
allocate(M::AbstractManifold, a, dims::Tuple)
allocate(M::AbstractManifold, a, T::Type)
allocate(M::AbstractManifold, a, T::Type, dims::Integer...)
allocate(M::AbstractManifold, a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="functions.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p><p>It&#39;s behavior can be overriden by a specific manifold, for example power manifold with nested replacing representation can decide that <code>allocate</code> for <code>Array{&lt;:SArray}</code> returns another <code>Array{&lt;:SArray}</code> instead of <code>Array{&lt;:MArray}</code>, as would be done by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L36-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::AbstractManifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q, m::AbstractInverseRetractionMethod)</code></pre><p>Approximate distance between points <code>p</code> and <code>q</code> on manifold <code>M</code> using <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L332-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[d(p,q) = \inf_{γ} L(γ),\]</p><p>where the infimum is over all piecewise smooth curves <span>$γ: [a,b] \to \mathcal M$</span> connecting <span>$γ(a)=p$</span> and <span>$γ(b)=q$</span> and</p><p class="math-container">\[L(γ) = \displaystyle\int_{a}^{b} \lVert \dotγ(t)\rVert_{γ(t)} \mathrm{d}t\]</p><p>is the length of the curve <span>$γ$</span>.</p><p>If <span>$\mathcal M$</span> is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be <span>$∞$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L311-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, Y, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space and return the result in <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.</p><p>The default is set in such a way that it assumes that the points on <code>M</code> are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding also for tangent vectors is the identity by default.</p><p>See also: <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="projections.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L411-L429">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, q, p)</code></pre><p>Embed point <code>p</code> from the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if points on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that it assumes that the points on <code>M</code> are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding in the identity by default.</p><p>If you have more than one embedding, see <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your point <code>p</code> is already represented in some embedding, see <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="projections.html#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L363-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).</p><p>Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if tangent vectors on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that memory is allocated and <code>embed!(M, Y, p. X)</code> is called.</p><p>If you have more than one embedding, see <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your tangent vector <code>X</code> is already represented in some embedding, see <a href="decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="projections.html#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L385-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p)</code></pre><p>Embed point <code>p</code> from the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed</code> includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that memory is allocated and <code>embed!(M, q, p)</code> is called.</p><p>See also: <a href="manifolds.html#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="projections.html#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L343-L356">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed_project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed_project(M::AbstractManifold, p, X)</code></pre><p>Embed vector <code>X</code> tangent at <code>p</code> from manifold <code>M</code> an project it back to tangent space at <code>p</code>. For points from that tangent space this is identity but in case embedding is defined for tagent vectors from outside of it, this can serve as a way to for example remove numerical innacuracies caused by some algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L442-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed_project</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">embed_project(M::AbstractManifold, p)</code></pre><p>Embed <code>p</code> from manifold <code>M</code> an project it back to <code>M</code>. For points from <code>M</code> this is identity but in case embedding is defined for points outside of <code>M</code>, this can serve as a way to for example remove numerical innacuracies caused by some algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L432-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractManifold)</code></pre><p>Infimum of the injectivity radii <code>injectivity_radius(M,p)</code> of all points <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p><p>In order to dispatch on different retraction methods, please either implement <code>_injectivity_radius(M[, p], m::T)</code> for your retraction <code>R</code> or specifically <code>injectivity_radius_exp(M[, p])</code> for the exponential map. By default the variant with a point <code>p</code> assumes that the default (without <code>p</code>) can ve called as a lower bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L461-L482">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L509-L514">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{AbstractManifold}" href="#ManifoldsBase.is_flat-Tuple{AbstractManifold}"><code>ManifoldsBase.is_flat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(M::AbstractManifold)</code></pre><p>Return true if the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is flat, i.e. if its Riemann curvature tensor is everywhere zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L517-L522">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_point" href="#ManifoldsBase.is_point"><code>ManifoldsBase.is_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_point(M::AbstractManifold, p, throw_error::Boolean = false; kwargs...)
is_point(M::AbstractManifold, p, report_error::Symbol; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>A more precise way can be set using a symbol as the optional parameter, where &#39; <code>:error</code> is the same as setting <code>throw_error=true</code> &#39; <code>:info</code> displays the error message as an <code>@info</code></p><ul><li><code>:warn</code> displays the error message as a <code>@warning</code></li></ul><p>all other symbols are equivalent to <code>throw_error=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L626-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_vector" href="#ManifoldsBase.is_vector"><code>ManifoldsBase.is_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_vector(M::AbstractManifold, p, X, throw_error = false, check_base_point=true; kwargs...)
is_vector(M::AbstractManifold, p, X, error::Symbol, check_base_point::Bool=true; kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="functions.html#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>If <code>check_base_point</code> is true, then the point <code>p</code> will be first checked using the <a href="functions.html#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> function.</p><p>A more precise way can be set using a symbol as the optional parameter, where &#39; <code>:error</code> is the same as setting <code>throw_error=true</code> &#39; <code>:info</code> displays the error message as an <code>@info</code></p><ul><li><code>:warn</code> displays the error message as a <code>@warn</code>ing.</li></ul><p>all other symbols are equivalent to <code>throw_error=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L675-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::AbstractManifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is homeomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L750-L755">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.mid_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point!(M::AbstractManifold, q, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="functions.html#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>. Saves the result in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L769-L775">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.mid_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mid_point(M::AbstractManifold, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="functions.html#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L758-L763">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjuntion with <a href="functions.html#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> or <a href="functions.html#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L801-L806">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{AbstractManifold}" href="#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">representation_size(M::AbstractManifold)</code></pre><p>The size of an array representing a point on <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns <code>nothing</code> by default indicating that points are not represented using an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L855-L861">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.riemann_tensor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractManifold, p, X, Y, Z)</code></pre><p>Compute the value of the Riemann tensor <span>$R(X_f,Y_f)Z_f$</span> at point <code>p</code>, where <span>$X_f$</span>, <span>$Y_f$</span> and <span>$Z_f$</span> are vector fields defined by parallel transport of, respectively, <code>X</code>, <code>Y</code> and <code>Z</code> to the desired point. All computations are performed using the connection associated to manifold <code>M</code>.</p><p>The formula reads <span>$R(X_f,Y_f)Z_f = \nabla_X\nabla_Y Z - \nabla_Y\nabla_X Z - \nabla_{[X, Y]}Z$</span>, where <span>$[X, Y]$</span> is the Lie bracket of vector fields.</p><p>Note that some authors define this quantity with inverse sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L866-L878">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.zero_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector!(M::AbstractManifold, X, p)</code></pre><p>Save to <code>X</code> the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> that represents the zero vector, i.e. such that retracting <code>X</code> to the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L891-L897">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.zero_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::AbstractManifold, p)</code></pre><p>Return the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L900-L906">source</a></section></article><h3 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h3><p>While you should always add your documentation to functions from the last section, some of the functions dispatch onto functions on <a href="design.html#design-layer3">layer III</a>. These are the ones you usually implement for your manifold – unless there is no lower level function called, like for the <a href="functions.html#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase._isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_isapprox(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>An internal function for testing whether tangent vectors <code>X</code> and <code>Y</code> from tangent space at point <code>p</code> from manifold <code>M</code> are approximately equal. Returns either <code>true</code> or <code>false</code> and does not support errors like <a href="functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>.</p><p>For more details see documentation of <a href="functions.html#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L613-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase._isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_isapprox(M::AbstractManifold, p, q; kwargs...)</code></pre><p>An internal function for testing whether points <code>p</code> and <code>q</code> from manifold <code>M</code> are approximately equal. Returns either <code>true</code> or <code>false</code> and does not support errors like <a href="functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>.</p><p>For more details see documentation of <a href="functions.html#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L601-L609">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}" href="#ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>ManifoldsBase._pick_basic_allocation_argument</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_pick_basic_allocation_argument(::AbstractManifold, f, x...)</code></pre><p>Pick which one of elements of <code>x</code> should be used as a basis for allocation in the <code>allocate_result(M::AbstractManifold, f, x...)</code> method. This can be specialized to, for example, skip <code>Identity</code> arguments in Manifolds.jl group-related functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}" href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result(M::AbstractManifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}" href="#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L114-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_approx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_approx(M::AbstractManifold, p, q; kwargs...)
check_approx(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>Check whether two elements are approximately equal, either <code>p</code>, <code>q</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> or the two tangent vectors <code>X</code>, <code>Y</code> in the tangent space at <code>p</code> are approximately the same. The keyword arguments <code>kwargs</code> can be used to set tolerances, similar to Julia&#39;s <code>isapprox</code>.</p><p>This function might use <code>isapprox</code> from Julia internally and is similar to <a href="functions.html#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>, with the difference that is returns an <a href="functions.html#ManifoldsBase.ApproximatelyError"><code>ApproximatelyError</code></a> if the two elements are not approximately equal, containting a more detailed description/reason. If the two elements are approximalely equal, this method returns <code>nothing</code>.</p><p>This method is an internal function and is called by <code>isapprox</code> whenever the user specifies an <code>error=</code> keyword therein. <a href="functions.html#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>_isapprox</code></a> is another related internal function. It is supposed to provide a fast true/false decision whether points or vectors are equal or not, while <code>check_approx</code> also provides a textual explanation. If no additional explanation is needed, a manifold may just implement a method of <a href="functions.html#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>_isapprox</code></a>, while it should also implement <code>check_approx</code> if a more detailed explanation could be helpful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L152-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractManifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="types.html#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L193-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_size(M::AbstractManifold, p)
check_size(M::AbstractManifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="functions.html#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> for a <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L217-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractManifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. An implementation does not have to validate the point <code>p</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="types.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L204-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple" href="#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>ManifoldsBase.size_to_tuple</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/ManifoldsBase.jl#L884-L888">source</a></section></article><h2 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h2><p>This interface introduces a small set of own error messages.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractManifoldDomainError" href="#ManifoldsBase.AbstractManifoldDomainError"><code>ManifoldsBase.AbstractManifoldDomainError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldDomainError &lt;: Exception</code></pre><p>An absytract Case for Errors when checking validity of points/vectors on mainfolds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ApproximatelyError" href="#ManifoldsBase.ApproximatelyError"><code>ManifoldsBase.ApproximatelyError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ApproximatelyError{V,S} &lt;: Exception</code></pre><p>Store an error that occurs when two data structures, e.g. points or tangent vectors.</p><p><strong>Fields</strong></p><ul><li><code>val</code> amount the two approximate elements are apart – is set to <code>NaN</code> if this is not known</li><li><code>msg</code> a message providing more detail about the performed test and why it failed.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ApproximatelyError(val::V, msg::S) where {V,S}</code></pre><p>Generate an Error with value <code>val</code> and message <code>msg</code>.</p><pre><code class="nohighlight hljs">ApproximatelyError(msg::S) where {S}</code></pre><p>Generate a message without a value (using <code>val=NaN</code> internally) and message <code>msg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ComponentManifoldError" href="#ManifoldsBase.ComponentManifoldError"><code>ManifoldsBase.ComponentManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompnentError{I,E} &lt;: Exception</code></pre><p>Store an error that occured in a component, where the additional <code>index</code> is stored.</p><p><strong>Fields</strong></p><ul><li><code>index::I</code> index where the error occured`</li><li><code>error::E</code> error that occured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CompositeManifoldError" href="#ManifoldsBase.CompositeManifoldError"><code>ManifoldsBase.CompositeManifoldError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CompositeManifoldError{T} &lt;: Exception</code></pre><p>A composite type to collect a set of errors that occured. Mainly used in conjunction with <a href="functions.html#ManifoldsBase.ComponentManifoldError"><code>ComponentManifoldError</code></a> to store a set of errors that occured.</p><p><strong>Fields</strong></p><ul><li><code>errors</code> a <code>Vector</code> of <code>&lt;:Exceptions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ManifoldDomainError" href="#ManifoldsBase.ManifoldDomainError"><code>ManifoldsBase.ManifoldDomainError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ManifoldDomainError{&lt;:Exception} &lt;: Exception</code></pre><p>An error to represent a nested (Domain) error on a manifold, for example if a point or tangent vector is invalid because its representation in some embedding is already invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="functions.html#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map or <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="functions.html#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>injectivity_radius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/aef5a0af3f7f615fb81d551db062a904d684629d/src/errors.jl#L118-L123">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="types.html">« An abstract manifold</a><a class="docs-footer-nextpage" href="projections.html">Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 February 2023 17:27">Tuesday 14 February 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
