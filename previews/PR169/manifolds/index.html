<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manifolds ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li><a class="tocitem" href="../design/">Design principles</a></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="../functions/">Basic functions</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li><a class="tocitem" href="../vector_transports/">Vector transports</a></li></ul></li><li class="is-active"><a class="tocitem" href>Manifolds</a><ul class="internal"><li><a class="tocitem" href="#sec-power-manifold"><span>(Abstract) power manifold</span></a></li><li><a class="tocitem" href="#VectorBundles-and-TangentSpaces"><span>VectorBundles and TangentSpaces</span></a></li><li><a class="tocitem" href="#ValidationManifold"><span><code>ValidationManifold</code></span></a></li><li><a class="tocitem" href="#DefaultManifold"><span><code>DefaultManifold</code></span></a></li><li><a class="tocitem" href="#sec-embedded-manifold"><span>Embedded manifold</span></a></li><li><a class="tocitem" href="#Metrics"><span>Metrics</span></a></li></ul></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manifolds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manifolds</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/manifolds.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Manifolds"><a class="docs-heading-anchor" href="#Manifolds">Manifolds</a><a id="Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Manifolds" title="Permalink"></a></h1><p>While the interface <code>ManifoldsBase.jl</code> does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds</p><h2 id="sec-power-manifold"><a class="docs-heading-anchor" href="#sec-power-manifold">(Abstract) power manifold</a><a id="sec-power-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#sec-power-manifold" title="Permalink"></a></h2><p>A power manifold is constructed like higher dimensional vector spaces are formed from the real line, just that for every point <span>$p = (p_1,\ldots,p_n) ‚àà \mathcal M^n$</span> on the power manifold <span>$\mathcal M^n$</span> the entries of <span>$p$</span> are points <span>$p_1,\ldots,p_n ‚àà \mathcal M$</span> on some manifold <span>$\mathcal M$</span>. Note that <span>$n$</span> can also be replaced by multiple values, such that <span>$p$</span> is not a vector but a matrix or a multi-index array of points.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerManifold" href="#ManifoldsBase.AbstractPowerManifold"><code>ManifoldsBase.AbstractPowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerManifold{ùîΩ,M,TPR} &lt;: AbstractManifold{ùîΩ}</code></pre><p>An abstract <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to represent manifolds that are build as powers of another <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with representation type <code>TPR</code>, a subtype of <a href="#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractPowerRepresentation" href="#ManifoldsBase.AbstractPowerRepresentation"><code>ManifoldsBase.AbstractPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerRepresentation</code></pre><p>An abstract representation type of points and tangent vectors on a power manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedPowerRepresentation" href="#ManifoldsBase.NestedPowerRepresentation"><code>ManifoldsBase.NestedPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is modified in-place, differently than in <a href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.NestedReplacingPowerRepresentation" href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>ManifoldsBase.NestedReplacingPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedReplacingPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for <a href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerBasisData" href="#ManifoldsBase.PowerBasisData"><code>ManifoldsBase.PowerBasisData</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerBasisData{TB&lt;:AbstractArray}</code></pre><p>Data storage for an array of basis data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PowerManifold" href="#ManifoldsBase.PowerManifold"><code>ManifoldsBase.PowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerManifold{ùîΩ,TM&lt;:AbstractManifold,TSize&lt;:Tuple,TPR&lt;:AbstractPowerRepresentation} &lt;: AbstractPowerManifold{ùîΩ,TM}</code></pre><p>The power manifold <span>$\mathcal M^{n_1√ó n_2 √ó ‚Ä¶ √ó n_d}$</span> with power geometry  <code>TSize</code> statically defines the number of elements along each axis.</p><p>For example, a manifold-valued time series would be represented by a power manifold with <span>$d$</span> equal to 1 and <span>$n_1$</span> equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (<span>$d=2$</span>) with <span>$n_1$</span> and <span>$n_2$</span> equal to width and height of the image.</p><p>While the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)
PowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)
M^(N_1, N_2, ..., N_d)</code></pre><p>Generate the power manifold <span>$M^{N_1 √ó N_2 √ó ‚Ä¶ √ó N_d}$</span>. By default, a [<code>PowerManifold</code>](@ref} is expanded further, i.e. for <code>M=PowerManifold(N,3)</code> <code>PowerManifold(M,2)</code> is equivalend to <code>PowerManifold(N,3,2)</code>. Points are then 3√ó2 matrices of points on <code>N</code>. Providing a <a href="#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a> as the second argument to the constructor can be used to nest manifold, i.e. <code>PowerManifold(M,NestedPowerRepresentation(),2)</code> represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.</p><p>Since there is no default <a href="#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a> within this interface, the <code>^</code> operator is only available for <code>PowerManifold</code>s and concatenates dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L45-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, Y, p, X)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, B, a, A)</code> for all elements <code>A</code>, <code>a</code> and <code>B</code> of <code>X</code>, <code>p</code>, and <code>Y</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L363-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, q, p)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, b, a)</code> for all elements <code>a</code> and <code>b</code> of <code>p</code> and <code>q</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the exponential map from <code>p</code> in direction <code>X</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds exponential map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L437-L442">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
p[M::AbstractPowerManifold, i...]</code></pre><p>Access the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L691-L698">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the logarithmic map from <code>p</code> to <code>q</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds logarithmic map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L851-L856">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.setindex!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
q[M::AbstractPowerManifold, i...] = p</code></pre><p>Set the element(s) at index <code>[i...]</code> of a point <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing to <code>q</code>. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1266-L1273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.view-Tuple{AbstractArray, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.view-Tuple{AbstractArray, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.view</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view(p, M::PowerManifoldNested, i::Union{Integer,Colon,AbstractVector}...)</code></pre><p>Get the view of the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1444-L1449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the norm of <code>X</code> from the tangent space of <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. from the element wise norms the Frobenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L916-L922">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}" href="#ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}"><code>ManifoldsBase._allocate_access_nested</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_access_nested(M::PowerManifoldNested, y, i)</code></pre><p>Helper function for <code>allocate_result</code> on <code>PowerManifoldNested</code>. In allocation <code>y</code> can be a number in which case <code>_access_nested</code> wouldn&#39;t work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractPowerManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. each element of <code>p</code> has to be a valid point on the base manifold. If <code>p</code> is not a point on <code>M</code> a <a href="../functions/#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L229-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_power_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_power_size(M, p)
check_power_size(M, p, X)</code></pre><p>Check whether p hase the right size to represent points on M generically, i.e. just cheking the overall sizes, not the individual ones per manifold</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L252-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractPowerManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> an the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. atfer <a href="../functions/#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a><code>(M, p)</code>, and all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="../functions/#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L318-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_inverse_retraction_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_inverse_retraction_method(M::PowerManifold)</code></pre><p>Use the default inverse retraction method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L395-L400">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_retraction_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_retraction_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_retraction_method(M::PowerManifold)</code></pre><p>Use the default retraction method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::PowerManifold)</code></pre><p>Use the default vector transport method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L408-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the distance between <code>q</code> and <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>, i.e. from the element wise distances the Forbenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L421-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}" href="#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}"><code>ManifoldsBase.get_component</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(M::AbstractPowerManifold, p, idx...)</code></pre><p>Get the component of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L482-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractPowerManifold[, p])</code></pre><p>the injectivity radius on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is for the global case equal to the one of its base manifold. For a given point <code>p</code> it&#39;s equal to the minimum of all radii in the array entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L707-L713">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractPowerManifold, p, X, Y)</code></pre><p>Compute the inner product of <code>X</code> and <code>Y</code> from the tangent space at <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. for each arrays entry the tangent vector entries from <code>X</code> and <code>Y</code> are in the tangent space of the corresponding element from <code>p</code>. The inner product is then the sum of the elementwise inner products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L734-L742">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using an <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>. Then this method is performed elementwise, so the inverse retraction method has to be one that is available on the base <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L793-L800">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}" href="#ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(M::AbstractPowerManifold)</code></pre><p>Return true if <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is flat. It is flat if and only if the wrapped manifold is flat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L757-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}" href="#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::PowerManifold)</code></pre><p>Returns the manifold-dimension of an <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> <span>$=\mathcal N = (\mathcal M)^{n_1,‚Ä¶,n_d}$</span>, i.e. with <span>$n=(n_1,‚Ä¶,n_d)$</span> the array size of the power manifold and <span>$d_{\mathcal M}$</span> the dimension of the base manifold <span>$\mathcal M$</span>, the manifold is of dimension</p><p class="math-container">\[\dim(\mathcal N) = \dim(\mathcal M)\prod_{i=1}^d n_i = n_1n_2\cdot‚Ä¶\cdot n_d \dim(\mathcal M).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L879-L890">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}" href="#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, &lt;:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}"><code>ManifoldsBase.power_dimensions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_dimensions(M::PowerManifold)</code></pre><p>return the power of <code>M</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1008-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p, X)</code></pre><p>Project the point <code>X</code> onto the tangent space at <code>p</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1040-L1045">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p)</code></pre><p>Project the point <code>p</code> from the embedding onto the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1017-L1022">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::AbstractPowerManifold, p, X, method::AbstractRetractionMethod)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using a <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>. Then this method is performed elementwise, so the retraction method has to be one that is available on the base <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1164-L1171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}"><code>ManifoldsBase.riemann_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractPowerManifold, p, X, Y, Z)</code></pre><p>Compute the Riemann tensor at point from <code>p</code> with tangent vectors <code>X</code>, <code>Y</code> and <code>Z</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1217-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}" href="#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}"><code>ManifoldsBase.set_component!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_component!(M::AbstractPowerManifold, q, p, idx...)</code></pre><p>Set the component of a point <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code> to <code>p</code>, which itself is a point on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> the power manifold is build on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1253-L1258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport the tangent vector <code>X</code>at <code>p</code> to <code>q</code> on the <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> using an <a href="../vector_transports/#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>m</code>. This method is performed elementwise, i.e. the method <code>m</code> has to be implemented on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/PowerManifold.jl#L1377-L1384">source</a></section></article><h2 id="VectorBundles-and-TangentSpaces"><a class="docs-heading-anchor" href="#VectorBundles-and-TangentSpaces">VectorBundles and TangentSpaces</a><a id="VectorBundles-and-TangentSpaces-1"></a><a class="docs-heading-anchor-permalink" href="#VectorBundles-and-TangentSpaces" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CotangentSpaceAtPoint-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.CotangentSpaceAtPoint-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.CotangentSpaceAtPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CotangentSpaceAtPoint(M::AbstractManifold, p)</code></pre><p>Return an object of type <a href="#ManifoldsBase.VectorSpaceAtPoint"><code>VectorSpaceAtPoint</code></a> representing cotangent space at <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.SasakiRetraction" href="#ManifoldsBase.SasakiRetraction"><code>ManifoldsBase.SasakiRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct SasakiRetraction &lt;: AbstractRetractionMethod end</code></pre><p>Exponential map on <a href="#ManifoldsBase.TangentBundle"><code>TangentBundle</code></a> computed via Euler integration as described in <a href="@cite">MuralidharanFlecther:2012</a>. The system of equations for <span>$\gamma : ‚Ñù \to T\mathcal M$</span> such that <span>$\gamma(1) = \exp_{p,X}(X_M, X_F)$</span> and <span>$\gamma(0)=(p, X)$</span> reads</p><p class="math-container">\[\dot{\gamma}(t) = (\dot{p}(t), \dot{X}(t)) = (R(X(t), \dot{X}(t))\dot{p}(t), 0)\]</p><p>where <span>$R$</span> is the Riemann curvature tensor (see <a href="../functions/#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}"><code>riemann_tensor</code></a>).</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">SasakiRetraction(L::Int)</code></pre><p>In this constructor <code>L</code> is the number of integration steps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L105-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TangentBundle" href="#ManifoldsBase.TangentBundle"><code>ManifoldsBase.TangentBundle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentBundle{ùîΩ,M} = VectorBundle{ùîΩ,TangentSpaceType,M} where {ùîΩ,M&lt;:AbstractManifold{ùîΩ}}</code></pre><p>Tangent bundle for manifold of type <code>M</code>, as a manifold with the Sasaki metric <a href="@cite">Sasaki:1958</a>.</p><p>Exact retraction and inverse retraction can be approximated using <a href="#ManifoldsBase.VectorBundleProductRetraction"><code>VectorBundleProductRetraction</code></a>, <a href="#ManifoldsBase.VectorBundleInverseProductRetraction"><code>VectorBundleInverseProductRetraction</code></a> and <a href="#ManifoldsBase.SasakiRetraction"><code>SasakiRetraction</code></a>. <a href="#ManifoldsBase.VectorBundleProductVectorTransport"><code>VectorBundleProductVectorTransport</code></a> can be used as a vector transport.</p><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">TangentBundle(M::AbstractManifold)
TangentBundle(M::AbstractManifold, vtm::VectorBundleProductVectorTransport)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L204-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TangentSpaceAtPoint" href="#ManifoldsBase.TangentSpaceAtPoint"><code>ManifoldsBase.TangentSpaceAtPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentSpaceAtPoint{M}</code></pre><p>Alias for <a href="#ManifoldsBase.VectorSpaceAtPoint"><code>VectorSpaceAtPoint</code></a> for the tangent space at a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TangentSpaceAtPoint-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.TangentSpaceAtPoint-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.TangentSpaceAtPoint</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TangentSpaceAtPoint(M::AbstractManifold, p)</code></pre><p>Return an object of type <a href="#ManifoldsBase.VectorSpaceAtPoint"><code>VectorSpaceAtPoint</code></a> representing tangent space at <code>p</code> on the <a href="@refe"><code>AbstractManifold</code></a>  <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L77-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TensorProductType" href="#ManifoldsBase.TensorProductType"><code>ManifoldsBase.TensorProductType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TensorProductType(spaces::VectorSpaceType...)</code></pre><p>Vector space type corresponding to the tensor product of given vector space types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L2-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundle" href="#ManifoldsBase.VectorBundle"><code>ManifoldsBase.VectorBundle</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorBundle{ùîΩ,TVS&lt;:VectorSpaceType,TM&lt;:AbstractManifold{ùîΩ}} &lt;: AbstractManifold{ùîΩ}</code></pre><p>Vector bundle on a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  <code>M</code> of type <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/bases.html#ManifoldsBase.VectorSpaceType"><code>VectorSpaceType</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorBundle(M::AbstractManifold, type::VectorSpaceType)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L170-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundleFibers" href="#ManifoldsBase.VectorBundleFibers"><code>ManifoldsBase.VectorBundleFibers</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorBundleFibers(fiber::VectorSpaceType, M::AbstractManifold)</code></pre><p>Type representing a family of vector spaces (fibers) of a vector bundle over <code>M</code> with vector spaces of type <code>fiber</code>. In contrast with <code>VectorBundle</code>, operations on <code>VectorBundleFibers</code> expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundleInverseProductRetraction" href="#ManifoldsBase.VectorBundleInverseProductRetraction"><code>ManifoldsBase.VectorBundleInverseProductRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VectorBundleInverseProductRetraction &lt;: AbstractInverseRetractionMethod end</code></pre><p>Inverse retraction of the point <code>y</code> at point <code>p</code> from vector bundle <code>B</code> over manifold <code>B.fiber</code> (denoted <span>$\mathcal M$</span>). The inverse retraction is derived as a product manifold-style approximation to the logarithmic map in the Sasaki metric. The considered product manifold is the product between the manifold <span>$\mathcal M$</span> and the topological vector space isometric to the fiber.</p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p ‚àà \mathcal M$</span> and <span>$V_p$</span> belongs to the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>. Similarly, <span>$q = (x_q, V_q)$</span>.</li></ul><p>The inverse retraction is calculated as</p><p class="math-container">\[\operatorname{retr}^{-1}_p q = (\operatorname{retr}^{-1}_{x_p}(x_q), V_{\operatorname{retr}^{-1}} - V_p)\]</p><p>where <span>$V_{\operatorname{retr}^{-1}}$</span> is the result of vector transport of <span>$V_q$</span> to the point <span>$x_p$</span>. The difference <span>$V_{\operatorname{retr}^{-1}} - V_p$</span> corresponds to the logarithmic map in the vector space <span>$F$</span>.</p><p>See also <a href="#ManifoldsBase.VectorBundleProductRetraction"><code>VectorBundleProductRetraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L239-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundleProductRetraction" href="#ManifoldsBase.VectorBundleProductRetraction"><code>ManifoldsBase.VectorBundleProductRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct VectorBundleProductRetraction &lt;: AbstractRetractionMethod end</code></pre><p>Product retraction map of tangent vector <span>$X$</span> at point <span>$p$</span> from vector bundle <code>B</code> over manifold <code>B.fiber</code> (denoted <span>$\mathcal M$</span>). The retraction is derived as a product manifold-style approximation to the exponential map in the Sasaki metric. The considered product manifold is the product between the manifold <span>$\mathcal M$</span> and the topological vector space isometric to the fiber.</p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p ‚àà \mathcal M$</span> and <span>$V_p$</span> belongs to the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li><li>The tangent vector <span>$X = (V_{X,M}, V_{X,F}) ‚àà T_pB$</span> where <span>$V_{X,M}$</span> is a tangent vector from the tangent space <span>$T_{x_p}\mathcal M$</span> and <span>$V_{X,F}$</span> is a tangent vector from the tangent space <span>$T_{V_p}F$</span> (isomorphic to <span>$F$</span>).</li></ul><p>The retraction is calculated as</p><p class="math-container">\[\operatorname{retr}_p(X) = (\exp_{x_p}(V_{X,M}), V_{\exp})\]</p><p>where <span>$V_{\exp}$</span> is the result of vector transport of <span>$V_p + V_{X,F}$</span> to the point <span>$\exp_{x_p}(V_{X,M})$</span>. The sum <span>$V_p + V_{X,F}$</span> corresponds to the exponential map in the vector space <span>$F$</span>.</p><p>See also <a href="#ManifoldsBase.VectorBundleInverseProductRetraction"><code>VectorBundleInverseProductRetraction</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L266-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundleProductVectorTransport" href="#ManifoldsBase.VectorBundleProductVectorTransport"><code>ManifoldsBase.VectorBundleProductVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorBundleProductVectorTransport{
    TMP&lt;:AbstractVectorTransportMethod,
    TMV&lt;:AbstractVectorTransportMethod,
} &lt;: AbstractVectorTransportMethod</code></pre><p>Vector transport type on <a href="#ManifoldsBase.VectorBundle"><code>VectorBundle</code></a>. <code>method_point</code> is used for vector transport of the point part and <code>method_vector</code> is used for transport of the vector part.</p><p>The vector transport is derived as a product manifold-style vector transport. The considered product manifold is the product between the manifold <span>$\mathcal M$</span> and the topological vector space isometric to the fiber.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorBundleProductVectorTransport(
    method_point::AbstractVectorTransportMethod,
    method_vector::AbstractVectorTransportMethod,
)
VectorBundleProductVectorTransport()</code></pre><p>By default both methods are set to <code>ParallelTransport</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L128-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorBundleVectorTransport" href="#ManifoldsBase.VectorBundleVectorTransport"><code>ManifoldsBase.VectorBundleVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">const VectorBundleVectorTransport = VectorBundleProductVectorTransport</code></pre><p>Deprecated: an alias for <code>VectorBundleProductVectorTransport</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorSpaceAtPoint" href="#ManifoldsBase.VectorSpaceAtPoint"><code>ManifoldsBase.VectorSpaceAtPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceAtPoint{
    ùîΩ,
    TFiber&lt;:VectorBundleFibers{&lt;:VectorSpaceType,&lt;:AbstractManifold{ùîΩ}},
    TX,
} &lt;: AbstractManifold{ùîΩ}</code></pre><p>A vector space at a point <code>p</code> on the manifold. This is modelled using <a href="#ManifoldsBase.VectorBundleFibers"><code>VectorBundleFibers</code></a> with only a vector-like part and fixing the point-like part to be just <code>p</code>.</p><p>This vector space itself is also a <code>manifold</code>. Especially, it&#39;s flat and hence isometric to the <a href="@ref"><code>Euclidean</code></a> manifold.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorSpaceAtPoint(fiber::VectorBundleFibers, p)</code></pre><p>A vector space (fiber type <code>fiber</code> of a vector bundle) at point <code>p</code> from the manifold <code>fiber.manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L40-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}" href="#Base.exp-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::TangentSpaceAtPoint, p, X)</code></pre><p>Exponential map of tangent vectors <code>X</code> and <code>p</code> from the tangent space <code>M</code>. It is calculated as their sum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L349-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Vararg{Any}}" href="#Base.log-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::TangentSpaceAtPoint, p, q)</code></pre><p>Logarithmic map on the tangent space manifold <code>M</code>, calculated as the difference of tangent vectors <code>q</code> and <code>p</code> from <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L676-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{VectorBundleFibers, Any, Any}" href="#LinearAlgebra.norm-Tuple{VectorBundleFibers, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(B::VectorBundleFibers, p, q)</code></pre><p>Norm of the vector <code>X</code> from the vector space of type <code>B.fiber</code> at point <code>p</code> from manifold <code>B.manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L695-L700">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.Weingarten-Tuple{VectorSpaceAtPoint, Any, Any, Any}" href="#ManifoldsBase.Weingarten-Tuple{VectorSpaceAtPoint, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Y = Weingarten(M::VectorSpaceAtPoint, p, X, V)
Weingarten!(M::VectorSpaceAtPoint, Y, p, X, V)</code></pre><p>Compute the Weingarten map <span>$\mathcal W_p$</span> at <code>p</code> on the <a href="#ManifoldsBase.VectorSpaceAtPoint"><code>VectorSpaceAtPoint</code></a> <code>M</code> with respect to the tangent vector <span>$X \in T_p\mathcal M$</span> and the normal vector <span>$V \in N_p\mathcal M$</span>.</p><p>Since this a flat space by itself, the result is always the zero tangent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1119-L1127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Union{Tuple{TF}, Tuple{VectorBundleFibers, TF, Vararg{Any}}} where TF" href="#ManifoldsBase.allocate_result-Union{Tuple{TF}, Tuple{VectorBundleFibers, TF, Vararg{Any}}} where TF"><code>ManifoldsBase.allocate_result</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result(B::VectorBundleFibers, f, x...)</code></pre><p>Allocates an array for the result of function <code>f</code> that is an element of the vector space of type <code>B.fiber</code> on manifold <code>B.manifold</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L947-L954">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{TF}, Tuple{VectorBundleFibers, TF, Tuple{Vararg{Any, N}}}} where {TF, N}" href="#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{TF}, Tuple{VectorBundleFibers, TF, Tuple{Vararg{Any, N}}}} where {TF, N}"><code>ManifoldsBase.allocate_result_type</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">allocate_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> for representing an operation with result in the vector space <code>fiber</code> for manifold <code>M</code> on given arguments (passed at a tuple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L972-L978">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.bundle_projection-Tuple{VectorBundle, Any}" href="#ManifoldsBase.bundle_projection-Tuple{VectorBundle, Any}"><code>ManifoldsBase.bundle_projection</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bundle_projection(B::VectorBundle, p::ArrayPartition)</code></pre><p>Projection of point <code>p</code> from the bundle <code>M</code> to the base manifold. Returns the point on the base manifold <code>B.manifold</code> at which the vector part of <code>p</code> is attached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L303-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}" href="#ManifoldsBase.distance-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::TangentSpaceAtPoint, p, q)</code></pre><p>Distance between vectors <code>p</code> and <code>q</code> from the vector space <code>M</code>. It is calculated as the norm of their difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L332-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{VectorBundleFibers, Any, Any, Any}" href="#ManifoldsBase.distance-Tuple{VectorBundleFibers, Any, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(B::VectorBundleFibers, p, X, Y)</code></pre><p>Distance between vectors <code>X</code> and <code>Y</code> from the vector space at point <code>p</code> from the manifold <code>B.manifold</code>, that is the base manifold of <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L325-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{TangentBundle{ùîΩ} where ùîΩ}" href="#ManifoldsBase.injectivity_radius-Tuple{TangentBundle{ùîΩ} where ùîΩ}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::TangentBundle)</code></pre><p>Injectivity radius of <a href="#ManifoldsBase.TangentBundle"><code>TangentBundle</code></a> manifold is infinite if the base manifold is flat and 0 otherwise. See <a href="https://mathoverflow.net/questions/94322/injectivity-radius-of-the-sasaki-metric">https://mathoverflow.net/questions/94322/injectivity-radius-of-the-sasaki-metric</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L547-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ}" href="#ManifoldsBase.injectivity_radius-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::TangentSpaceAtPoint)</code></pre><p>Return the injectivity radius on the <a href="#ManifoldsBase.TangentSpaceAtPoint"><code>TangentSpaceAtPoint</code></a> <code>M</code>, which is <span>$‚àû$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L540-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::TangentSpaceAtPoint, p, X, Y)</code></pre><p>Inner product of vectors <code>X</code> and <code>Y</code> from the tangent space at <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L608-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{VectorBundle, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{VectorBundle, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(B::VectorBundle, p, X, Y)</code></pre><p>Inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the vector bundle <code>B</code> over manifold <code>B.fiber</code> (denoted <span>$\mathcal M$</span>).</p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p ‚àà \mathcal M$</span> and <span>$V_p$</span> belongs to the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li><li>The tangent vector <span>$v = (V_{X,M}, V_{X,F}) ‚àà T_{x}B$</span> where <span>$V_{X,M}$</span> is a tangent vector from the tangent space <span>$T_{x_p}\mathcal M$</span> and <span>$V_{X,F}$</span> is a tangent vector from the tangent space <span>$T_{V_p}F$</span> (isomorphic to <span>$F$</span>). Similarly for the other tangent vector <span>$w = (V_{Y,M}, V_{Y,F}) ‚àà T_{x}B$</span>.</li></ul><p>The inner product is calculated as</p><p class="math-container">\[‚ü®X, Y‚ü©_p = ‚ü®V_{X,M}, V_{Y,M}‚ü©_{x_p} + ‚ü®V_{X,F}, V_{Y,F}‚ü©_{V_p}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L579-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{VectorBundleFibers, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{VectorBundleFibers, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(B::VectorBundleFibers, p, X, Y)</code></pre><p>Inner product of vectors <code>X</code> and <code>Y</code> from the vector space of type <code>B.fiber</code> at point <code>p</code> from manifold <code>B.manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L562-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract_product-Tuple{VectorBundle, Any, Any}" href="#ManifoldsBase.inverse_retract_product-Tuple{VectorBundle, Any, Any}"><code>ManifoldsBase.inverse_retract_product</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract_product(M::VectorBundle, p, q)</code></pre><p>Compute the allocating variant of the <a href="#ManifoldsBase.VectorBundleInverseProductRetraction"><code>VectorBundleInverseProductRetraction</code></a>, which by default allocates and calls <code>inverse_retract_product!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L625-L630">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ}" href="#ManifoldsBase.is_flat-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(::TangentSpaceAtPoint)</code></pre><p>Return true. <a href="#ManifoldsBase.TangentSpaceAtPoint"><code>TangentSpaceAtPoint</code></a> is a flat manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L663-L667">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{VectorBundle}" href="#ManifoldsBase.is_flat-Tuple{VectorBundle}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(::VectorBundle)</code></pre><p>Return true if the underlying manifold of <a href="#ManifoldsBase.VectorBundle"><code>VectorBundle</code></a> <code>M</code> is flat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L669-L673">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}" href="#ManifoldsBase.project-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::TangentSpaceAtPoint, p, X)</code></pre><p>Project the vector <code>X</code> from the tangent space <code>M</code>, that is project the vector <code>X</code> tangent at <code>M.point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L764-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any}" href="#ManifoldsBase.project-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::TangentSpaceAtPoint, p)</code></pre><p>Project the point <code>p</code> from the tangent space <code>M</code>, that is project the vector <code>p</code> tangent at <code>M.point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L726-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{VectorBundle, Any, Any}" href="#ManifoldsBase.project-Tuple{VectorBundle, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(B::VectorBundle, p, X)</code></pre><p>Project the element <code>X</code> of the ambient space of the tangent space <span>$T_p B$</span> to the tangent space <span>$T_p B$</span>.</p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p ‚àà \mathcal M$</span> and <span>$V_p$</span> belongs to the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li><li>The vector <span>$x = (V_{X,M}, V_{X,F})$</span> where <span>$x_p$</span> belongs to the ambient space of <span>$T_{x_p}\mathcal M$</span> and <span>$V_{X,F}$</span> belongs to the ambient space of the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li></ul><p>The projection is calculated by projecting <span>$V_{X,M}$</span> to tangent space <span>$T_{x_p}\mathcal M$</span> and then projecting the vector <span>$V_{X,F}$</span> to the fiber <span>$F$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L745-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{VectorBundle, Any}" href="#ManifoldsBase.project-Tuple{VectorBundle, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(B::VectorBundle, p)</code></pre><p>Project the point <code>p</code> from the ambient space of the vector bundle <code>B</code> over manifold <code>B.fiber</code> (denoted <span>$\mathcal M$</span>) to the vector bundle.</p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p$</span> belongs to the ambient space of <span>$\mathcal M$</span> and <span>$V_p$</span> belongs to the ambient space of the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li></ul><p>The projection is calculated by projecting the point <span>$x_p$</span> to the manifold <span>$\mathcal M$</span> and then projecting the vector <span>$V_p$</span> to the tangent space <span>$T_{x_p}\mathcal M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L709-L723">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project-Tuple{VectorBundleFibers, Any, Any}" href="#ManifoldsBase.project-Tuple{VectorBundleFibers, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(B::VectorBundleFibers, p, X)</code></pre><p>Project vector <code>X</code> from the vector space of type <code>B.fiber</code> at point <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L784-L788">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract_product-Tuple{VectorBundle, Any, Any, Number}" href="#ManifoldsBase.retract_product-Tuple{VectorBundle, Any, Any, Number}"><code>ManifoldsBase.retract_product</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract_product(M::VectorBundle, p, q, t::Number)</code></pre><p>Compute the allocating variant of the <a href="#ManifoldsBase.VectorBundleProductRetraction"><code>VectorBundleProductRetraction</code></a>, which by default allocates and calls <code>retract_product!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L828-L833">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract_sasaki-Tuple{AbstractManifold, Any, Any, Number, SasakiRetraction}" href="#ManifoldsBase.retract_sasaki-Tuple{AbstractManifold, Any, Any, Number, SasakiRetraction}"><code>ManifoldsBase.retract_sasaki</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract_sasaki(M::AbstractManifold, p, X, t::Number, m::SasakiRetraction)</code></pre><p>Compute the allocating variant of the <a href="#ManifoldsBase.SasakiRetraction"><code>SasakiRetraction</code></a>, which by default allocates and calls <code>retract_sasaki!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L866-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_bundle_transport-Tuple{ManifoldsBase.VectorSpaceType, AbstractManifold}" href="#ManifoldsBase.vector_bundle_transport-Tuple{ManifoldsBase.VectorSpaceType, AbstractManifold}"><code>ManifoldsBase.vector_bundle_transport</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_bundle_transport(fiber::VectorSpaceType, M::AbstractManifold)</code></pre><p>Determine the vector tranport used for <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> and <a href="../functions/#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> maps on a vector bundle with vector space type <code>fiber</code> and manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L987-L993">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{VectorBundle, Any, Any, Any, VectorBundleProductVectorTransport}" href="#ManifoldsBase.vector_transport_to-Tuple{VectorBundle, Any, Any, Any, VectorBundleProductVectorTransport}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::VectorBundle, p, X, q, m::VectorBundleProductVectorTransport)</code></pre><p>Compute the vector transport the tangent vector <code>X</code>at <code>p</code> to <code>q</code> on the <a href="#ManifoldsBase.VectorBundle"><code>VectorBundle</code></a> <code>M</code> using the <a href="#ManifoldsBase.VectorBundleProductVectorTransport"><code>VectorBundleProductVectorTransport</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1058-L1063">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector!-Tuple{VectorBundleFibers, Any, Any}" href="#ManifoldsBase.zero_vector!-Tuple{VectorBundleFibers, Any, Any}"><code>ManifoldsBase.zero_vector!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector!(B::VectorBundleFibers, X, p)</code></pre><p>Save the zero vector from the vector space of type <code>B.fiber</code> at point <code>p</code> from manifold <code>B.manifold</code> to <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1172-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Vararg{Any}}" href="#ManifoldsBase.zero_vector-Tuple{TangentSpaceAtPoint{ùîΩ} where ùîΩ, Vararg{Any}}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::TangentSpaceAtPoint, p)</code></pre><p>Zero tangent vector at point <code>p</code> from the tangent space <code>M</code>, that is the zero tangent vector at point <code>M.point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1164-L1169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{VectorBundle, Vararg{Any}}" href="#ManifoldsBase.zero_vector-Tuple{VectorBundle, Vararg{Any}}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(B::VectorBundle, p)</code></pre><p>Zero tangent vector at point <code>p</code> from the vector bundle <code>B</code> over manifold <code>B.fiber</code> (denoted <span>$\mathcal M$</span>). The zero vector belongs to the space <span>$T_{p}B$</span></p><p>Notation:</p><ul><li>The point <span>$p = (x_p, V_p)$</span> where <span>$x_p ‚àà \mathcal M$</span> and <span>$V_p$</span> belongs to the fiber <span>$F=œÄ^{-1}(\{x_p\})$</span> of the vector bundle <span>$B$</span> where <span>$œÄ$</span> is the canonical projection of that vector bundle <span>$B$</span>.</li></ul><p>The zero vector is calculated as</p><p class="math-container">\[\mathbf{0}_{p} = (\mathbf{0}_{x_p}, \mathbf{0}_F)\]</p><p>where <span>$\mathbf{0}_{x_p}$</span> is the zero tangent vector from <span>$T_{x_p}\mathcal M$</span> and <span>$\mathbf{0}_F$</span> is the zero element of the vector space <span>$F$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1144-L1161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{VectorBundleFibers, Any}" href="#ManifoldsBase.zero_vector-Tuple{VectorBundleFibers, Any}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(B::VectorBundleFibers, p)</code></pre><p>Compute the zero vector from the vector space of type <code>B.fiber</code> at point <code>p</code> from manifold <code>B.manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/VectorBundle.jl#L1133-L1138">source</a></section></article><h2 id="ValidationManifold"><a class="docs-heading-anchor" href="#ValidationManifold"><code>ValidationManifold</code></a><a id="ValidationManifold-1"></a><a class="docs-heading-anchor-permalink" href="#ValidationManifold" title="Permalink"></a></h2><p><a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> is a simple decorator using the <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> that ‚Äúdecorates‚Äù a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling <a href="../functions/#ManifoldsBase.is_point"><code>is_point</code></a> or <a href="../functions/#ManifoldsBase.is_vector"><code>is_vector</code></a> whenever applicable.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationCoTVector" href="#ManifoldsBase.ValidationCoTVector"><code>ManifoldsBase.ValidationCoTVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}</code></pre><p>Represent a cotangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationFibreVector" href="#ManifoldsBase.ValidationFibreVector"><code>ManifoldsBase.ValidationFibreVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationFibreVector{TType&lt;:VectorSpaceType} &lt;: AbstractFibreVector{TType}</code></pre><p>Represent a tangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L27-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationMPoint" href="#ManifoldsBase.ValidationMPoint"><code>ManifoldsBase.ValidationMPoint</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationMPoint &lt;: AbstractManifoldPoint</code></pre><p>Represent a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>s and <a href="#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L16-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationManifold" href="#ManifoldsBase.ValidationManifold"><code>ManifoldsBase.ValidationManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationManifold{ùîΩ,M&lt;:AbstractManifold{ùîΩ}} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A manifold to encapsulate manifolds working on array representations of <a href="../types/#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a>s and <a href="../types/#ManifoldsBase.TVector"><code>TVector</code></a>s in a transparent way, such that for these manifolds it&#39;s not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.</p><p>This manifold is a decorator for a manifold, i.e. it decorates a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with types points, vectors, and covectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ValidationTVector" href="#ManifoldsBase.ValidationTVector"><code>ManifoldsBase.ValidationTVector</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValidationTVector = ValidationFibreVector{TangentSpaceType}</code></pre><p>Represent a tangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.array_value-Tuple{AbstractArray}" href="#ManifoldsBase.array_value-Tuple{AbstractArray}"><code>ManifoldsBase.array_value</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">array_value(p)</code></pre><p>Return the internal array value of an <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="#ManifoldsBase.ValidationTVector"><code>ValidationTVector</code></a>, or <a href="#ManifoldsBase.ValidationCoTVector"><code>ValidationCoTVector</code></a> if the value <code>p</code> is encapsulated as such. Return <code>p</code> if it is already an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/ValidationManifold.jl#L67-L73">source</a></section></article><h2 id="DefaultManifold"><a class="docs-heading-anchor" href="#DefaultManifold"><code>DefaultManifold</code></a><a id="DefaultManifold-1"></a><a class="docs-heading-anchor-permalink" href="#DefaultManifold" title="Permalink"></a></h2><p><a href="#ManifoldsBase.DefaultManifold"><code>DefaultManifold</code></a> is a simplified version of <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using <code>Manifolds.jl</code> the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> is available, the <code>DefaultManifold</code> itself is not exported.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultManifold" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DefaultManifold &lt;: AbstractManifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variables.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DefaultManifold(n::Int...; field = ‚Ñù, parameter::Symbol = :field)</code></pre><p>Arguments:</p><ul><li><code>n</code>: shape of array representing points on the manifold.</li><li><code>field</code>: field over which the manifold is defined. Either <code>‚Ñù</code>, <code>‚ÑÇ</code> or <code>‚Ñç</code>.</li><li><code>parameter</code>: whether a type parameter should be used to store <code>n</code>. By default size is stored in a field. Value can either be <code>:field</code> or <code>:type</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/DefaultManifold.jl#L1-L23">source</a></section></article><h2 id="sec-embedded-manifold"><a class="docs-heading-anchor" href="#sec-embedded-manifold">Embedded manifold</a><a id="sec-embedded-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#sec-embedded-manifold" title="Permalink"></a></h2><p>The embedded manifold is a manifold <span>$\mathcal M$</span> which is modelled <em>explicitly</em> specifying its embedding <span>$\mathcal N$</span> in which the points and tangent vectors are represented. Most prominently <a href="../functions/#ManifoldsBase.is_point"><code>is_point</code></a> and <a href="../functions/#ManifoldsBase.is_vector"><code>is_vector</code></a> of an embedded manifold are implemented to check whether the point is a valid point in the embedding. This can of course still be extended by further tests. <code>ManifoldsBase.jl</code> provides two possibilities of easily introducing this in order to dispatch some functions to the embedding.</p><h3 id="subsec-implicit-embedded"><a class="docs-heading-anchor" href="#subsec-implicit-embedded">Implicit case: the <code>IsEmbeddedManifold</code> Trait</a><a id="subsec-implicit-embedded-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-implicit-embedded" title="Permalink"></a></h3><p>For the implicit case, your manifold has to be a subtype of the <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>. Adding a method to the <a href="../decorator/#ManifoldsBase.active_traits-Tuple{Any, Vararg{Any}}"><code>active_traits</code></a> function for a manifold that returns an <a href="../decorator/#ManifoldsBase.AbstractTrait"><code>AbstractTrait</code></a> <a href="../decorator/#ManifoldsBase.IsEmbeddedManifold"><code>IsEmbeddedManifold</code></a>, makes that manifold an embedded manifold. You just have to also define <a href="../decorator/#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold, Any}"><code>get_embedding</code></a> so that appropriate functions are passed on to that embedding. This is the implicit case, since the manifold type itself does not carry any information about the embedding, just the trait and the function definition do.</p><h3 id="subsec-explicit-embedded"><a class="docs-heading-anchor" href="#subsec-explicit-embedded">Explicit case: the <code>EmbeddedManifold</code></a><a id="subsec-explicit-embedded-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-explicit-embedded" title="Permalink"></a></h3><p>The <a href="#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> itself is an <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> so it is a case of the implicit embedding itself, but internally stores both the original manifold and the embedding. They are also parameters of the type. This way, an additional embedding of one manifold in another can be modelled. That is, if the manifold is implemented using the implicit embedding approach from before but can also be implemented using a <em>different</em> embedding, then this method should be chosen, since you can dispatch functions that you want to implement in this embedding then on the type which explicitly has the manifold and its embedding as parameters.</p><p>Hence this case should be used for any further embedding after the first or if the default implementation works without an embedding and the alternative needs one.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.EmbeddedManifold" href="#ManifoldsBase.EmbeddedManifold"><code>ManifoldsBase.EmbeddedManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EmbeddedManifold{ùîΩ, MT &lt;: AbstractManifold, NT &lt;: AbstractManifold} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A type to represent an explicit embedding of a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> of type <code>MT</code> embedded into a manifold <code>N</code> of type <code>NT</code>. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This type is not required if a manifold <code>M</code> is to be embedded in one specific manifold <code>N</code>.  One can then just implement <a href="../functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> and <a href="../projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a>. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>. Only for a second ‚Äìmaybe considered non-default‚Äì embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings <code>N</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>manifold</code> the manifold that is an embedded manifold</li><li><code>embedding</code> a second manifold, the first one is embedded into</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EmbeddedManifold(M, N)</code></pre><p>Generate the <code>EmbeddedManifold</code> of the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/EmbeddedManifold.jl#L1-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}" href="#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}"><code>ManifoldsBase.decorated_manifold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the manifold of <code>M</code> that is decorated with its embedding. For this specific type the internally stored enhanced manifold <code>M.manifold</code> is returned.</p><p>See also <a href="../functions/#ManifoldsBase.base_manifold"><code>base_manifold</code></a>, where this is used to (potentially) completely undecorate the manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/EmbeddedManifold.jl#L43-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}" href="#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_embedding(M::EmbeddedManifold)</code></pre><p>Return the embedding <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code> of <code>M</code>, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/EmbeddedManifold.jl#L53-L57">source</a></section></article><h2 id="Metrics"><a class="docs-heading-anchor" href="#Metrics">Metrics</a><a id="Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics" title="Permalink"></a></h2><p>Most metric-related functionality is currently defined in <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/"><code>Manifolds.jl</code></a> but a few basic types are defined here.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractMetric" href="#ManifoldsBase.AbstractMetric"><code>ManifoldsBase.AbstractMetric</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractMetric</code></pre><p>Abstract type for the pseudo-Riemannian metric tensor <span>$g$</span>, a family of smoothly varying inner products on the tangent space. See <a href="../functions/#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p><p><strong>Functor</strong></p><pre><code class="nohighlight hljs">(metric::Metric)(M::AbstractManifold)
(metric::Metric)(M::MetricManifold)</code></pre><p>Generate the <code>MetricManifold</code> that wraps the manifold <code>M</code> with given <code>metric</code>. This works for both a variable containing the metric as well as a subtype <code>T&lt;:AbstractMetric</code>, where a zero parameter constructor <code>T()</code> is availabe. If <code>M</code> is already a metric manifold, the inner manifold with the new <code>metric</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.EuclideanMetric" href="#ManifoldsBase.EuclideanMetric"><code>ManifoldsBase.EuclideanMetric</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EuclideanMetric &lt;: RiemannianMetric</code></pre><p>A general type for any manifold that employs the Euclidean Metric, for example the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> manifold itself, or the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/sphere.html"><code>Sphere</code></a>, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).</p><p>Since the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the <code>EuclideanMetric</code> but where the field type of the manifold is <code>‚ÑÇ</code>.</p><p>This metric is the default metric for example for the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.RiemannianMetric" href="#ManifoldsBase.RiemannianMetric"><code>ManifoldsBase.RiemannianMetric</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RiemannianMetric &lt;: AbstractMetric</code></pre><p>Abstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for <span>$X  ‚àà T_p \mathcal M$</span>, the inner product <span>$g(X, X) &gt; 0$</span> whenever <span>$X$</span> is not the zero vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L19-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_metric!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)</code></pre><p>Compute the <a href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>change_metric</code></a> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_metric(M::AbstractcManifold, G2::AbstractMetric, p, X)</code></pre><p>On the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with implicitly given metric <span>$g_1$</span> and a second <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <span>$g_2$</span> this function performs a change of metric in the sense that it returns the tangent vector <span>$Z=BX$</span> such that the linear map <span>$B$</span> fulfills</p><p class="math-container">\[g_2(Y_1,Y_2) = g_1(BY_1,BY_2) \quad \text{for all } Y_1, Y_2 ‚àà T_p\mathcal M.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L44-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_representer!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)</code></pre><p>Compute the <a href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>change_metric</code></a> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.change_representer-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_representer-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_representer(M::AbstractManifold, G2::AbstractMetric, p, X)</code></pre><p>Convert the representer <code>X</code> of a linear function (in other words a cotangent vector at <code>p</code>) in the tangent space at <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> given with respect to the <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>G2</code> into the representer with respect to the (implicit) metric of <code>M</code>.</p><p>In order to convert <code>X</code> into the representer with respect to the (implicitly given) metric <span>$g_1$</span> of <code>M</code>, we have to find the conversion function <span>$c: T_p\mathcal M \to T_p\mathcal M$</span> such that</p><p class="math-container">\[    g_2(X,Y) = g_1(c(X),Y)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/360c871007e4fcadd81a6e7d7117727794764bc2/src/metric.jl#L68-L81">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vector_transports/">¬´ Vector transports</a><a class="docs-footer-nextpage" href="../decorator/">Decorating/Extending a Manifold ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 30 September 2023 11:09">Saturday 30 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
