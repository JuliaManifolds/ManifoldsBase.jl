<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic functions · ManifoldsBase.jl</title><meta name="title" content="Basic functions · ManifoldsBase.jl"/><meta property="og:title" content="Basic functions · ManifoldsBase.jl"/><meta property="twitter:title" content="Basic functions · ManifoldsBase.jl"/><meta name="description" content="Documentation for ManifoldsBase.jl."/><meta property="og:description" content="Documentation for ManifoldsBase.jl."/><meta property="twitter:description" content="Documentation for ManifoldsBase.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li><a class="tocitem" href="../design/">Design principles</a></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li class="is-active"><a class="tocitem" href>Basic functions</a><ul class="internal"><li><a class="tocitem" href="#exp-and-log"><span>The exponential map, the logarithmic map, and geodesics</span></a></li><li><a class="tocitem" href="#subsec-parallel-transport"><span>Parallel transport</span></a></li><li><a class="tocitem" href="#Further-functions-on-manifolds"><span>Further functions on manifolds</span></a></li><li><a class="tocitem" href="#Approximation-Methods"><span>Approximation Methods</span></a></li><li><a class="tocitem" href="#Error-Messages"><span>Error Messages</span></a></li></ul></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li><a class="tocitem" href="../vector_transports/">Vector transports</a></li></ul></li><li><a class="tocitem" href="../manifolds/">Manifolds</a></li><li><a class="tocitem" href="../metamanifolds/">Meta-Manifolds</a></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li><li><a class="tocitem" href="../numerical_verification/">Numerical Verification</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions on maniolds</a></li><li class="is-active"><a href>Basic functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/functions.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions-on-manifolds"><a class="docs-heading-anchor" href="#Functions-on-manifolds">Functions on manifolds</a><a id="Functions-on-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-manifolds" title="Permalink"></a></h1><p>This page collects several basic functions on manifolds.</p><h2 id="exp-and-log"><a class="docs-heading-anchor" href="#exp-and-log">The exponential map, the logarithmic map, and geodesics</a><a id="exp-and-log-1"></a><a class="docs-heading-anchor-permalink" href="#exp-and-log" title="Permalink"></a></h2><p>Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector “points towards” the other point.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractManifold, Any, Any}" href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractManifold, p, X)</code></pre><p>Compute the exponential map of tangent vector <code>X</code> at point <code>p</code> from the manifold <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[\exp_p X = γ_{p,X}(1),\]</p><p>where <span>$γ_{p,X}$</span> is the unique geodesic starting in <span>$γ(0)=p$</span> such that <span>$\dot γ(0) = X$</span>.</p><p>See also <a href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>shortest_geodesic</code></a>, <a href="../metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{AbstractManifold, Any, Any}" href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractManifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The logarithmic map is the inverse of the <a href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>See also <a href="../metamanifolds/#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L157-L165">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp!(M::AbstractManifold, q, p, X)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from the manifold <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p><p>If you want to implement exponential map for your manifold, you should implement the in-place method with, that is <code>exp_fused!(M::MyManifold, q, p, X)</code>.</p><p>See also <a href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L34-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.exp_fused!-Tuple{AbstractManifold, Any, Any, Any, Number}" href="#ManifoldsBase.exp_fused!-Tuple{AbstractManifold, Any, Any, Any, Number}"><code>ManifoldsBase.exp_fused!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp_fused!(M::AbstractManifold, q, p, X, t::Number)</code></pre><p>Compute the exponential map of tangent vector <code>X</code> scaled by <code>t</code> at point <code>p</code> in-place of <code>q</code>. Compared to <a href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>, this method provides the opportunity to avoid the allocation when computing <code>t*X</code>. By default, this method performs this operation and passes to <a href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.exp_fused-Tuple{AbstractManifold, Any, Any, Number}" href="#ManifoldsBase.exp_fused-Tuple{AbstractManifold, Any, Any, Number}"><code>ManifoldsBase.exp_fused</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp_fused(M::AbstractManifold, p, X, t::Number = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code> scaled by <code>t</code> at point <code>p</code>. Compared to <a href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>, this method provides the opportunity to avoid the allocation when computing <code>t*X</code>. By default, this method allocates the resulting point <code>q</code> and passes to <a href="#ManifoldsBase.exp_fused!-Tuple{AbstractManifold, Any, Any, Any, Number}"><code>exp_fused!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, Q, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at time points <code>t</code> fom <code>T</code> in place of <code>Q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L136-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, q, p, X, t::Real)</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at <code>t</code> in place of <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L121-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic!(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields that the curve has constant velocity and is locally distance-minimizing.</p><p>This function returns a function <code>(q,t)</code> of (time) <code>t</code> that mutates <code>q</code>`.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L104-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate the geodesic <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>at time points <code>t</code> from <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L90-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X, t::Real)</code></pre><p>Evaluate the geodesic <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">geodesic(M::AbstractManifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. A geodesic is a curve of zero acceleration. That is for the curve <span>$γ_{p,X}: I → \mathcal M$</span>, with <span>$γ_{p,X}(0) = p$</span> and <span>$\dot γ_{p,X}(0) = X$</span> a geodesic further fulfills</p><p class="math-container">\[∇_{\dot γ_{p,X}(t)} \dot γ_{p,X}(t) = 0,\]</p><p>i.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.</p><p>This function returns a function of (time) <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L58-L73">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">log!(M::AbstractManifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. The result is saved to <code>X</code>. The logarithmic map is the inverse of the <a href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>onential map. Note that the logarithmic map might not be globally defined.</p><p>see also <a href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a> and <a href="../retractions/#ManifoldsBase.inverse_retract!"><code>inverse_retract!</code></a>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at all <code>t</code> from <code>T</code> in place of <code>R</code>. When there are multiple shortest geodesics, a deterministic choice will be taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L242-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)</code></pre><p>Evaluate a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at <code>t</code> in place of <code>r</code>. When there are multiple shortest geodesics, a deterministic choice will be taken.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L232-L238">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic!(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function <code>(r,t) -&gt; ...</code> of time <code>t</code> which works in place of <code>r</code>.</p><p>Further variants</p><pre><code class="nohighlight hljs">shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)
shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>mutate (and return) the point <code>r</code> and the vector of points <code>R</code>, respectively, returning the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L214-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Evaluate a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at time points <code>T</code>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L202-L208">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AabstractManifold, p, q, t::Real)</code></pre><p>Evaluate a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span> at time <code>t</code>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L194-L200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">shortest_geodesic(M::AbstractManifold, p, q) -&gt; Function</code></pre><p>Get a <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$γ_{p,q}(0)=p$</span> and <span>$γ_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, a deterministic choice will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/exp_log_geo.jl#L184-L192">source</a></section></article><h2 id="subsec-parallel-transport"><a class="docs-heading-anchor" href="#subsec-parallel-transport">Parallel transport</a><a id="subsec-parallel-transport-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-parallel-transport" title="Permalink"></a></h2><p>While moving vectors from one base point to another is the identity in the Euclidean space – or in other words all tangent spaces (directions one can “walk” into) are the same. This is different on a manifold.</p><p>If we have two points <span>$p,q ∈ \mathcal M$</span>, we take a <span>$c: [0,1] → \mathcal M$</span> connecting the two points, i.e. <span>$c(0) = p$</span> and <span>$c(1) = q$</span>. this could be a (or the) geodesic. If we further consider a vector field <span>$X: [0,1] → T\mathcal M$</span>, i.e. where <span>$X(t) ∈ T_{c(t)}\mathcal M$</span>. Then the vector field is called <em>parallel</em> if its covariant derivative <span>$\frac{\mathrm{D}}{\mathrm{d}t}X(t) = 0$</span> for all <span>$t∈ |0,1]$</span>.</p><p>If we now impose a value for <span>$X=X(0) ∈ T_p\mathcal M$</span>, we obtain an ODE with an initial condition. The resulting value <span>$X(1) ∈ T_q\mathcal M$</span> is called the <em>parallel transport</em> of <code>X</code> along <span>$c$</span> or in case of a geodesic the _parallel transport of <code>X</code> from <code>p</code> to <code>q</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.parallel_transport_direction</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallel_transport_direction(M::AbstractManifold, p, X, d)</code></pre><p>Compute the parallel transport of <span>$X$</span> along the curve <span>$c(t) = γ_{p,X}(t)$</span> to <span>$c(1)=q$</span>, where <span>$c(t)=γ_{p,X}(t)$</span> is the the unique geodesic starting from <span>$γ_{p,d}(0)=p$</span> into direction <span>$̇\dot γ_{p,d}(0)=d$</span>.</p><p>By default this function calls <a href="#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_to</code></a><code>(M, p, X, q)</code>, where <span>$q=\exp_pX$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/parallel_transport.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.parallel_transport_to</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parallel_transport_to(M::AbstractManifold, p, X, q)</code></pre><p>Compute the parallel transport of <span>$X$</span> along the curve <span>$c(t) = γ_{p,q}(t)$</span>, i.e. the (assumed to be unique) <a href="#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>geodesic</code></a> <span>$γ_{p,q}$</span> connecting <code>p</code> and <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/parallel_transport.jl#L21-L26">source</a></section></article><h2 id="Further-functions-on-manifolds"><a class="docs-heading-anchor" href="#Further-functions-on-manifolds">Further functions on manifolds</a><a id="Further-functions-on-manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Further-functions-on-manifolds" title="Permalink"></a></h2><h3 id="General-functions-provided-by-the-interface"><a class="docs-heading-anchor" href="#General-functions-provided-by-the-interface">General functions provided by the interface</a><a id="General-functions-provided-by-the-interface-1"></a><a class="docs-heading-anchor-permalink" href="#General-functions-provided-by-the-interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.angle-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.angle-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">angle(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with respect to the inner product from <a href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L215-L220">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any, Any}" href="#Base.copy-Tuple{AbstractManifold, Any, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(M::AbstractManifold, p, X)</code></pre><p>Copy the value(s) from the tangent vector <code>X</code> at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new tangent vector. See <a href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L395-L401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy-Tuple{AbstractManifold, Any}" href="#Base.copy-Tuple{AbstractManifold, Any}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(M::AbstractManifold, p)</code></pre><p>Copy the value(s) from the point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into a new point. See <a href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a> for the allocation of new point memory and <a href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>copyto!</code></a> for the copying.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L380-L385">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, Y, p, X)</code></pre><p>Copy the value(s) from <code>X</code> to <code>Y</code>, where both are tangent vectors from the tangent space at <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(Y, X)</code>, but it might be useful to overwrite the function at the level, where also information from <code>p</code> and <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L422-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractManifold, Any, Any}" href="#Base.copyto!-Tuple{AbstractManifold, Any, Any}"><code>Base.copyto!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copyto!(M::AbstractManifold, q, p)</code></pre><p>Copy the value(s) from <code>p</code> to <code>q</code>, where both are points on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. This function defaults to calling <code>copyto!(q, p)</code>, but it might be useful to overwrite the function at the level, where also information from <code>M</code> can be accessed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L413-L419">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, X, Y; error:Symbol=:none; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>The optional positional argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported</p><ul><li><code>:error</code> - throws an error if <code>isapprox</code> evaluates to false, providing possibly a more detailed error. Note that this turns <code>isapprox</code> basically to an <code>@assert</code>.</li><li><code>:info</code> – prints the information in an <code>@info</code></li><li><code>:warn</code> – prints the information in an <code>@warn</code></li><li><code>:none</code> (default) – the function just returns <code>true</code>/<code>false</code></li></ul><p>By default these informations are collected by calling <a href="#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L703-L722">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.isapprox-Tuple{AbstractManifold, Any, Any}" href="#Base.isapprox-Tuple{AbstractManifold, Any, Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isapprox(M::AbstractManifold, p, q; error::Symbol=:none, kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> are approximately equal.</p><p>The keyword argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported</p><ul><li><code>:error</code> - throws an error if <code>isapprox</code> evaluates to false, providing possibly a more detailed error. Note that this turns <code>isapprox</code> basically to an <code>@assert</code>.</li><li><code>:info</code> – prints the information in an <code>@info</code></li><li><code>:warn</code> – prints the information in an <code>@warn</code></li><li><code>:none</code> (default) – the function just returns <code>true</code>/<code>false</code></li></ul><p>Keyword arguments can be used to specify tolerances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L667-L683">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{AbstractManifold}" href="#Base.rand-Tuple{AbstractManifold}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Random.rand(M::AbstractManifold, [d::Integer]; vector_at=nothing)
Random.rand(rng::AbstractRNG, M::AbstractManifold, [d::Integer]; vector_at=nothing)</code></pre><p>Generate a random point on manifold <code>M</code> (when <code>vector_at</code> is <code>nothing</code>) or a tangent vector at point <code>vector_at</code> (when it is not <code>nothing</code>).</p><p>Optionally a random number generator <code>rng</code> to be used can be specified. An optional integer <code>d</code> indicates that a vector of <code>d</code> points or tangent vectors is to be generated.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Usually a uniform distribution should be expected for compact manifolds and a Gaussian-like distribution for non-compact manifolds and tangent vectors, although it is not guaranteed. The distribution may change between releases.</p><p><code>rand</code> methods for specific manifolds may take additional keyword arguments.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L970-L989">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractManifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. By default this is computed using <a href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L940-L945">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Weingarten!-Tuple{AbstractManifold, Vararg{Any, 4}}" href="#ManifoldsBase.Weingarten!-Tuple{AbstractManifold, Vararg{Any, 4}}"><code>ManifoldsBase.Weingarten!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Weingarten!(M, Y, p, X, V)</code></pre><p>Compute the Weingarten map <span>$\mathcal W_p\colon T_p\mathcal M × N_p\mathcal M \to T_p\mathcal M$</span> in place of <code>Y</code>, see <a href="#ManifoldsBase.Weingarten-Tuple{AbstractManifold, Any, Any, Any}"><code>Weingarten</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1099-L1104">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Weingarten-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.Weingarten-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Weingarten(M, p, X, V)</code></pre><p>Compute the Weingarten map <span>$\mathcal W_p\colon T_p\mathcal M × N_p\mathcal M \to T_p\mathcal M$</span>, where <span>$N_p\mathcal M$</span> is the orthogonal complement of the tangent space <span>$T_p\mathcal M$</span> of the embedded submanifold <span>$\mathcal M$</span>, where we denote the embedding by <span>$\mathcal E$</span>.</p><p>The Weingarten map can be defined by restricting the differential of the orthogonal <a href="../metamanifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>project</code></a>ion <span>$\operatorname{proj}_{T_p\mathcal M}\colon T_p \mathcal E \to T_p\mathcal M$</span> with respect to the base point <span>$p$</span>, i.e. defining</p><p class="math-container">\[\mathcal P_X := D_p\operatorname{proj}_{T_p\mathcal M}(Y)[X],
\qquad Y \in T_p \mathcal E, X \in T_p\mathcal M,\]</p><p>the Weingarten map can be written as <span>$\mathcal W_p(X,V) = \mathcal P_X(V)$</span>.</p><p>The Weingarten map is named after <a href="https://en.wikipedia.org/wiki/Julius_Weingarten">Julius Weingarten</a> (1836–1910).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1107-L1124">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}" href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate(a)
allocate(a, dims::Integer...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Integer...)
allocate(a, T::Type, dims::Tuple)
allocate(M::AbstractManifold, a)
allocate(M::AbstractManifold, a, dims::Integer...)
allocate(M::AbstractManifold, a, dims::Tuple)
allocate(M::AbstractManifold, a, T::Type)
allocate(M::AbstractManifold, a, T::Type, dims::Integer...)
allocate(M::AbstractManifold, a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p><p>It&#39;s behavior can be overridden by a specific manifold, for example power manifold with nested replacing representation can decide that <code>allocate</code> for <code>Array{&lt;:SArray}</code> returns another <code>Array{&lt;:SArray}</code> instead of <code>Array{&lt;:MArray}</code>, as would be done by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L50-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.allocate_on-Tuple{AbstractManifold}" href="#ManifoldsBase.allocate_on-Tuple{AbstractManifold}"><code>ManifoldsBase.allocate_on</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_on(M::AbstractManifold, [T:::Type])
allocate_on(M::AbstractManifold, F::FiberType, [T:::Type])</code></pre><p>Allocate a new point on manifold <code>M</code> with optional type given by <code>T</code>. Note that <code>T</code> is not number element type as in <a href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> but rather the type of the entire point to be returned.</p><p>If <code>F</code> is provided, then an element of the corresponding fiber is allocated, assuming it is independent of the base point.</p><p>To allocate a tangent vector, use ``</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using ManifoldsBase

julia&gt; M = ManifoldsBase.DefaultManifold(4)
DefaultManifold(4; field = ℝ)

julia&gt; allocate_on(M)
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0

julia&gt; allocate_on(M, Array{Float64})
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0

julia&gt; allocate_on(M, TangentSpaceType())
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0

julia&gt; allocate_on(M, TangentSpaceType(), Array{Float64})
4-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L99-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">base_manifold(M::AbstractManifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L243-L250">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_type-Tuple{AbstractManifold, ManifoldsBase.FiberType}" href="#ManifoldsBase.default_type-Tuple{AbstractManifold, ManifoldsBase.FiberType}"><code>ManifoldsBase.default_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_type(M::AbstractManifold, ft::FiberType)</code></pre><p>Get the default type of points from the fiber <code>ft</code> of the fiber bundle based on manifold <code>M</code>. For example, call <code>default_type(MyManifold(), TangentSpaceType())</code> to get the default type of a tangent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L438-L444">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_type-Tuple{AbstractManifold}" href="#ManifoldsBase.default_type-Tuple{AbstractManifold}"><code>ManifoldsBase.default_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_type(M::AbstractManifold)</code></pre><p>Get the default type of points on manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L432-L436">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q, m::AbstractInverseRetractionMethod)</code></pre><p>Approximate distance between points <code>p</code> and <code>q</code> on manifold <code>M</code> using <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L468-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractManifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, i.e.</p><p class="math-container">\[d(p,q) = \inf_{γ} L(γ),\]</p><p>where the infimum is over all piecewise smooth curves <span>$γ: [a,b] \to \mathcal M$</span> connecting <span>$γ(a)=p$</span> and <span>$γ(b)=q$</span> and</p><p class="math-container">\[L(γ) = \displaystyle\int_{a}^{b} \lVert \dotγ(t)\rVert_{γ(t)} \mathrm{d}t\]</p><p>is the length of the curve <span>$γ$</span>.</p><p>If <span>$\mathcal M$</span> is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be <span>$∞$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L447-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, Y, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space and return the result in <code>Y</code>. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed!</code> includes changing data representation, if applicable, i.e. if the tangents on <code>M</code> are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.</p><p>The default is set in such a way that it assumes that the points on <code>M</code> are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding also for tangent vectors is the identity by default.</p><p>See also: <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="../projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L547-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed!(M::AbstractManifold, q, p)</code></pre><p>Embed point <code>p</code> from the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if points on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that it assumes that the points on <code>M</code> are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding in the identity by default.</p><p>If you have more than one embedding, see <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your point <code>p</code> is already represented in some embedding, see <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="../projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}"><code>project!</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L499-L518">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p, X)</code></pre><p>Embed a tangent vector <code>X</code> at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).</p><p>Additionally, <code>embed</code> might include changing data representation, if applicable, i.e. if tangent vectors on <code>M</code> are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that memory is allocated and <code>embed!(M, Y, p. X)</code> is called.</p><p>If you have more than one embedding, see <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> for defining a second embedding. If your tangent vector <code>X</code> is already represented in some embedding, see <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> how you can avoid reimplementing code from the embedded manifold</p><p>See also: <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="../projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L521-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed(M::AbstractManifold, p)</code></pre><p>Embed point <code>p</code> from the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, <code>embed</code> includes changing data representation, if applicable, i.e. if the points on <code>M</code> are not represented in the same way as points on the embedding, the representation is changed accordingly.</p><p>The default is set in such a way that memory is allocated and <code>embed!(M, q, p)</code> is called.</p><p>See also: <a href="../manifolds/#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>, <a href="../projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any}"><code>project</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L479-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.embed_project</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed_project(M::AbstractManifold, p, X)</code></pre><p>Embed vector <code>X</code> tangent at <code>p</code> from manifold <code>M</code> an project it back to tangent space at <code>p</code>. For points from that tangent space this is identity but in case embedding is defined for tangent vectors from outside of it, this can serve as a way to for example remove numerical inaccuracies caused by some algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L578-L585">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.embed_project</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">embed_project(M::AbstractManifold, p)</code></pre><p>Embed <code>p</code> from manifold <code>M</code> an project it back to <code>M</code>. For points from <code>M</code> this is identity but in case embedding is defined for points outside of <code>M</code>, this can serve as a way to for example remove numerical inaccuracies caused by some algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L568-L574">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.has_components-Tuple{AbstractManifold}" href="#ManifoldsBase.has_components-Tuple{AbstractManifold}"><code>ManifoldsBase.has_components</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_components(M::AbstractManifold)</code></pre><p>Return whether the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>(M)</code> consists of components, like the <a href="../metamanifolds/#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> or the <a href="../metamanifolds/#ProductManifold"><code>ProductManifold</code></a>, that one can iterate over. By default, this function returns <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L597-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractManifold)</code></pre><p>Infimum of the injectivity radii <code>injectivity_radius(M,p)</code> of all points <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="nohighlight hljs">injectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="../metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p><p>In order to dispatch on different retraction methods, please either implement <code>_injectivity_radius(M[, p], m::T)</code> for your retraction <code>R</code> or specifically <code>injectivity_radius_exp(M[, p])</code> for the exponential map. By default the variant with a point <code>p</code> assumes that the default (without <code>p</code>) can ve called as a lower bound.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L606-L627">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L651-L656">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{AbstractManifold}" href="#ManifoldsBase.is_flat-Tuple{AbstractManifold}"><code>ManifoldsBase.is_flat</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_flat(M::AbstractManifold)</code></pre><p>Return true if the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is flat, i.e. if its Riemann curvature tensor is everywhere zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L659-L664">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}" href="#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>ManifoldsBase.is_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_point(M::AbstractManifold, p; error::Symbol = :none, kwargs...)
is_point(M::AbstractManifold, p, throw_error::Bool; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. By default the function calls <a href="#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a>, which returns an <code>ErrorException</code> or <code>nothing</code>.</p><p>How to report a potential error can be set using the <code>error=</code> keyword</p><ul><li><code>:error</code>          - throws an error if <code>p</code> is not a point</li><li><code>:info</code>           - displays the error message as an <code>@info</code></li><li><code>:warn</code>           - displays the error message as a <code>@warning</code></li><li><code>:none</code> (default) – the function just returns <code>true</code>/<code>false</code></li></ul><p>all other symbols are equivalent to <code>error=:none</code>.</p><p>The second signature is a shorthand, where the boolean is used for <code>error=:error</code> (<code>true</code>) and <code>error=:none</code> (default, <code>false</code>). This case ignores the <code>error=</code> keyword</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L767-L785">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}" href="#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>ManifoldsBase.is_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">is_vector(M::AbstractManifold, p, X, check_base_point::Bool=true; error::Symbol=:none, kwargs...)
is_vector(M::AbstractManifold, p, X, check_base_point::Bool=true, throw_error::Boolean; kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>check_base_point</code> is set to true, this function also (first) calls <a href="#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a> on <code>p</code>. Then, the function calls <a href="#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p><p>How to report a potential error can be set using the <code>error=</code> keyword</p><ul><li><code>:error</code>          - throws an error if <code>X</code> is not a tangent vector and/or <code>p</code> is not point</li></ul><p>^ <code>:info</code>           - displays the error message as an <code>@info</code></p><ul><li><code>:warn</code>           - displays the error message as a <code>@warn</code>ing.</li><li><code>:none</code>           - (default) the function just returns <code>true</code>/<code>false</code></li></ul><p>all other symbols are equivalent to <code>error=:none</code></p><p>The second signature is a shorthand, where <code>throw_error</code> is used for <code>error=:error</code> (<code>true</code>) and <code>error=:none</code> (default, <code>false</code>). This case ignores the <code>error=</code> keyword.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L826-L849">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::AbstractManifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> is homeomorphic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L909-L914">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.mid_point!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mid_point!(M::AbstractManifold, q, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a>. Saves the result in <code>q</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L928-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.mid_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mid_point(M::AbstractManifold, p1, p2)</code></pre><p>Calculate the middle between the two point <code>p1</code> and <code>p2</code> from manifold <code>M</code>. By default uses <a href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>, divides the vector by 2 and uses <a href="#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L917-L922">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjunction with <a href="#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}"><code>allocate</code></a> or <a href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>allocate_result</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L948-L953">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{AbstractManifold}" href="#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">representation_size(M::AbstractManifold)</code></pre><p>The size of an array representing a point on <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Returns <code>nothing</code> by default indicating that points are not represented using an <code>AbstractArray</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1017-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}"><code>ManifoldsBase.riemann_tensor</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractManifold, p, X, Y, Z)</code></pre><p>Compute the value of the Riemann tensor <span>$R(X_f,Y_f)Z_f$</span> at point <code>p</code>, where <span>$X_f$</span>, <span>$Y_f$</span> and <span>$Z_f$</span> are vector fields defined by parallel transport of, respectively, <code>X</code>, <code>Y</code> and <code>Z</code> to the desired point. All computations are performed using the connection associated to manifold <code>M</code>.</p><p>The formula reads <span>$R(X_f,Y_f)Z_f = \nabla_X\nabla_Y Z - \nabla_Y\nabla_X Z - \nabla_{[X, Y]}Z$</span>, where <span>$[X, Y]$</span> is the Lie bracket of vector fields.</p><p>Note that some authors define this quantity with inverse sign.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1028-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.sectional_curvature-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.sectional_curvature</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sectional_curvature(M::AbstractManifold, p, X, Y)</code></pre><p>Compute the sectional curvature of a manifold <span>$\mathcal M$</span> at a point <span>$p \in \mathcal M$</span> on two linearly independent tangent vectors at <span>$p$</span>. The formula reads</p><p class="math-container">\[
    \kappa_p(X, Y) = \frac{⟨R(X, Y, Y), X⟩_p}{\lVert X \rVert^2_p \lVert Y \rVert^2_p - ⟨X, Y⟩^2_p}
\]</p><p>where <span>$R(X, Y, Y)$</span> is the <a href="#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}"><code>riemann_tensor</code></a> on <span>$\mathcal M$</span>.</p><p><strong>Input</strong></p><ul><li><code>M</code>:   a manifold <span>$\mathcal M$</span></li><li><code>p</code>:   a point <span>$p \in \mathcal M$</span></li><li><code>X</code>:   a tangent vector <span>$X \in T_p \mathcal M$</span></li><li><code>Y</code>:   a tangent vector <span>$Y \in T_p \mathcal M$</span></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1046-L1066">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_max-Tuple{AbstractManifold}" href="#ManifoldsBase.sectional_curvature_max-Tuple{AbstractManifold}"><code>ManifoldsBase.sectional_curvature_max</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_max(M::AbstractManifold)</code></pre><p>Upper bound on sectional curvature of manifold <code>M</code>. The formula reads</p><p class="math-container">\[\omega = \operatorname{sup}_{p\in\mathcal M, X\in T_p\mathcal M, Y\in T_p\mathcal M, ⟨X, Y⟩ ≠ 0} \kappa_p(X, Y)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1072-L1079">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_min-Tuple{AbstractManifold}" href="#ManifoldsBase.sectional_curvature_min-Tuple{AbstractManifold}"><code>ManifoldsBase.sectional_curvature_min</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_min(M::AbstractManifold)</code></pre><p>Lower bound on sectional curvature of manifold <code>M</code>. The formula reads</p><p class="math-container">\[\omega = \operatorname{inf}_{p\in\mathcal M, X\in T_p\mathcal M, Y\in T_p\mathcal M, ⟨X, Y⟩ ≠ 0} \kappa_p(X, Y)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1082-L1089">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.zero_vector!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_vector!(M::AbstractManifold, X, p)</code></pre><p>Save to <code>X</code> the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> that represents the zero vector, i.e. such that retracting <code>X</code> to the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1132-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.zero_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_vector(M::AbstractManifold, p)</code></pre><p>Return the tangent vector from the tangent space <span>$T_p\mathcal M$</span> at <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1141-L1147">source</a></section></article><h3 id="Internal-functions"><a class="docs-heading-anchor" href="#Internal-functions">Internal functions</a><a id="Internal-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-functions" title="Permalink"></a></h3><p>While you should always add your documentation to functions from the last section, some of the functions dispatch onto functions on <a href="../design/#design-layer3">layer III</a>. These are the ones you usually implement for your manifold – unless there is no lower level function called, like for the <a href="#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type, AbstractManifold, Any, Any}" href="#Base.convert-Tuple{Type, AbstractManifold, Any, Any}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(T::Type, M::AbstractManifold, p, X)</code></pre><p>Convert vector <code>X</code> tangent at point <code>p</code> from manifold <code>M</code> to type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L373-L377">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.convert-Tuple{Type, AbstractManifold, Any}" href="#Base.convert-Tuple{Type, AbstractManifold, Any}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">convert(T::Type, M::AbstractManifold, p)</code></pre><p>Convert point <code>p</code> from manifold <code>M</code> to type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase._isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_isapprox(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>An internal function for testing whether tangent vectors <code>X</code> and <code>Y</code> from tangent space at point <code>p</code> from manifold <code>M</code> are approximately equal. Returns either <code>true</code> or <code>false</code> and does not support errors like <a href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>.</p><p>For more details see documentation of <a href="#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L754-L762">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase._isapprox</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_isapprox(M::AbstractManifold, p, q; kwargs...)</code></pre><p>An internal function for testing whether points <code>p</code> and <code>q</code> from manifold <code>M</code> are approximately equal. Returns either <code>true</code> or <code>false</code> and does not support errors like <a href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>.</p><p>For more details see documentation of <a href="#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>check_approx</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L742-L750">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}" href="#ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>ManifoldsBase._pick_basic_allocation_argument</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_pick_basic_allocation_argument(::AbstractManifold, f, x...)</code></pre><p>Pick which one of elements of <code>x</code> should be used as a basis for allocation in the <code>allocate_result(M::AbstractManifold, f, x...)</code> method. This can be specialized to, for example, skip <code>Identity</code> arguments in Manifolds.jl group-related functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L155-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}" href="#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_result(M::AbstractManifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L166-L174">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, NTuple{N, Any}}} where {N, TF}" href="#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, NTuple{N, Any}}} where {N, TF}"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.are_linearly_independent-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.are_linearly_independent-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.are_linearly_independent</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">are_linearly_independent(M::AbstractManifold, p, X, Y)</code></pre><p>Check is vectors <code>X</code>, <code>Y</code> tangent at <code>p</code> to <code>M</code> are linearly independent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L225-L229">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_approx</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_approx(M::AbstractManifold, p, q; kwargs...)
check_approx(M::AbstractManifold, p, X, Y; kwargs...)</code></pre><p>Check whether two elements are approximately equal, either <code>p</code>, <code>q</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> or the two tangent vectors <code>X</code>, <code>Y</code> in the tangent space at <code>p</code> are approximately the same. The keyword arguments <code>kwargs</code> can be used to set tolerances, similar to Julia&#39;s <code>isapprox</code>.</p><p>This function might use <code>isapprox</code> from Julia internally and is similar to <a href="#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>isapprox</code></a>, with the difference that is returns an <a href="#ManifoldsBase.ApproximatelyError"><code>ApproximatelyError</code></a> if the two elements are not approximately equal, containting a more detailed description/reason. If the two elements are approximalely equal, this method returns <code>nothing</code>.</p><p>This method is an internal function and is called by <code>isapprox</code> whenever the user specifies an <code>error=</code> keyword therein. <a href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>_isapprox</code></a> is another related internal function. It is supposed to provide a fast true/false decision whether points or vectors are equal or not, while <code>check_approx</code> also provides a textual explanation. If no additional explanation is needed, a manifold may just implement a method of <a href="#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}"><code>_isapprox</code></a>, while it should also implement <code>check_approx</code> if a more detailed explanation could be helpful.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L254-L273">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_point</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractManifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="../types/#ManifoldsBase.AbstractManifoldPoint"><code>AbstractManifoldPoint</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L295-L303">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.check_size</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_size(M::AbstractManifold, p)
check_size(M::AbstractManifold, p, X)</code></pre><p>Check whether <code>p</code> has the right <a href="#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> for a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. Additionally if a tangent vector is given, both <code>p</code> and <code>X</code> are checked to be of corresponding correct representation sizes for points and tangent vectors on <code>M</code>.</p><p>By default, <code>check_size</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L319-L329">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractManifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>. An implementation does not have to validate the point <code>p</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="../types/#ManifoldsBase.AbstractTangentVector"><code>AbstractTangentVector</code></a> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L306-L316">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple" href="#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S&lt;:Tuple"><code>ManifoldsBase.size_to_tuple</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">size_to_tuple(::Type{S}) where S&lt;:Tuple</code></pre><p>Converts a size given by <code>Tuple{N, M, ...}</code> into a tuple <code>(N, M, ...)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/ManifoldsBase.jl#L1092-L1096">source</a></section></article><h2 id="Approximation-Methods"><a class="docs-heading-anchor" href="#Approximation-Methods">Approximation Methods</a><a id="Approximation-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Approximation-Methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractApproximationMethod" href="#ManifoldsBase.AbstractApproximationMethod"><code>ManifoldsBase.AbstractApproximationMethod</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractApproximationMethod</code></pre><p>Abstract type for defining estimation methods on manifolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.CyclicProximalPointEstimation" href="#ManifoldsBase.CyclicProximalPointEstimation"><code>ManifoldsBase.CyclicProximalPointEstimation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CyclicProximalPointEstimation &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation using the cyclic proximal point technique, which is based on <a href="https://en.wikipedia.org/wiki/Proximal_operator">proximal maps</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.EfficientEstimator" href="#ManifoldsBase.EfficientEstimator"><code>ManifoldsBase.EfficientEstimator</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EfficientEstimator &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation in the best possible sense, see <a href="https://en.wikipedia.org/wiki/Efficiency_(statistics)">Efficiency (Statictsics)</a> for more details. This can for example be used when computing the usual mean on an Euclidean space, which is the best estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ExtrinsicEstimation" href="#ManifoldsBase.ExtrinsicEstimation"><code>ManifoldsBase.ExtrinsicEstimation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ExtrinsicEstimation{T} &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation in the ambient space with a method of type <code>T</code> and projecting the result back to the manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.GeodesicInterpolation" href="#ManifoldsBase.GeodesicInterpolation"><code>ManifoldsBase.GeodesicInterpolation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeodesicInterpolation &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation based on geodesic interpolation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.GeodesicInterpolationWithinRadius" href="#ManifoldsBase.GeodesicInterpolationWithinRadius"><code>ManifoldsBase.GeodesicInterpolationWithinRadius</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GeodesicInterpolationWithinRadius{T} &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation based on geodesic interpolation that is restricted to some <code>radius</code></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">GeodesicInterpolationWithinRadius(radius::Real)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L56-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.GradientDescentEstimation" href="#ManifoldsBase.GradientDescentEstimation"><code>ManifoldsBase.GradientDescentEstimation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GradientDescentEstimation &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation using <a href="https://en.wikipedia.org/wiki/Gradient_descent">gradient descent</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.WeiszfeldEstimation" href="#ManifoldsBase.WeiszfeldEstimation"><code>ManifoldsBase.WeiszfeldEstimation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">WeiszfeldEstimation &lt;: AbstractApproximationMethod</code></pre><p>Method for estimation using the Weiszfeld algorithm, compare for example the computation of the <a href="https://en.wikipedia.org/wiki/Geometric_median">Geometric median</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L41-L46">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_approximation_method-Tuple{AbstractManifold, Any}" href="#ManifoldsBase.default_approximation_method-Tuple{AbstractManifold, Any}"><code>ManifoldsBase.default_approximation_method</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_approximation_method(M::AbstractManifold, f)
default_approximation_method(M::AbtractManifold, f, T)</code></pre><p>Specify a default estimation method for an <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> and a specific function <code>f</code> and optionally as well a type <code>T</code> to distinguish different (point or vector) representations on <code>M</code>.</p><p>By default, all functions <code>f</code> call the signature for just a manifold. The exceptional functions are:</p><ul><li><code>retract</code> and <code>retract!</code> which fall back to <a href="../metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a></li><li><code>inverse_retract</code> and <code>inverse_retract!</code> which fall back to <a href="../metamanifolds/#ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}"><code>default_inverse_retraction_method</code></a></li><li>any of the vector transport mehods fall back to <a href="../metamanifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/approximation_methods.jl#L75-L88">source</a></section></article><h2 id="Error-Messages"><a class="docs-heading-anchor" href="#Error-Messages">Error Messages</a><a id="Error-Messages-1"></a><a class="docs-heading-anchor-permalink" href="#Error-Messages" title="Permalink"></a></h2><p>This interface introduces a small set of own error messages.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractManifoldDomainError" href="#ManifoldsBase.AbstractManifoldDomainError"><code>ManifoldsBase.AbstractManifoldDomainError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractManifoldDomainError &lt;: Exception</code></pre><p>An absytract Case for Errors when checking validity of points/vectors on mainfolds</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ApproximatelyError" href="#ManifoldsBase.ApproximatelyError"><code>ManifoldsBase.ApproximatelyError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ApproximatelyError{V,S} &lt;: Exception</code></pre><p>Store an error that occurs when two data structures, e.g. points or tangent vectors.</p><p><strong>Fields</strong></p><ul><li><code>val</code> amount the two approximate elements are apart – is set to <code>NaN</code> if this is not known</li><li><code>msg</code> a message providing more detail about the performed test and why it failed.</li></ul><p><strong>Constructors</strong></p><pre><code class="nohighlight hljs">ApproximatelyError(val::V, msg::S) where {V,S}</code></pre><p>Generate an Error with value <code>val</code> and message <code>msg</code>.</p><pre><code class="nohighlight hljs">ApproximatelyError(msg::S) where {S}</code></pre><p>Generate a message without a value (using <code>val=NaN</code> internally) and message <code>msg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ComponentManifoldError" href="#ManifoldsBase.ComponentManifoldError"><code>ManifoldsBase.ComponentManifoldError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompnentError{I,E} &lt;: Exception</code></pre><p>Store an error that occured in a component, where the additional <code>index</code> is stored.</p><p><strong>Fields</strong></p><ul><li><code>index::I</code> index where the error occured`</li><li><code>error::E</code> error that occured.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L45-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.CompositeManifoldError" href="#ManifoldsBase.CompositeManifoldError"><code>ManifoldsBase.CompositeManifoldError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CompositeManifoldError{T} &lt;: Exception</code></pre><p>A composite type to collect a set of errors that occured. Mainly used in conjunction with <a href="#ManifoldsBase.ComponentManifoldError"><code>ComponentManifoldError</code></a> to store a set of errors that occured.</p><p><strong>Fields</strong></p><ul><li><code>errors</code> a <code>Vector</code> of <code>&lt;:Exceptions</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ManifoldDomainError" href="#ManifoldsBase.ManifoldDomainError"><code>ManifoldsBase.ManifoldDomainError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ManifoldDomainError{&lt;:Exception} &lt;: Exception</code></pre><p>An error to represent a nested (Domain) error on a manifold, for example if a point or tangent vector is invalid because its representation in some embedding is already invalid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log</code></a>arithmic map or <a href="../metamanifolds/#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}"><code>injectivity_radius</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/6067671ac35e3e10adcf65aad373d8963d88ecd7/src/errors.jl#L118-L123">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« An abstract manifold</a><a class="docs-footer-nextpage" href="../projections/">Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Tuesday 29 April 2025 08:49">Tuesday 29 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
