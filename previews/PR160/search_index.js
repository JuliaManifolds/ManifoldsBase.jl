var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions-on-manifolds","page":"Basic functions","title":"Functions on manifolds","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"This page collects several basic functions on manifolds.","category":"page"},{"location":"functions/#exp-and-log","page":"Basic functions","title":"The exponential map, the logarithmic map, and geodesics","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector ‚Äúpoints towards‚Äù the other point.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"exp_log_geo.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions/#Base.exp-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.exp","text":"exp(M::AbstractManifold, p, X)\nexp(M::AbstractManifold, p, X, t::Number = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M, i.e.\n\nexp_p X = Œ≥_pX(1)\n\nwhere Œ≥_pX is the unique geodesic starting in Œ≥(0)=p such that dot Œ≥(0) = X.\n\nSee also shortest_geodesic, retract.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.log-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.log","text":"log(M::AbstractManifold, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The logarithmic map is the inverse of the exponential map. Note that the logarithmic map might not be globally defined.\n\nSee also inverse_retract.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.exp!","text":"exp!(M::AbstractManifold, q, p, X)\nexp!(M::AbstractManifold, q, p, X, t::Number = 1)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M. The result is saved to q.\n\nIf you want to implement exponential map for your manifold, you should implement the method with t, that is exp!(M::MyManifold, q, p, X, t::Number).\n\nSee also exp.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, Q, p, X, T::AbstractVector) -> AbstractVector\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at time points t fom T in place of Q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, q, p, X, t::Real)\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at t in place of q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields that the curve has constant velocity and is locally distance-minimizing.\n\nThis function returns a function (q,t) of (time) t that mutates q`.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X, T::AbstractVector) -> AbstractVector\n\nEvaluate the geodesic Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\nat time points t from T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X, t::Real)\n\nEvaluate the geodesic Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\nat time t.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Œ≥_pX I  mathcal M, with Œ≥_pX(0) = p and dot Œ≥_pX(0) = X a geodesic further fulfills\n\n_dot Œ≥_pX(t) dot Œ≥_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.\n\nThis function returns a function of (time) t.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.log!","text":"log!(M::AbstractManifold, X, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The result is saved to X. The logarithmic map is the inverse of the exp!onential map. Note that the logarithmic map might not be globally defined.\n\nsee also log and inverse_retract!,\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -> AbstractVector\n\nEvaluate a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q at all t from T in place of R. When there are multiple shortest geodesics, a deterministic choice will be taken.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)\n\nEvaluate a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q at t in place of r. When there are multiple shortest geodesics, a deterministic choice will be taken.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function (r,t) -> ... of time t which works in place of r.\n\nFurther variants\n\nshortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)\nshortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -> AbstractVector\n\nmutate (and return) the point r and the vector of points R, respectively, returning the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -> AbstractVector\n\nEvaluate a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q at time points T. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AabstractManifold, p, q, t::Real)\n\nEvaluate a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q at time t. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic Œ≥_pq(t) whose length is the shortest path between the points pand q, where Œ≥_pq(0)=p and Œ≥_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#subsec-parallel-transport","page":"Basic functions","title":"Parallel transport","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"While moving vectors from one base point to another is the identity in the Euclidean space ‚Äì¬†or in other words all tangent spaces (directions one can ‚Äúwalk‚Äù into) are the same. This is different on a manifold.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"If we have two points pq  mathcal M, we take a c 01  mathcal M connecting the two points, i.e. c(0) = p and c(1) = q. this could be a (or the) geodesic. If we further consider a vector field X 01  Tmathcal M, i.e. where X(t)  T_c(t)mathcal M. Then the vector field is called parallel if its covariant derivative fracmathrmDmathrmdtX(t) = 0 for all t 01.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"If we now impose a value for X=X(0)  T_pmathcal M, we obtain an ODE with an initial condition. The resulting value X(1)  T_qmathcal M is called the parallel transport of X along c or in case of a geodesic the _parallel transport of X from p to q.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"parallel_transport.jl\"]\nOrder = [:function]","category":"page"},{"location":"functions/#ManifoldsBase.parallel_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_along","text":"Y = parallel_transport_along(M::AbstractManifold, p, X, c)\n\nCompute the parallel transport of the vector X from the tangent space at p along the curve c.\n\nTo be precise let c(t) be a curve c(0)=p for vector_transport_along mathcal P^cY\n\nTHen In the result Yin T_pmathcal M is the vector X from the tangent space at p=c(0) to the tangent space at c(1).\n\nLet Zcolon 01 to Tmathcal M, Z(t)in T_c(t)mathcal M be a smooth vector field along the curve c with Z(0) = Y, such that Z is parallel, i.e. its covariant derivative fracmathrmDmathrmdtZ is zero. Note that such a Z always exists and is unique.\n\nThen the parallel transport is given by Z(1).\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::AbstractManifold, p, X, d)\n\nCompute the parallel_transport_along the curve c(t) = Œ≥_pq(t), i.e. the * the unique geodesic c(t)=Œ≥_pX(t) from Œ≥_pd(0)=p into direction dot Œ≥_pd(0)=d, of the tangent vector X.\n\nBy default this function calls parallel_transport_to(M, p, X, q), where q=exp_pX.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractManifold, p, X, q)\n\nCompute the parallel_transport_along the curve c(t) = Œ≥_pq(t), i.e. the (assumed to be unique) geodesic connecting p and q, of the tangent vector X.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Further-functions-on-manifolds","page":"Basic functions","title":"Further functions on manifolds","text":"","category":"section"},{"location":"functions/#General-functions-provided-by-the-interface","page":"Basic functions","title":"General functions provided by the interface","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]\nPublic=true\nPrivate=false","category":"page"},{"location":"functions/#Base.angle-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.angle","text":"angle(M::AbstractManifold, p, X, Y)\n\nCompute the angle between tangent vectors X and Y at point p from the AbstractManifold M with respect to the inner product from inner.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M::AbstractManifold, p, X)\n\nCopy the value(s) from the tangent vector X at a point p on the AbstractManifold M into a new tangent vector. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M::AbstractManifold, p)\n\nCopy the value(s) from the point p on the AbstractManifold M into a new point. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, Y, p, X)\n\nCopy the value(s) from X to Y, where both are tangent vectors from the tangent space at p on the AbstractManifold M. This function defaults to calling copyto!(Y, X), but it might be useful to overwrite the function at the level, where also information from p and M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copyto!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, q, p)\n\nCopy the value(s) from p to q, where both are points on the AbstractManifold M. This function defaults to calling copyto!(q, p), but it might be useful to overwrite the function at the level, where also information from M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, X, Y; error:Symbol=:none; kwargs...)\n\nCheck if vectors X and Y tangent at p from AbstractManifold M are approximately equal.\n\nThe optional positional argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported\n\n:error - throws an error if isapprox evaluates to false, providing possibly a more detailed error. Note that this turns isapprox basically to an @assert.\n:info ‚Äì prints the information in an @info\n:warn ‚Äì prints the information in an @warn\n:none (default) ‚Äì the function just returns true/false\n\nBy default these informations are collected by calling check_approx.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, q; error::Symbol=none, kwargs...)\n\nCheck if points p and q from AbstractManifold M are approximately equal.\n\nThe keyword argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported\n\n:error - throws an error if isapprox evaluates to false, providing possibly a more detailed error. Note that this turns isapprox basically to an @assert.\n:info ‚Äì prints the information in an @info\n:warn ‚Äì prints the information in an @warn\n:none (default) ‚Äì the function just returns true/false\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.rand-Tuple{AbstractManifold}","page":"Basic functions","title":"Base.rand","text":"Random.rand(M::AbstractManifold, [d::Integer]; vector_at=nothing)\nRandom.rand(rng::AbstractRNG, M::AbstractManifold, [d::Integer]; vector_at=nothing)\n\nGenerate a random point on manifold M (when vector_at is nothing) or a tangent vector at point vector_at (when it is not nothing).\n\nOptionally a random number generator rng to be used can be specified. An optional integer d indicates that a vector of d points or tangent vectors is to be generated.\n\nnote: Note\nUsually a uniform distribution should be expected for compact manifolds and a Gaussian-like distribution for non-compact manifolds and tangent vectors, although it is not guaranteed. The distribution may change between releases.rand methods for specific manifolds may take additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"LinearAlgebra.norm","text":"norm(M::AbstractManifold, p, X)\n\nCompute the norm of tangent vector X at point p from a AbstractManifold M. By default this is computed using inner.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Integer...)\nallocate(a, dims::Tuple)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Integer...)\nallocate(a, T::Type, dims::Tuple)\nallocate(M::AbstractManifold, a)\nallocate(M::AbstractManifold, a, dims::Integer...)\nallocate(M::AbstractManifold, a, dims::Tuple)\nallocate(M::AbstractManifold, a, T::Type)\nallocate(M::AbstractManifold, a, T::Type, dims::Integer...)\nallocate(M::AbstractManifold, a, T::Type, dims::Tuple)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\nIt's behavior can be overriden by a specific manifold, for example power manifold with nested replacing representation can decide that allocate for Array{<:SArray} returns another Array{<:SArray} instead of Array{<:MArray}, as would be done by default.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.base_manifold","page":"Basic functions","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::AbstractManifold, depth = Val(-1))\n\nReturn the internally stored AbstractManifold for decorated manifold M and the base manifold for vector bundles or power manifolds. The optional parameter depth can be used to remove only the first depth many decorators and return the AbstractManifold from that level, whether its decorated or not. Any negative value deactivates this depth limit.\n\n\n\n\n\n","category":"function"},{"location":"functions/#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q, m::AbstractInverseRetractionMethod)\n\nApproximate distance between points p and q on manifold M using AbstractInverseRetractionMethod m.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q)\n\nShortest distance between the points p and q on the AbstractManifold M, i.e.\n\nd(pq) = inf_Œ≥ L(Œ≥)\n\nwhere the infimum is over all piecewise smooth curves Œ≥ ab to mathcal M connecting Œ≥(a)=p and Œ≥(b)=q and\n\nL(Œ≥) = displaystyleint_a^b lVert dotŒ≥(t)rVert_Œ≥(t) mathrmdt\n\nis the length of the curve Œ≥.\n\nIf mathcal M is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be .\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, Y, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into the ambient space and return the result in Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nThe default is set in such a way that it assumes that the points on M are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding also for tangent vectors is the identity by default.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, q, p)\n\nEmbed point p from the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, embed might include changing data representation, if applicable, i.e. if points on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that it assumes that the points on M are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding in the identity by default.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your point p is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).\n\nAdditionally, embed might include changing data representation, if applicable, i.e. if tangent vectors on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that memory is allocated and embed!(M, Y, p. X) is called.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your tangent vector X is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p)\n\nEmbed point p from the AbstractManifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that memory is allocated and embed!(M, q, p) is called.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed_project","text":"embed_project(M::AbstractManifold, p, X)\n\nEmbed vector X tangent at p from manifold M an project it back to tangent space at p. For points from that tangent space this is identity but in case embedding is defined for tagent vectors from outside of it, this can serve as a way to for example remove numerical innacuracies caused by some algorithms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed_project","text":"embed_project(M::AbstractManifold, p)\n\nEmbed p from manifold M an project it back to M. For points from M this is identity but in case embedding is defined for points outside of M, this can serve as a way to for example remove numerical innacuracies caused by some algorithms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractManifold)\n\nInfimum of the injectivity radii injectivity_radius(M,p) of all points p on the AbstractManifold.\n\ninjectivity_radius(M::AbstractManifold, p)\n\nReturn the distance d such that exp(M, p, X) is injective for all tangent vectors shorter than d (i.e. has an inverse).\n\ninjectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)\ninjectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)\n\nDistance d such that retract(M, p, X, method) is injective for all tangent vectors shorter than d (i.e. has an inverse) for point p if provided or all manifold points otherwise.\n\nIn order to dispatch on different retraction methods, please either implement _injectivity_radius(M[, p], m::T) for your retraction R or specifically injectivity_radius_exp(M[, p]) for the exponential map. By default the variant with a point p assumes that the default (without p) can ve called as a lower bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.inner","text":"inner(M::AbstractManifold, p, X, Y)\n\nCompute the inner product of tangent vectors X and Y at point p from the AbstractManifold M.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.is_flat-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractManifold)\n\nReturn true if the AbstractManifold M is flat, i.e. if its Riemann curvature tensor is everywhere zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.is_point","page":"Basic functions","title":"ManifoldsBase.is_point","text":"is_point(M::AbstractManifold, p, throw_error::Boolean = false; kwargs...)\nis_point(M::AbstractManifold, p, report_error::Symbol; kwargs...)\n\nReturn whether p is a valid point on the AbstractManifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_point and checks whether the returned value is nothing or an error.\n\nA more precise way can be set using a symbol as the optional parameter, where ' :error is the same as setting throw_error=true ' :info displays the error message as an @info\n\n:warn displays the error message as a @warning\n\nall other symbols are equivalent to throw_error=false.\n\n\n\n\n\n","category":"function"},{"location":"functions/#ManifoldsBase.is_vector","page":"Basic functions","title":"ManifoldsBase.is_vector","text":"is_vector(M::AbstractManifold, p, X, throw_error = false, check_base_point=true; kwargs...)\nis_vector(M::AbstractManifold, p, X, error::Symbol, check_base_point::Bool=true; kwargs...)\n\nReturn whether X is a valid tangent vector at point p on the AbstractManifold M. Returns either true or false.\n\nIf throw_error is false, the function returns either true or false. If throw_error is true, the function either returns true or throws an error. By default the function calls check_vector and checks whether the returned value is nothing or an error.\n\nIf check_base_point is true, then the point p will be first checked using the check_point function.\n\nA more precise way can be set using a symbol as the optional parameter, where ' :error is the same as setting throw_error=true ' :info displays the error message as an @info\n\n:warn displays the error message as a @warning.\n\nall other symbols are equivalent to throw_error=false.\n\n\n\n\n\n","category":"function"},{"location":"functions/#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractManifold)\n\nThe dimension n=dim_mathcal M of real space mathbb R^n to which the neighborhood of each point of the AbstractManifold M is homeomorphic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point!","text":"mid_point!(M::AbstractManifold, q, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp!. Saves the result in q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point","text":"mid_point(M::AbstractManifold, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.number_eltype-Tuple{Any}","page":"Basic functions","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjuntion with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.representation_size-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractManifold)\n\nThe size of an array representing a point on AbstractManifold M. Returns nothing by default indicating that points are not represented using an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Basic functions","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractManifold, p, X, Y, Z)\n\nCompute the value of the Riemann tensor R(X_fY_f)Z_f at point p, where X_f, Y_f and Z_f are vector fields defined by parallel transport of, respectively, X, Y and Z to the desired point. All computations are performed using the connection associated to manifold M.\n\nThe formula reads R(X_fY_f)Z_f = nabla_Xnabla_Y Z - nabla_Ynabla_X Z - nabla_X YZ, where X Y is the Lie bracket of vector fields.\n\nNote that some authors define this quantity with inverse sign.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector!","text":"zero_vector!(M::AbstractManifold, X, p)\n\nSave to X the tangent vector from the tangent space T_pmathcal M at p that represents the zero vector, i.e. such that retracting X to the AbstractManifold M at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::AbstractManifold, p)\n\nReturn the tangent vector from the tangent space T_pmathcal M at p on the AbstractManifold M, that represents the zero vector, i.e. such that a retraction at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Internal-functions","page":"Basic functions","title":"Internal functions","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"While you should always add your documentation to functions from the last section, some of the functions dispatch onto functions on layer III. These are the ones you usually implement for your manifold ‚Äì unless there is no lower level function called, like for the manifold_dimension.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:function]\nPublic=false\nPrivate=true","category":"page"},{"location":"functions/#Base.convert-Tuple{Type, AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.convert","text":"convert(T::Type, M::AbstractManifold, p, X)\n\nConvert vector X tangent at point p from manifold M to type T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.convert-Tuple{Type, AbstractManifold, Any}","page":"Basic functions","title":"Base.convert","text":"convert(T::Type, M::AbstractManifold, p)\n\nConvert point p from manifold M to type T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase._isapprox","text":"_isapprox(M::AbstractManifold, p, X, Y; kwargs...)\n\nAn internal function for testing whether tangent vectors X and Y from tangent space at point p from manifold M are approximately equal. Returns either true or false and does not support errors like isapprox.\n\nFor more details see documentation of check_approx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase._isapprox","text":"_isapprox(M::AbstractManifold, p, q; kwargs...)\n\nAn internal function for testing whether points p and q from manifold M are approximately equal. Returns either true or false and does not support errors like isapprox.\n\nFor more details see documentation of check_approx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase._pick_basic_allocation_argument","text":"_pick_basic_allocation_argument(::AbstractManifold, f, x...)\n\nPick which one of elements of x should be used as a basis for allocation in the allocate_result(M::AbstractManifold, f, x...) method. This can be specialized to, for example, skip Identity arguments in Manifolds.jl group-related functions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::AbstractManifold, f, x...)\n\nAllocate an array for the result of function f on AbstractManifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, Tuple{Vararg{Any, N}}}} where {N, TF}","page":"Basic functions","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f and the AbstractManifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_approx","text":"check_approx(M::AbstractManifold, p, q; kwargs...)\ncheck_approx(M::AbstractManifold, p, X, Y; kwargs...)\n\nCheck whether two elements are approximately equal, either p, q on the AbstractManifold or the two tangent vectors X, Y in the tangent space at p are approximately the same. The keyword arguments kwargs can be used to set tolerances, similar to Julia's isapprox.\n\nThis function might use isapprox from Julia internally and is similar to isapprox, with the difference that is returns an ApproximatelyError if the two elements are not approximately equal, containting a more detailed description/reason. If the two elements are approximalely equal, this method returns nothing.\n\nThis method is an internal function and is called by isapprox whenever the user specifies an error= keyword therein. _isapprox is another related internal function. It is supposed to provide a fast true/false decision whether points or vectors are equal or not, while check_approx also provides a textual explanation. If no additional explanation is needed, a manifold may just implement a method of _isapprox, while it should also implement check_approx if a more detailed explanation could be helpful.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractManifold, p; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when p is a point on the AbstractManifold M. Otherwise, return an error with description why the point does not belong to manifold M.\n\nBy default, check_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the AbstractManifoldPoint type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_size","text":"check_size(M::AbstractManifold, p)\ncheck_size(M::AbstractManifold, p, X)\n\nCheck whether p has the right representation_size for a AbstractManifold M. Additionally if a tangent vector is given, both p and X are checked to be of corresponding correct representation sizes for points and tangent vectors on M.\n\nBy default, check_size returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractManifold, p, X; kwargs...) -> Union{Nothing,String}\n\nCheck whether X is a valid tangent vector in the tangent space of p on the AbstractManifold M. An implementation does not have to validate the point p. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S<:Tuple","page":"Basic functions","title":"ManifoldsBase.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"method"},{"location":"functions/#Error-Messages","page":"Basic functions","title":"Error Messages","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"This interface introduces a small set of own error messages.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Modules = [ManifoldsBase]\nPages = [\"errors.jl\"]\nOrder = [:type]","category":"page"},{"location":"functions/#ManifoldsBase.AbstractManifoldDomainError","page":"Basic functions","title":"ManifoldsBase.AbstractManifoldDomainError","text":"AbstractManifoldDomainError <: Exception\n\nAn absytract Case for Errors when checking validity of points/vectors on mainfolds\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ApproximatelyError","page":"Basic functions","title":"ManifoldsBase.ApproximatelyError","text":"ApproximatelyError{V,S} <: Exception\n\nStore an error that occurs when two data structures, e.g. points or tangent vectors.\n\nFields\n\nval amount the two approximate elements are apart ‚Äì is set to NaN if this is not known\nmsg a message providing more detail about the performed test and why it failed.\n\nConstructors\n\nApproximatelyError(val::V, msg::S) where {V,S}\n\nGenerate an Error with value val and message msg.\n\nApproximatelyError(msg::S) where {S}\n\nGenerate a message without a value (using val=NaN internally) and message msg.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ComponentManifoldError","page":"Basic functions","title":"ManifoldsBase.ComponentManifoldError","text":"CompnentError{I,E} <: Exception\n\nStore an error that occured in a component, where the additional index is stored.\n\nFields\n\nindex::I index where the error occured`\nerror::E error that occured.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.CompositeManifoldError","page":"Basic functions","title":"ManifoldsBase.CompositeManifoldError","text":"CompositeManifoldError{T} <: Exception\n\nA composite type to collect a set of errors that occured. Mainly used in conjunction with ComponentManifoldError to store a set of errors that occured.\n\nFields\n\nerrors a Vector of <:Exceptions.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ManifoldDomainError","page":"Basic functions","title":"ManifoldsBase.ManifoldDomainError","text":"ManifoldDomainError{<:Exception} <: Exception\n\nAn error to represent a nested (Domain) error on a manifold, for example if a point or tangent vector is invalid because its representation in some embedding is already invalid.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.OutOfInjectivityRadiusError","page":"Basic functions","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/implement-a-manifold/#How-to-Implement-a-Manifold","page":"How to define a manifold","title":"How to Implement a Manifold","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"CurrentModule = ManifoldsBase","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"This tutorial illustrates, how to implement your very first manifold. We start from the very beginning and cover the basic ideas of the interface provided by ManifoldsBase.jl interface.","category":"page"},{"location":"tutorials/implement-a-manifold/#Preliminaries","page":"How to define a manifold","title":"Preliminaries","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We will use a simple example in this tutorial, since the main focus here is to illustrate how to define a manifold. We will use the sphere of radius r embedded in mathbb R^d+1, i.e.¬†all vectors of length r. Formally we define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"mathbb S_r^d =\nbigl\n    p in mathbb R^d+1\n    big\n    lVert p rVert = r\nbigr","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"When defining a Riemannian manifold mathematically, there is several things to keep in mind, for example the metric imposed on the tangent spaces. For this interface we assume these things to be given implicitly for a first implementation, but they can be made more precise when necessary.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"The only thing we have to be aware of for now is the number_system, i.e.¬†whether our manifold is a real-valued or a complex-valued manifold. The abstract type all manifolds inherit from, the AbstractManifold{ùîΩ} has this number system as a parameter. The usual parameter we will use are the RealNumbers(), which have a short hand in ManifoldsBase.jl, namely ‚Ñù. The second one are the ComplexNumbers(), or ‚ÑÇ for short.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"using LinearAlgebra, ManifoldsBase\nusing ManifoldsBase: ‚Ñù","category":"page"},{"location":"tutorials/implement-a-manifold/#Defining-a-manifold","page":"How to define a manifold","title":"Defining a manifold","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"A manifold itself is a struct that is a subtype of AbstractManifold and should contain. We usually recommend to also document your new manifold.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Since the Sphere is already a name used within Manifolds.jl, let‚Äôs use a slightly more specific name. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"\"\"\"\n    ScaledSphere <: AbstractManifold{‚Ñù}\n\nDefine a sphere of fixed radius\n\n# Fields\n\n* `dimension` dimension of the sphere\n* `radius` the radius of the sphere\n\n# Constructor\n\n    ScaledSphere(dimension,radius=1.0)\n\nInitialize the manifold to a certain `dimension` and `radius`,\nwhich by default is set to `1.0`\n\"\"\"\nstruct ScaledSphere <: AbstractManifold{‚Ñù}\n    dimension::Int\n    radius::Float64\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And we can directly use this manifold and set","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"M = ScaledSphere(2,1.5)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ScaledSphere(2, 1.5)","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-I:-Manifold-properties","page":"How to define a manifold","title":"Functions I: Manifold properties","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"While the interface provides a lot of possible functions to define for your manifold, you only need to define those that are necessary for your implementation. If you are using other packages depending on ManifoldsBase.jl you will often just get a ‚ÄúMethod not defined‚Äù and sometimes an ambiguity error indicating that a function is missing that is required for a certain task.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We can first start with a technical function which internally ist often used. Any of our points or tangent vectors is represented as a (d+1)-dimensional vector. This is internally often used when allocating memory, see representation_size. It returns a tuple representing the size of arrays for valid points. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: representation_size\nrepresentation_size(M::ScaledSphere) = (M.dimension+1,)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Similarly, we can implement the function returning the dimension of the manifold, cf.¬†manifold_dimension as","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: manifold_dimension\nmanifold_dimension(M::ScaledSphere) = M.dimension","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and we can now easily use them to access the dimension of the manifold","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"manifold_dimension(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"2","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-II:-Verifying-Points-and-tangent-vectors","page":"How to define a manifold","title":"Functions II: Verifying Points and tangent vectors","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"The first two functions we want to define are those to check points and tangent vectors for our manifold. Let‚Äôs first clarify what the tangent space looks like. The directions ‚Äúwe can walk into‚Äù from a point pin mathbb S_r^d are all X that are orthogonal to p, which is the plane/vector space tangent to the sphere. Formally","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"T_pmathbb S_r^d =\nbigl\n    X in mathbb R^d+1\n    big\n    langle p X rangle = 0\nbigr qquad p in mathbb S_r^d","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"to verify either p or X one uses is_point(M,p) and is_vector(M, p, X) respectively. Since both involve some automatic options and possibililities, for example whether to throw an error or just return false, both mention that the actual functions to implement are check_point and check_vector, which both do not throw but return an error if something is wrong.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"In principle we would have to check two properties, namely that the size of p is of correct size M.dimension+1 and that its norm is M.radius. Luckily, by defining representation_size the first check is automatically done already ‚Äì¬†actually for both points and vectors. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: check_point\nfunction check_point(M::ScaledSphere, p; kwargs...)\n    if !isapprox(norm(p), M.radius; kwargs...)\n        return DomainError(norm(p), \"The norm of $p is not $(M.radius).\")\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And we can directly test the function. To see all 3 failing ones, we switch from errors to warnings in the check","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"is_point(M, [1.5, 0.0], :warn) # wrong size\nis_point(M, [1.0, 0.0, 0.0], :warn) # wrong norm\nis_point(M, [1.5, 0.0, 0.0], :warn) # on the manifold, returns true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"‚îå Warning: DomainError with (2,)\n‚îÇ The point [1.5, 0.0] can not belong to the manifold ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifolds representation size ((3,)).\n‚îî @ ManifoldsBase ~/.julia/packages/ManifoldsBase/U8FsH/src/ManifoldsBase.jl:680\n‚îå Warning: DomainError with 1.0\n‚îÇ The norm of [1.0, 0.0, 0.0] is not 1.5.\n‚îî @ ManifoldsBase ~/.julia/packages/ManifoldsBase/U8FsH/src/ManifoldsBase.jl:687\n\ntrue","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"similarly for vectors, we just have to implement the orthogonality check.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: check_vector\nfunction check_vector(M::ScaledSphere, p, X; kwargs...)\n    if !isapprox(dot(p,X), 0.0; kwargs...)\n        return DomainError(\n            dot(p,X),\n            \"The tangent vector $X is not orthogonal to $p.\"\n        )\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and again, the high level interface can be used to display warning for vectors not fulfilling the criterion, but we can also activate a check for the point using the last positional argument","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"is_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0], :warn) # wrong size\nis_vector(M, [1.5, 0.0, 0.0], [1.0, 1.0, 0.0], :warn) # not orthogonal norm\nis_vector(M, [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], :warn, true) # point not valid\nis_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0, 0.0], :warn, true) # returns true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"‚îå Warning: DomainError with (2,)\n‚îÇ The tangent vector [0.0, 1.0] can not belong to the manifold ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifodls representation size ((3,)).\n‚îî @ ManifoldsBase ~/.julia/packages/ManifoldsBase/U8FsH/src/ManifoldsBase.jl:756\n‚îå Warning: DomainError with 1.5\n‚îÇ The tangent vector [1.0, 1.0, 0.0] is not orthogonal to [1.5, 0.0, 0.0].\n‚îî @ ManifoldsBase ~/.julia/packages/ManifoldsBase/U8FsH/src/ManifoldsBase.jl:763\n‚îå Warning: DomainError with 1.0\n‚îÇ The norm of [1.0, 0.0, 0.0] is not 1.5.\n‚îî @ ManifoldsBase ~/.julia/packages/ManifoldsBase/U8FsH/src/ManifoldsBase.jl:687\n\ntrue","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction.","page":"How to define a manifold","title":"Functions on Manifolds III: The exponential map and a retraction.","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"For the final group of functions, we want to implement the exponential map and a retraction. Both are ways to ‚Äúmove around‚Äù on the manifold, that is, given a point p and a tangent vector indicating a ‚Äúwalking direction‚Äù, the two functions we define will return a new point q on the manifold.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"For functions that compute a new point or tangent vector, ManifoldsBase.jl always provides two varinats: One that allocates new memory and one, that allows to provide the memory, the result should be returned in ‚Äì¬†to spare memory allocations.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Let‚Äôs first take a look at what the exponential map is defined like. We follow the shortest curves, that is great arcs, on the sphere. Formally we have","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"exp_p X =\ncosBigl(frac1rlVert X rVertBigr)p +\nsinBigl(frac1rlVert X rVertBigr)fracXlVert X rVert","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"In fact, from the two functions above, exp(M, p, X) and exp!(M, q, p, X), that works in place of q, we only have to implement the second. The first one, exp by default falls back to allocating memory and calling the secnod. Sp exp should only be defined, if there is a special reason for. Furthermore, we usually do not verify/check inputs to spare time. If a user feels insecure, they could for example use the ValidationManifold wrapper which adds explicitly checks of inputs and outputs.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: exp!\nfunction exp!(M::ScaledSphere, q, p, X)\n    nX = norm(X)\n    if nX == 0\n        q .= p\n    else\n        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (1/nX) .* X\n    end\n    return q\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and we can directly test our function starting in the north pole and ‚Äúwaling down‚Äù to the equator","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"q = exp(M, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0])","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.5\n 0.0\n 9.184850993605148e-17","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"but we also get the other variants for free, for example","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"q2 = zero(q)\nexp!(M, q2, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0])\nq2","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.5\n 0.0\n 9.184850993605148e-17","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"or the one that shortens or enlongates the path by a factor, for example, if we walk twice the distance, we reach the opposite point","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"exp!(M, q2, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0], 2.0)\nq2","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n  1.8369701987210297e-16\n  0.0\n -1.5","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Of course we can easliy check that both points we computed still lie on the sphere","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"all([is_point(M, q), is_point(M, q2)])","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Since the exponential map might in general be expensive, we can do a similar implementation with the ProjectionRetraction. Here, we really have to take into account, that the interface is designed with 3 levels in mind: While the actual function we would call in the end is retract(M, p, X, ProjectionRetraction()) (or its ! variant), we actually have to implement retract_project!(M, q, p, X, t) for technical details, that are a bit beyond this introductionary tutorial. In short this split avoids ambiguity errors for decorators of the manifolds. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: retract_project!\nfunction retract_project!(M::ScaledSphere, q, p, X, t)\n    q .= (p + t*X) .* (M.radius/norm(p + t*X))\n    return q\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"retract_project! (generic function with 1 method)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And to test also this function, and avoiding allocations at the same time, we call","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"retract!(M, q, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0], ProjectionRetraction())","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.2653454121031529\n 0.0\n 0.8055439082194726","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Finally, there is default_retraction_method to specify which is the default retraction to use. By default this is","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ExponentialRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"But we can easily specify this for our manifold as well, for example defining","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: default_retraction_method\ndefault_retraction_method(::ScaledSphere) = ProjectionRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method (generic function with 5 methods)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Then","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ProjectionRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and retract without a method specified would always fall back to using the projection retraction instead of the exponential map. Note that for compatibilty there is the AbstractRetractionMethod called ExponentialRetraction which makes retract fall back to calling exp.","category":"page"},{"location":"decorator/#A-Decorator-for-manifolds","page":"Decorating/Extending a Manifold","title":"A Decorator for manifolds","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"Several properties of a manifold are often implicitly assumed, for example the choice of the (Riemannian) metric, the group structure or the embedding. The latter shall serve as an example how to either implicitly or explicitly specify the embedding to avoid re-implementations and/or distinguish different embeddings.","category":"page"},{"location":"decorator/#The-abstract-decorator","page":"Decorating/Extending a Manifold","title":"The abstract decorator","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"When first implementing a manifold, it might be beneficial to dispatch certain computations to already existing manifolds. For an embedded manifold that is isometrically embedded this might be the inner the manifold inherits in each tangent space from its embedding.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"This means we would like to dispatch the default implementation of a function to some other manifold. We refer to this as implicit decoration, since one can not ‚Äúsee‚Äù explicitly that a certain manifold inherits this property. As an example consider the Sphere. At each point the tangent space can be identified with a subspace of the tangent space in the embedding, the Euclidean manifold which the unit vectors of the sphere belong to. Thus every tangent space inherits its metric from the embedding. Since in the default implementation in Manifolds.jl points are represented by unit vectors and tangent vectors at a point as vectors orthogonal to that point, we can just dispatch the inner product to the embedding without having to re-implement this. The manifold using such an implicit dispatch just has to be a subtype of AbstractDecoratorManifold.","category":"page"},{"location":"decorator/#Traits-with-an-inheritance-hierarchy","page":"Decorating/Extending a Manifold","title":"Traits with an inheritance hierarchy","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"The properties mentioned above might form a hierarchy. For embedded manifolds, again, we might have just a manifold whose points are represented in some embedding. If the manifold is even isometrically embedded, it is embedded but also inherits the Riemannian metric by restricting the metric from the embedding to the corresponding tangent space under consideration. But it also inherits the functions defined for the plain embedding, for example checking some conditions for the validity of points and vectors. If it is even a submanifold, also further functions are inherited like the shortest_geodesic.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"We use a variation of Tim Holy's Traits Trick (THTT) which takes into account this nestedness of traits.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"Modules = [ManifoldsBase]\nPages = [\"nested_trait.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"decorator/#ManifoldsBase.AbstractDecoratorManifold","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractDecoratorManifold","text":"AbstractDecoratorManifold{ùîΩ} <: AbstractManifold{ùîΩ}\n\nDeclare a manifold to be an abstract decorator. A manifold which is a subtype of is a decorated manifold, i.e. has\n\ncertain additional properties or\ndelegates certain properties to other manifolds.\n\nMost prominently, a manifold might be an embedded manifold, i.e. points on a manifold mathcal M are represented by (some, maybe not all) points on another manifold mathcal N. Depending on the type of embedding, several functions are dedicated to the embedding. For example if the embedding is isometric, then the inner does not have to be implemented for mathcal M but can be automatically implemented by deligation to mathcal N.\n\nThis is modelled by the AbstractDecoratorManifold and traits. These are mapped to functions, which determine the types of transparencies.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.AbstractTrait","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractTrait","text":"AbstractTrait\n\nAn abstract trait type to build a sequence of traits\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.EmptyTrait","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.EmptyTrait","text":"EmptyTrait <: AbstractTrait\n\nA Trait indicating that no feature is present.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.IsExplicitDecorator","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IsExplicitDecorator","text":"IsExplicitDecorator <: AbstractTrait\n\nSpecify that a certain type should dispatch per default to its decorated_manifold.\n\nnote: Note\nAny decorator behind this decorator might not have any effect, since the function dispatch is moved to its field at this point. Therefore this decorator should always be last in the TraitList.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.TraitList","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.TraitList","text":"TraitList <: AbstractTrait\n\nCombine two traits into a combined trait.  Note that this introduces a preceedence. the first of the traits takes preceedence if a trait is implemented for both functions.\n\nConstructor\n\nTraitList(head::AbstractTrait, tail::AbstractTrait)\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.@next_trait_function-Tuple{Any, Any}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.@next_trait_function","text":"next_trait_function(trait_type, sig)\n\nDefine a special trait-handling method for function indicated by sig. It does not change the result but the presence of such additional methods may prevent method recursion limits in Julia's inference from being triggered. Some functions may work faster after adding methods generated by next_trait_function.\n\nSee the \"Trait recursion breaking\" section at the bottom of src/decorator_trait.jl file for an example of intended usage.\n\n\n\n\n\n","category":"macro"},{"location":"decorator/#ManifoldsBase.active_traits-Tuple{Any, Vararg{Any}}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.active_traits","text":"active_traits(f, args...)\n\nReturn the list of traits applicable to the given call of function f`. This function should be overloaded for specific function calls.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.expand_trait-Tuple{AbstractTrait}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.expand_trait","text":"expand_trait(t::AbstractTrait)\n\nExpand given trait into an ordered TraitList list of traits with their parent traits obtained using parent_trait.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.merge_traits-Tuple{}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.merge_traits","text":"merge_traits(t1, t2, trest...)\n\nMerge two traits into a nested list of traits. Note that this takes trait preceedence into account, i.e. t1 takes preceedence over t2 is any operations. It always returns either ab EmptyTrait or a TraitList.\n\nThis means that for\n\none argument it just returns the trait itself if it is list-like, or wraps the trait in a   single-element list otherwise,\ntwo arguments that are list-like, it merges them,\ntwo arguments of which only the first one is list-like and the second one is not,   it appends the second argument to the list,\ntwo arguments of which only the second one is list-like, it prepends the first one to   the list,\ntwo arguments of which none is list-like, it creates a two-element list.\nmore than two arguments it recursively performs a left-assiciative recursive reduction   on arguments, that is for example merge_traits(t1, t2, t3) is equivalent to   merge_traits(merge_traits(t1, t2), t3)\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.next_trait-Tuple{AbstractTrait}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.next_trait","text":"next_trait(t::AbstractTrait)\n\nReturn the next trait to consider, which by default is no following trait (i.e. EmptyTrait).\n\nExpecially for a a TraitList this function returns the (remaining) tail of the remaining traits.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.parent_trait-Tuple{AbstractTrait}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.parent_trait","text":"parent_trait(t::AbstractTrait)\n\nReturn the parent trait for trait t, that is the more general trait whose behaviour it inherits as a fallback.\n\n\n\n\n\n","category":"method"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"The key part of the trait system is that it forms a list of traits, from the most specific one to the least specific one, and tries to find a specific implementation of a function for a trait in the least. This ensures that there are, by design, no ambiguities (caused by traits) in the method selection process. Trait resolution is driven by Julia's method dispatch and the compiler is sufficiently clever to quite reliably constant-propagate traits and inline method calls.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"The list of traits is browsed from the most specific one for implementation of a given function for that trait. If one is found, the implementation is called and it may internally call completely different function, breaking the trait dispatch chain. When no implementation for a trait is found, the next trait on the list is checked, until EmptyTrait is reached, which is conventionally the last trait to be considered, expected to have the most generic default implementation of a function If you want to continue with the following traits afterwards, use s =next_trait(t) of a TraitList t to continue working on the next trait in the list by calling the function with s as first argument.","category":"page"},{"location":"decorator/#The-Manifold-decorator","page":"Decorating/Extending a Manifold","title":"The Manifold decorator","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"Based on the generic TraitList the following types, functions, and macros introduce the decorator trait which allows to decorate an arbitrary <:AbstractDecoratorManifold with further features.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"Modules = [ManifoldsBase]\nPages = [\"decorator_trait.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"decorator/#ManifoldsBase.IsEmbeddedManifold","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IsEmbeddedManifold","text":"IsEmbeddedManifold <: AbstractTrait\n\nA trait to declare an AbstractManifold as an embedded manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.IsEmbeddedSubmanifold","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IsEmbeddedSubmanifold","text":"IsEmbeddedSubmanifold <: AbstractTrait\n\nA trait to determine whether an AbstractDecoratorManifold M is an embedded submanifold. It is a special case of the IsIsometricEmbeddedManifold trait, i.e. it has all properties of this trait.\n\nIn this trait, additionally to the isometric embedded manifold, all retractions, inverse retractions, and vectors transports, especially exp, log, and parallel_transport_to are passed to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.IsIsometricEmbeddedManifold","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IsIsometricEmbeddedManifold","text":"IsIsometricManifoldEmbeddedManifold <: AbstractTrait\n\nA Trait to determine whether an AbstractDecoratorManifold M is an isometrically embedded manifold. It is a special case of the IsEmbeddedManifold trait, i.e. it has all properties of this trait.\n\nHere, additionally, netric related functions like inner and norm are passed to the embedding\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.decorated_manifold-Tuple{AbstractDecoratorManifold}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::AbstractDecoratorManifold)\n\nFor a manifold M that is decorated with some properties, this function returns the manifold without that manifold, i.e. the manifold that was decorated.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold, Any}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::AbstractDecoratorManifold)\nget_embedding(M::AbstractDecoratorManifold, p)\n\nSpecify the embedding of a manifold that has abstract decorators. the embedding might depend on a point representation, where different point representations are distinguished as subtypes of AbstractManifoldPoint. A unique or default representation might also just be an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"For an example see the (implicit) embedded manifold.","category":"page"},{"location":"vector_transports/#Vector-transport","page":"Vector transports","title":"Vector transport","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Similar to the exponential and logarithmic map also the parallel transport might be costly to compute, especially when there is no closed form solution known and it has to be approximated with numerical methods. Similar to the retraction and its inverse, the generalisation of the parallel transport can be phrased as follows","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"A vector transport is a way to transport a vector between two tangent spaces. Let pq  mathcal M be given, c the curve along which we want to transport (cf. parallel transport, for example a geodesic or curve given by a retraction. We can specify the geodesic or curve a retraction realises for example by a direction d.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"More precisely using [AbsilMahonySepulchre2008], Def. 8.1.1, a vector transport T_pd T_pmathcal M to T_qmathcal M, p mathcal M, Y T_pmathcal M is a smooth mapping associated to a retraction operatornameretr_p(Y) = q such that","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"(associated retraction) mathcal T_pdX  T_qmathcal M if and only if q = operatornameretr_p(d),\n(consistency) mathcal T_p0_pX = X for all XT_pmathcal M,\n(linearity) mathcal T_pd(Œ±X+Œ≤Y) = mathcal Œ±T_pdX + mathcal Œ≤T_pdY for all Œ± Œ≤  ùîΩ,","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"hold.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Currently the following methods for vector transport are defined in ManifoldsBase.jl.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:function]\nPublic=true\nPrivate=false","category":"page"},{"location":"vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}","page":"Vector transports","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::AbstractManifold)\ndefault_vector_transport_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractVectorTransportMethod that is used when calling vector_transport_along, vector_transport_to, or vector_transport_direction without specifying the vector transport method. By default, this is ParallelTransport.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different vector transport methods.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along","page":"Vector transports","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::AbstractManifold, p, X, c)\nvector_transport_along(M::AbstractManifold, p, X, c, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along!","page":"Vector transports","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::AbstractManifold, Y, p, X, c::AbstractVector)\nvector_transport_along!(M::AbstractManifold, Y, p, X, c::AbstractVector, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along the curve represented by c using the method, which defaults to default_vector_transport_method(M). The result is saved to Y.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector, SchildsLadderTransport}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(\n    M::AbstractManifold,\n    p,\n    X,\n    c::AbstractVector,\n    m::SchildsLadderTransport\n)\n\nCompute the vector transport along a discretized curve using SchildsLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along","text":"function vector_transport_along(\n    M::AbstractManifold,\n    p,\n    X,\n    c::AbstractVector,\n    m::PoleLadderTransport\n)\n\nCompute the vector transport along a discretized curve using PoleLadderTransport succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::AbstractManifold, p, X, d)\nvector_transport_direction(M::AbstractManifold, p, X, d, m::AbstractVectorTransportMethod)\n\nGiven an AbstractManifold mathcal M the vector transport is a generalization of the parallel_transport_direction that identifies vectors from different tangent spaces.\n\nMore precisely using [AbsilMahonySepulchre2008], Def. 8.1.1, a vector transport T_pd T_pmathcal M to T_qmathcal M, p mathcal M, Y T_pmathcal M is a smooth mapping associated to a retraction operatornameretr_p(Y) = q such that\n\n(associated retraction) mathcal T_pdX  T_qmathcal M if and only if q = operatornameretr_p(d).\n(consistency) mathcal T_p0_pX = X for all XT_pmathcal M\n(linearity) mathcal T_pd(Œ±X+Œ≤Y) = Œ±mathcal T_pdX + Œ≤mathcal T_pdY\n\nFor the AbstractVectorTransportMethod we might even omit the third point. The AbstractLinearVectorTransportMethods are linear.\n\nInput Parameters\n\nM a manifold\np indicating the tangent space of\nX the tangent vector to be transported\nd indicating a transport direction (and distance through its length)\nm an AbstractVectorTransportMethod, by default default_vector_transport_method, so usually ParallelTransport\n\nUsually this method requires a AbstractRetractionMethod as well. By default this is assumed to be the default_retraction_method or implicitly given (and documented) for a vector transport. To explicitly distinguish different retractions for a vector transport, see VectorTransportDirection.\n\nInstead of spcifying a start direction d one can equivalently also specify a target tanget space T_qmathcal M, see vector_transport_to. By default vector_transport_direction falls back to using vector_transport_to, using the default_retraction_method on M.\n\n[AbsilMahonySepulchre2008]: Absil, P.-A., Mahony, R. and Sepulchre R., Optimization Algorithms on Matrix Manifolds Princeton University Press, 2008, doi: 10.1515/9781400830244 open access\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction!","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::AbstractManifold, Y, p, X, d)\nvector_transport_direction!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the m and r, which default to default_vector_transport_method(M) and default_retraction_method(M), respectively. The result is saved to Y.\n\nSee vector_transport_direction for more details.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to","page":"Vector transports","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractManifold, p, X, q)\nvector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)\nvector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along a curve implicitly given by an AbstractRetractionMethod associated to m. By default m is the default_vector_transport_method(M). To explicitly specify a (different) retraction to the implicitly assumeed retraction, see VectorTransportTo. Note that some vector transport methods might also carry their own retraction they are associated to, like the  DifferentiatedRetractionVectorTransport and some are even independent of the retraction, for example the ProjectionTransport.\n\nThis method is equivalent to using d = operatornameretr^-1_p(q) in vector_transport_direction(M, p, X, q, m, r), where you can find the formal definition. This is the fallback for VectorTransportTo.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to!","page":"Vector transports","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::AbstractManifold, Y, p, X, q)\nvector_transport_to!(M::AbstractManifold, Y, p, X, q, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M to q using the AbstractVectorTransportMethod m and the AbstractRetractionMethod r.\n\nThe result is computed in Y. See vector_transport_to for more details.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#Types-of-vector-transports","page":"Vector transports","title":"Types of vector transports","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"To distinguish different types of vector transport we introduce the AbstractVectorTransportMethod. The following concrete types are available.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:type]","category":"page"},{"location":"vector_transports/#ManifoldsBase.AbstractLinearVectorTransportMethod","page":"Vector transports","title":"ManifoldsBase.AbstractLinearVectorTransportMethod","text":"AbstractLinearVectorTransportMethod <: AbstractVectorTransportMethod\n\nAbstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.AbstractVectorTransportMethod","page":"Vector transports","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod\n\nAbstract type for methods for transporting vectors. Such vector transports are not necessarily linear.\n\nSee also\n\nAbstractLinearVectorTransportMethod\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.DifferentiatedRetractionVectorTransport","page":"Vector transports","title":"ManifoldsBase.DifferentiatedRetractionVectorTransport","text":"DifferentiatedRetractionVectorTransport{R<:AbstractRetractionMethod} <:\n    AbstractVectorTransportMethod\n\nA type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let mathcal M be a Riemannian manifold, pmathcal M a point, and XY T_pmathcal M denote two tangent vectors at p.\n\nGiven a retraction (cf. AbstractRetractionMethod) operatornameretr, the vector transport of X in direction Y (cf. vector_transport_direction) by differentiation this retraction, is given by\n\nmathcal T^operatornameretr_pYX\n= D_Yoperatornameretr_p(Y)X\n= fracmathrmdmathrmdtoperatornameretr_p(Y+tX)Bigr_t=0\n\nsee [AbsilMahonySepulchre2008], Section 8.1.2 for more details.\n\nThis can be phrased similarly as a vector_transport_to by introducing q=operatornameretr_pX and defining\n\nmathcal T^operatornameretr_q gets pX = mathcal T^operatornameretr_pYX\n\nwhich in practice usually requires the inverse_retract to exists in order to compute Y = operatornameretr_p^-1q.\n\nConstructor\n\nDifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ParallelTransport","page":"Vector transports","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nCompute the vector transport by parallel transport, see parallel_transport_to\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.PoleLadderTransport","page":"Vector transports","title":"ManifoldsBase.PoleLadderTransport","text":"PoleLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use pole_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet X T_pmathcal M be a tangent vector at pmathcal M and qmathcal M the point to transport to. Then x = exp_pX is used to call y =pole_ladder(M, p, x, q) and the resulting vector is obtained by computing Y = -log_qy.\n\nThe PoleLadderTransport posesses two advantages compared to SchildsLadderTransport:\n\nit is cheaper to evaluate, if you want to transport several vectors, since the mid point c then stays unchanged.\nwhile both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds[Pennec2018]\n\nThe pole ladder was was proposed in [LorenziPennec2014]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.\n\nConstructor\n\nPoleLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical pole ladder that employs exp and log, i.e. as proposed in[LorenziPennec2014]. For an even cheaper transport the inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[LorenziPennec2014]: Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild‚Äôs to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5‚Äì17 doi 10.1007/s10851-013-0470-3, hal: hal-00870489\n\n[Pennec2018]: Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: 1805.11436\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ProjectionTransport","page":"Vector transports","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along. See project for details.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ScaledVectorTransport","page":"Vector transports","title":"ManifoldsBase.ScaledVectorTransport","text":"ScaledVectorTransport{T} <: AbstractVectorTransportMethod\n\nIntroduce a scaled variant of any AbstractVectorTransportMethod T, as introduced in [SatoIwai2013] for some X T_pmathcal M as\n\n    mathcal T^mathrmS(X) = fraclVert XrVert_plVert mathcal T(X)rVert_qmathcal T(X)\n\nNote that the resulting point q has to be known, i.e. for vector_transport_direction the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the vector_transport_to\n\nConstructor\n\nScaledVectorTransport(m::AbstractVectorTransportMethod)\n\n[SatoIwai2013]: Sato, H., Iwai, T.: A new, globally convergent Riemannian conjugate gradient method, Optimization, 2013, Volume 64(4), pp. 1011‚Äì1031. doi: 10.1080/02331934.2013.836650, arXiv: 1302.0125.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.SchildsLadderTransport","page":"Vector transports","title":"ManifoldsBase.SchildsLadderTransport","text":"SchildsLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use schilds_ladder as vector transport method within vector_transport_to, vector_transport_direction, or vector_transport_along, i.e.\n\nLet X T_pmathcal M be a tangent vector at pmathcal M and qmathcal M the point to transport to. Then\n\nP^mathrmS_qgets p(X) =\n    log_qbigl( operatornameretr_p ( 2operatornameretr_p^-1c ) bigr)\n\nwhere c is the mid point between q and d=exp_pX.\n\nThis method employs the internal function schilds_ladder(M, p, d, q) that avoids leaving the manifold.\n\nThe name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [EhlersPiraniSchild1972].\n\nConstructor\n\nSchildsLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical Schilds ladder that employs exp and log, i.e. as proposed in[EhlersPiraniSchild1972]. For an even cheaper transport these inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n[EhlersPiraniSchild1972]: Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O‚ÄôRaifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63‚Äì84. Clarendon Press, Oxford (1972). reprint doi: 10.1007/s10714-012-1353-4\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportDirection","page":"Vector transports","title":"ManifoldsBase.VectorTransportDirection","text":"VectorTransportDirection{VM<:AbstractVectorTransportMethod,RM<:AbstractRetractionMethod}\n    <: AbstractVectorTransportMethod\n\nSpecify a vector_transport_direction using a AbstractVectorTransportMethod with explicitly using the AbstractRetractionMethod to determine the point in the specified direction where to transsport to. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportTo","page":"Vector transports","title":"ManifoldsBase.VectorTransportTo","text":"VectorTransportTo{VM<:AbstractVectorTransportMethod,RM<:AbstractRetractionMethod}\n    <: AbstractVectorTransportMethod\n\nSpecify a vector_transport_to using a AbstractVectorTransportMethod with explicitly using the AbstractInverseRetractionMethod to determine the direction that transports from  in pto q. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportWithKeywords","page":"Vector transports","title":"ManifoldsBase.VectorTransportWithKeywords","text":"VectorTransportWithKeywords{V<:AbstractVectorTransportMethod, K} <: AbstractVectorTransportMethod\n\nSince vector transports might have keywords, this type is a way to set them as an own type to be used as a specific vector transport. Another reason for this type is that we dispatch on the vector transport first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\nvector_transport the vector transport that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nVectorTransportWithKeywords(m::T; kwargs...) where {T <: AbstractVectorTransportMethod}\n\nSpecify the subtype T <:AbstractVectorTransportMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#Functions-to-implement-(on-Layer-III)","page":"Vector transports","title":"Functions to implement (on Layer III)","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"While you should always add your documentation to the first layer vector transport methods above when implementing new manifolds, the actual implementation happens on the following functions on layer III.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Modules = [ManifoldsBase]\nPages = [\"vector_transport.jl\"]\nOrder = [:function]\nPublic = false\nPrivate = true","category":"page"},{"location":"vector_transports/#ManifoldsBase.pole_ladder","page":"Vector transports","title":"ManifoldsBase.pole_ladder","text":"pole_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q);\n    retraction=default_retraction_method(M, typeof(p)),\n    inverse_retraction=default_inverse_retraction_method(M, typeof(p))\n)\n\nCompute an inner step of the pole ladder, that can be used as a vector_transport_to. Let c = gamma_pq(frac12) mid point between p and q, then the pole ladder is given by\n\n    operatornamePl(pdq) = operatornameretr_d (2operatornameretr_d^-1c)\n\nWhere the classical pole ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nWhen you have X=log_pd and Y = -log_q operatornamePl(pdq), you will obtain the PoleLadderTransport. When performing multiple steps, this method avoids the switching to the tangent space. Keep in mind that after n successive steps the tangent vector reads Y_n = (-1)^nlog_q operatornamePl(p_n-1d_n-1p_n).\n\nIt is cheaper to evaluate than schilds_ladder, sinc if you want to form multiple ladder steps between p and q, but with different d, there is just one evaluation of a geodesic each., since the center c can be reused.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.pole_ladder!","page":"Vector transports","title":"ManifoldsBase.pole_ladder!","text":"pole_ladder(\n    M,\n    pl,\n    p,\n    d,\n    q,\n    c = mid_point(M, p, q),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nCompute the pole_ladder, i.e. the result is saved in pl. X is used for storing intermediate inverse retraction.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.schilds_ladder","page":"Vector transports","title":"ManifoldsBase.schilds_ladder","text":"schilds_ladder(\n    M,\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nPerform an inner step of schilds ladder, which can be used as a vector_transport_to, see SchildsLadderTransport. Let c = gamma_qd(frac12) denote the mid point on the shortest geodesic connecting q and the point d. Then Schild's ladder reads as\n\noperatornameSl(pdq) = operatornameretr_x( 2operatornameretr_p^-1 c)\n\nWhere the classical Schilds ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nIn consistency with pole_ladder you can change the way the mid point is computed using the optional parameter c, but note that here it's the mid point between q and d.\n\nWhen you have X=log_pd and Y = log_q operatornameSl(pdq), you will obtain the PoleLadderTransport. Then the approximation to the transported vector is given by log_qoperatornameSl(pdq).\n\nWhen performing multiple steps, this method avoidsd the switching to the tangent space. Hence after n successive steps the tangent vector reads Y_n = log_q operatornamePl(p_n-1d_n-1p_n).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.schilds_ladder!","page":"Vector transports","title":"ManifoldsBase.schilds_ladder!","text":"schilds_ladder!(\n    M,\n    sl\n    p,\n    d,\n    q,\n    c = mid_point(M, q, d),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nCompute schilds_ladder and return the value in the parameter sl. If the required mid point c was computed before, it can be passed using c, and the allocation of new memory can be avoided providing a tangent vector X for the interims result.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along_diff!-Tuple{AbstractManifold, Vararg{Any, 5}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along_diff!","text":"vector_transport_along_diff!(M::AbstractManifold, Y, p, X, c, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M along the curve c using the differential of the AbstractRetractionMethod m in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along_diff","text":"vector_transport_along_diff(M::AbstractManifold, p, X, c, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M along the curve c using the differential of the AbstractRetractionMethod m.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along_project!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along_project!","text":"vector_transport_along_project!(M::AbstractManifold, Y, p, X, c::AbstractVector)\n\nCompute the vector transport of X from T_pmathcal M along the curve c using a projection. The result is computed in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_along_project-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Vector transports","title":"ManifoldsBase.vector_transport_along_project","text":"vector_transport_along_project(M::AbstractManifold, p, X, c::AbstractVector)\n\nCompute the vector transport of X from T_pmathcal M along the curve c using a projection.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction_diff!","text":"vector_transport_direction_diff!(M::AbstractManifold, Y, p, X, d, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M into the direction d using the differential of the AbstractRetractionMethod m in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction_diff","text":"vector_transport_direction_diff(M::AbstractManifold, p, X, d, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M into the direction d using the differential of the AbstractRetractionMethod m.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Vararg{Any, 5}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_diff!","text":"vector_transport_to_diff(M::AbstractManifold, p, X, q, r)\n\nCompute a vector transport by using a DifferentiatedRetractionVectorTransport r in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_diff-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_diff","text":"vector_transport_to_diff(M::AbstractManifold, p, X, q, r)\n\nCompute a vector transport by using a DifferentiatedRetractionVectorTransport r.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_project!","text":"vector_transport_to_project!(M::AbstractManifold, Y, p, X, q)\n\nCompute a vector transport by projecting Xin T_pmathcal M onto the tangent space T_qmathcal M at q in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_project-Tuple{AbstractManifold, Any, Any, Any}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_project","text":"vector_transport_to_project(M::AbstractManifold, p, X, q)\n\nCompute a vector transport by projecting Xin T_pmathcal M onto the tangent space T_qmathcal M at q.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#sec-retractions","page":"Retractions","title":"Retractions and inverse Retractions","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The exponential and logarithmic map might be too expensive to evaluate or not be available in a very stable numerical way on certain manifolds mathcal M. Retractions provide a possibly cheap, fast and stable alternative.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"A retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfils (for all pinmathcal M) that","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"operatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M to T_pmathcal M is the identity map,","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"i.e. Doperatornameretr_p(0)X=X holds for all Xin T_pmathcal M,","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"where Doperatornameretr_p denotes the differential of the retraction.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"A retraction operatornameretr_p can be interpreted as a first order approximation to the exponential map exp_p.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The following figure compares the exponential map exp(M, p, X) on the Circle (‚ÑÇ) (or Sphere(1) embedded in ‚Ñù^2 with one possible retraction, the one based on projections. Note especially that operatornamedist(pq)=lVert XrVert_p while this is not the case for the result operatornameretr_p(X) = q.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"(Image: A comparison of the exponential map and a retraction on the Circle.)","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"Similar to the exponential map the retraction might not be globally invertible, but locally it is. So locally one can define the inverse retraction operatornameretr_p^-1colon mathcal M to T_pmathcal M, which can be seen as a first order approximation to the logarithmic map. Within the ManifoldsBase.jl interface the inverse retraction is called inverse_retract.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The general interface looks as follows.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\", \"shooting.jl\"]\nOrder = [:function]\nPrivate = false\nPublic = true","category":"page"},{"location":"retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::AbstractManifold)\ndefault_inverse_retraction_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractInverseRetractionMethod that is used when calling inverse_retract without specifying the inverse retraction method. By default, this is the LogarithmicInverseRetraction.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different inverse retraction methods.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::AbstractManifold)\ndefault_retraction_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractRetractionMethod that is used when calling retract without specifying the retraction method. By default, this is the ExponentialRetraction.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different retraction methods.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract","page":"Retractions","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractManifold, p, q)\ninverse_retract(M::AbstractManifold, p, q, method::AbstractInverseRetractionMethod\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). For available inverse retractions on certain manifolds see the documentation on the corresponding manifold.\n\nSee also retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.inverse_retract!","page":"Retractions","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::AbstractManifold, X, p, q[, method::AbstractInverseRetractionMethod])\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M. Result is saved to X.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee also retract!.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract","page":"Retractions","title":"ManifoldsBase.retract","text":"retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\nretract(M::AbstractManifold, p, X, t::Number=1, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold M.\n\nA retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfils\n\noperatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M to T_pmathcal M is the identity map,\n\ni.e. Doperatornameretr_p(0)X=X holds for all Xin T_pmathcal M,\n\nwhere Doperatornameretr_p denotes the differential of the retraction\n\nThe retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). For further available retractions see the documentation of respective manifolds.\n\nLocally, the retraction is invertible. For the inverse operation, see inverse_retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract!","page":"Retractions","title":"ManifoldsBase.retract!","text":"retract!(M::AbstractManifold, q, p, X)\nretract!(M::AbstractManifold, q, p, X, t::Real=1)\nretract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod)\nretract!(M::AbstractManifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)\n\nCompute a retraction, a cheaper, approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold manifold M. Result is saved to q.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee retract for more details.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#Types-of-Retractions","page":"Retractions","title":"Types of Retractions","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"To distinguish different types of retractions, the last argument of the retraction as well as its inverse specifies a type. The following ones are available.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\", \"shooting.jl\"]\nOrder = [:type]","category":"page"},{"location":"retractions/#ManifoldsBase.AbstractInverseRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.AbstractRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ApproximateInverseRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateInverseRetraction","text":"ApproximateInverseRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate inverse retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ApproximateRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateRetraction","text":"ApproximateRetraction <: AbstractRetractionMethod\n\nAn abstract type for representing approximate retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.CayleyInverseRetraction","page":"Retractions","title":"ManifoldsBase.CayleyInverseRetraction","text":"CayleyInverseRetraction <: AbstractInverseRetractionMethod\n\nA retraction based on the Cayley transform, which is realized by using the PadeRetraction{1}.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, CayleyInverseRetraction()), to implement an inverse caley retraction, define inverse_retract_cayley(M, p, q) or inverse_retract_cayley!(M, X, p, q) for your manifold M. By default both these functions fall back to calling a PadeInverseRetraction(1).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.CayleyRetraction","page":"Retractions","title":"ManifoldsBase.CayleyRetraction","text":"CayleyRetraction <: AbstractRetractionMethod\n\nA retraction based on the Cayley transform, which is realized by using the PadeRetraction{1}.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, CayleyRetraction()), to implement a caley retraction, define retract_cayley(M, p, X, t) or retract_cayley!(M, q, p, X, t) for your manifold M. By default both these functions fall back to calling a PadeRetraction(1).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.EmbeddedInverseRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedInverseRetraction","text":"EmbeddedInverseRetraction{T<:AbstractInverseRetractionMethod} <: AbstractInverseRetractionMethod\n\nCompute an inverse retraction by using the inverse retraction of type T in the embedding and projecting the result\n\nConstructor\n\nEmbeddedInverseRetraction(r::AbstractInverseRetractionMethod)\n\nGenerate the inverse retraction with inverse retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.EmbeddedRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedRetraction","text":"EmbeddedRetraction{T<:AbstractRetractionMethod} <: AbstractRetractionMethod\n\nCompute a retraction by using the retraction of type T in the embedding and projecting the result.\n\nConstructor\n\nEmbeddedRetraction(r::AbstractRetractionMethod)\n\nGenerate the retraction with retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ExponentialRetraction","page":"Retractions","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction <: AbstractRetractionMethod\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.InverseRetractionWithKeywords","page":"Retractions","title":"ManifoldsBase.InverseRetractionWithKeywords","text":"InverseRetractionWithKeywords{R<:AbstractRetractionMethod,K} <: AbstractInverseRetractionMethod\n\nSince inverse retractions might have keywords, this type is a way to set them as an own type to be used as a specific inverse retraction. Another reason for this type is that we dispatch on the inverse retraction first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\ninverse_retraction the inverse retraction that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nInverseRetractionWithKeywords(m::T; kwargs...) where {T <: AbstractInverseRetractionMethod}\n\nSpecify the subtype T <:AbstractInverseRetractionMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.LogarithmicInverseRetraction","page":"Retractions","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.NLSolveInverseRetraction","page":"Retractions","title":"ManifoldsBase.NLSolveInverseRetraction","text":"NLSolveInverseRetraction{T<:AbstractRetractionMethod,TV,TK} <:\n    ApproximateInverseRetraction\n\nAn inverse retraction method for approximating the inverse of a retraction using NLsolve.\n\nConstructor\n\nNLSolveInverseRetraction(\n    method::AbstractRetractionMethod[, X0];\n    project_tangent=false,\n    project_point=false,\n    nlsolve_kwargs...,\n)\n\nConstructs an approximate inverse retraction for the retraction method with initial guess X0, defaulting to the zero vector. If project_tangent is true, then the tangent vector is projected before the retraction using project. If project_point is true, then the resulting point is projected after the retraction. nlsolve_kwargs are keyword arguments passed to NLsolve.nlsolve.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ODEExponentialRetraction","page":"Retractions","title":"ManifoldsBase.ODEExponentialRetraction","text":"ODEExponentialRetraction{T<:AbstractRetractionMethod, B<:AbstractBasis} <: AbstractRetractionMethod\n\nApproximate the exponential map on the manifold by evaluating the ODE descripting the geodesic at 1, assuming the default connection of the given manifold by solving the ordinary differential equation\n\nfracd^2dt^2 p^k + Œì^k_ij fracddt p_i fracddt p_j = 0\n\nwhere Œì^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed.\n\nConstructor\n\nODEExponentialRetraction(\n    r::AbstractRetractionMethod,\n    b::AbstractBasis=DefaultOrthogonalBasis(),\n)\n\nGenerate the retraction with a retraction to use internally (for some approaches) and a basis for the tangent space(s).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PadeInverseRetraction","page":"Retractions","title":"ManifoldsBase.PadeInverseRetraction","text":"PadeInverseRetraction{m} <: AbstractInverseRetractionMethod\n\nAn inverse retraction based on the Pad√© approximation of order m for the retraction.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, PadeInverseRetraction(m)), to implement an inverse Pad√© retraction, define inverse_retract_pade(M, p, q, m) or inverse_retract_pade!(M, X, p, q, m) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PadeRetraction","page":"Retractions","title":"ManifoldsBase.PadeRetraction","text":"PadeRetraction{m} <: AbstractRetractionMethod\n\nA retraction based on the Pad√© approximation of order m\n\nConstructor\n\nPadeRetraction(m::Int)\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, PadeRetraction(m)), to implement a Pad√© retraction, define retract_pade(M, p, X, t, m) or retract_pade!(M, q, p, X, t, m) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PolarInverseRetraction","page":"Retractions","title":"ManifoldsBase.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, PolarInverseRetraction()), to implement an inverse polar retraction, define inverse_retract_polar(M, p, q) or inverse_retract_polar!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PolarRetraction","page":"Retractions","title":"ManifoldsBase.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vectors.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, PolarRetraction()), to implement a polar retraction, define retract_polar(M, p, X, t) or retract_polar!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ProjectionInverseRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, ProjectionInverseRetraction()), to implement an inverse projection retraction, define inverse_retract_project(M, p, q) or inverse_retract_project!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ProjectionRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, ProjectionRetraction()), to implement a projection retraction, define retract_project(M, p, X, t) or retract_project!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.QRInverseRetraction","page":"Retractions","title":"ManifoldsBase.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, QRInverseRetraction()), to implement an inverse QR retraction, define inverse_retract_qr(M, p, q) or inverse_retract_qr!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.QRRetraction","page":"Retractions","title":"ManifoldsBase.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, QRRetraction()), to implement a QR retraction, define retract_qr(M, p, X, t) or retract_qr!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.RetractionWithKeywords","page":"Retractions","title":"ManifoldsBase.RetractionWithKeywords","text":"RetractionWithKeywords{R<:AbstractRetractionMethod,K} <: AbstractRetractionMethod\n\nSince retractions might have keywords, this type is a way to set them as an own type to be used as a specific retraction. Another reason for this type is that we dispatch on the retraction first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\nretraction the retraction that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nRetractionWithKeywords(m::T; kwargs...) where {T <: AbstractRetractionMethod}\n\nSpecify the subtype T <:AbstractRetractionMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.SoftmaxInverseRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxInverseRetraction","text":"SoftmaxInverseRetraction <: AbstractInverseRetractionMethod\n\nDescribes an inverse retraction that is based on the softmax function.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, SoftmaxInverseRetraction()), to implement an inverse softmax retraction, define inverse_retract_softmax(M, p, q) or inverse_retract_softmax!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.SoftmaxRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxRetraction","text":"SoftmaxRetraction <: AbstractRetractionMethod\n\nDescribes a retraction that is based on the softmax function.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, SoftmaxRetraction()), to implement a softmax retraction, define retract_softmax(M, p, X, t) or retract_softmax!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ShootingInverseRetraction","page":"Retractions","title":"ManifoldsBase.ShootingInverseRetraction","text":"ShootingInverseRetraction <: ApproximateInverseRetraction\n\nApproximating the inverse of a retraction using the shooting method.\n\nThis implementation of the shooting method works by using another inverse retraction to form the first guess of the vector. This guess is updated by shooting the vector, guessing the vector pointing from the shooting result to the target point, and transporting this vector update back to the initial point on a discretized grid. This process is repeated until the norm of the vector update falls below a specified tolerance or the maximum number of iterations is reached.\n\nFields\n\nretraction::AbstractRetractionMethod: The retraction whose inverse is approximated.\ninitial_inverse_retraction::AbstractInverseRetractionMethod: The inverse retraction used   to form the initial guess of the vector.\nvector_transport::AbstractVectorTransportMethod: The vector transport used to transport   the initial guess of the vector.\nnum_transport_points::Int: The number of discretization points used for vector   transport in the shooting method. 2 is the minimum number of points, including just the   endpoints.\ntolerance::Real: The tolerance for the shooting method.\nmax_iterations::Int: The maximum number of iterations for the shooting method.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#The-functions-on-layer-3","page":"Retractions","title":"The functions on layer 3","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"While you should always add your documentation to retract or retract! when implementing new manifolds, the actual implementation happens on the following functions on layer III.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"Modules = [ManifoldsBase]\nPages = [\"retractions.jl\", \"shooting.jl\"]\nOrder = [:function]\nPublic = false\nPrivate = true","category":"page"},{"location":"retractions/#ManifoldsBase.inverse_retract_cayley!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_cayley!","text":"inverse_retract_cayley!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the CayleyInverseRetraction, which by default calls the first order [PadeInverseRetraction¬ß(@ref).\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_cayley-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_cayley","text":"inverse_retract_cayley(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the CayleyInverseRetraction, which by default allocates and calls inverse_retract_cayley!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_embedded!-Tuple{AbstractManifold, Any, Any, Any, AbstractInverseRetractionMethod}","page":"Retractions","title":"ManifoldsBase.inverse_retract_embedded!","text":"inverse_retract_embedded!(M::AbstractManifold, X, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the in-place variant of the EmbeddedInverseRetraction using the AbstractInverseRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_embedded-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}","page":"Retractions","title":"ManifoldsBase.inverse_retract_embedded","text":"inverse_retract_embedded(M::AbstractManifold, p, q, m::AbstractInverseRetractionMethod)\n\ncomputes the allocating variant of the EmbeddedInverseRetraction using the AbstractInverseRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_nlsolve!-Tuple{AbstractManifold, Any, Any, Any, NLSolveInverseRetraction}","page":"Retractions","title":"ManifoldsBase.inverse_retract_nlsolve!","text":"inverse_retract_nlsolve!(M::AbstractManifold, X, p, q, m::NLSolveInverseRetraction)\n\nCompute the in-place variant of the NLSolveInverseRetraction m.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_nlsolve-Tuple{AbstractManifold, Any, Any, NLSolveInverseRetraction}","page":"Retractions","title":"ManifoldsBase.inverse_retract_nlsolve","text":"inverse_retract_nlsolve(M::AbstractManifold, p, q, m::NLSolveInverseRetraction)\n\ncomputes the allocating variant of the NLSolveInverseRetraction m, which by default allocates and calls inverse_retract_nlsolve!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_pade!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_pade!","text":"inverse_retract_pade!(M::AbstractManifold, p, q, n)\n\nCompute the in-place variant of the PadeInverseRetraction(n),\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_pade-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_pade","text":"inverse_retract_pade(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PadeInverseRetraction(n), which by default allocates and calls inverse_retract_pade!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_polar!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_polar!","text":"inverse_retract_polar!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the PolarInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_polar-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_polar","text":"inverse_retract_polar(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the PolarInverseRetraction, which by default allocates and calls inverse_retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_project!","text":"inverse_retract_project!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the ProjectionInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_project-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_project","text":"inverse_retract_project(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the ProjectionInverseRetraction, which by default allocates and calls inverse_retract_project!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_qr!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_qr!","text":"inverse_retract_qr!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the QRInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_qr-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_qr","text":"inverse_retract_qr(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the QRInverseRetraction, which by default allocates and calls inverse_retract_qr!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_softmax!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_softmax!","text":"inverse_retract_softmax!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the SoftmaxInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_softmax-Tuple{AbstractManifold, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_softmax","text":"inverse_retract_softmax(M::AbstractManifold, p, q)\n\ncomputes the allocating variant of the SoftmaxInverseRetraction, which by default allocates and calls inverse_retract_softmax!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_cayley!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_cayley!","text":"retract_cayley!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the CayleyRetraction, which by default falls back to calling the first order PadeRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_cayley-Tuple{AbstractManifold, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_cayley","text":"retract_cayley(M::AbstractManifold, p, X, t::Number)\n\nCompute the allocating variant of the CayleyRetraction, which by default allocates and calls retract_cayley!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_embedded!-Tuple{AbstractManifold, Any, Any, Any, Number, AbstractRetractionMethod}","page":"Retractions","title":"ManifoldsBase.retract_embedded!","text":"retract_embedded!(M::AbstractManifold, q, p, X, t::Number, m::AbstractRetractionMethod)\n\nCompute the in-place variant of the EmbeddedRetraction using the AbstractRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_embedded-Tuple{AbstractManifold, Any, Any, Number, AbstractRetractionMethod}","page":"Retractions","title":"ManifoldsBase.retract_embedded","text":"retract_embedded(M::AbstractManifold, p, X, t::Number, m::AbstractRetractionMethod)\n\ncomputes the allocating variant of the EmbeddedRetraction using the AbstractRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_exp_ode!-Tuple{AbstractManifold, Any, Any, Any, Number, AbstractRetractionMethod, ManifoldsBase.AbstractBasis}","page":"Retractions","title":"ManifoldsBase.retract_exp_ode!","text":"retract_exp_ode!(M::AbstractManifold, q, p, X, t::Number, m::AbstractRetractionMethod, B::AbstractBasis)\n\nCompute the in-place variant of the ODEExponentialRetraction(m, B).\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_exp_ode-Tuple{AbstractManifold, Any, Any, Number, AbstractRetractionMethod, ManifoldsBase.AbstractBasis}","page":"Retractions","title":"ManifoldsBase.retract_exp_ode","text":"retract_exp_ode(M::AbstractManifold, p, q, m::AbstractRetractionMethod, B::AbstractBasis)\n\nCompute the allocating variant of the ODEExponentialRetraction(m,B), which by default allocates and calls retract_exp_ode!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_pade!-Tuple{AbstractManifold, Any, Any, Any, Number, PadeRetraction}","page":"Retractions","title":"ManifoldsBase.retract_pade!","text":"retract_pade!(M::AbstractManifold, q, p, X, t::Number, m::PadeRetraction)\n\nCompute the in-place variant of the PadeRetraction m.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_pade-Tuple{AbstractManifold, Any, Any, Number, PadeRetraction}","page":"Retractions","title":"ManifoldsBase.retract_pade","text":"retract_pade(M::AbstractManifold, p, X, t::Number, m::PadeRetraction)\n\nCompute the allocating variant of the PadeRetraction m, which by default allocates and calls retract_pade!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_polar!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_polar!","text":"retract_polar!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the PolarRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_polar-Tuple{AbstractManifold, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_polar","text":"retract_polar(M::AbstractManifold, p, X, t::Number)\n\ncomputes the allocating variant of the PolarRetraction, which by default allocates and calls retract_polar!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_project!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_project!","text":"retract_project!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_project-Tuple{AbstractManifold, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_project","text":"retract_project(M::AbstractManifold, p, X, t::Number)\n\nCompute the allocating variant of the ProjectionRetraction, which by default allocates and calls retract_project!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_qr!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_qr!","text":"retract_qr!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the QRRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_qr-Tuple{AbstractManifold, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_qr","text":"retract_qr(M::AbstractManifold, p, X, t::Number)\n\nCompute the allocating variant of the QRRetraction, which by default allocates and calls retract_qr!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_softmax!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_softmax!","text":"retract_softmax!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the SoftmaxRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_softmax-Tuple{AbstractManifold, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_softmax","text":"retract_softmax(M::AbstractManifold, p, X, t::Number)\n\nCompute the allocating variant of the SoftmaxRetraction, which by default allocates and calls retract_softmax!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_shooting-Tuple{AbstractManifold, Any, Any, ShootingInverseRetraction}","page":"Retractions","title":"ManifoldsBase.inverse_retract_shooting","text":"inverse_retract_shooting(M::AbstractManifold, p, q, m::ShootingInverseRetraction)\n\nApproximate the inverse of a retraction using the shooting method.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design","page":"Design principles","title":"Main Design Principles","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from Manopt.jl can be implemented on arbitrary manifolds.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The main design criteria for the interface are:","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Aims to also provide efficient global state-free, both in-place and out-of-place computations whenever possible.\nProvide a high level interface that is easy to use.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Therefore this interface has 3 main features, that we will explain using two (related) concepts, the exponential map that maps a tangent vector X at a point p to a point q or mathematically exp_pT_pmathcal M to mathcal M and its generalization, a retraction operatornameretr_p with the same domain and range.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"You do not need to know their exact definition at this point, just that there is one exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (called ExponentialRetraction for completeness). Every retraction has its own subtype of the AbstractRetractionMethod that uniquely defines it.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The following three design patterns aim to fulfil the criteria from above, while also avoiding ambiguities in multiple dispatch using the dispatch on one argument at a time approach.","category":"page"},{"location":"design/#General-order-of-parameters","page":"Design principles","title":"General order of parameters","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for in-place functions. Then the classical parameters of a function (for example a point and a tangent vector for the retraction) follow and the final part are parameters to further dispatch on, which usually have their defaults.","category":"page"},{"location":"design/#A-3-Layer-architecture-for-dispatch","page":"Design principles","title":"A 3-Layer architecture for dispatch","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The general architecture consists of three layers","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The high level interface for ease of use ‚Äì and to dispatch on other manifolds.\nThe intermediate layer to dispatch on different parameters in the last section, e.g. type of retraction or vector transport.\nThe lowest layer for specific manifolds to dispatch on different types of points and tangent vectors. Usually this layer with a specific manifold and no optional parameters.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"These three layers are described in more detail in the following. The main motivation to introduce these layers is, that it reduces method ambiguities. It also provides a good structure where to implement extensions to this interface.","category":"page"},{"location":"design/#design-layer1","page":"Design principles","title":"Layer I: The high level interface and ease of use","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The highest layer for convenience of decorators. A usual scheme is, that a manifold might assume several things implicitly, for example the default implementation of the sphere mathbb S^n using unit vectors in mathbb R^n+1. The embedding can be explicitly used to avoid re-implementations ‚Äì the inner product can be ‚Äúpassed on‚Äù to its embedding.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To do so, we ‚Äúdecorate‚Äù the manifold by making it an AbstractDecoratorManifold and activating the right traits see the tutorial How to Implement a Manifold.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The explicit case of the EmbeddedManifold can be used to distinguish different embeddings of a manifold, but also their dispatch (onto the manifold or its embedding, depending on the type of embedding) happens here.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Note that all other parameters of a function should be as least typed as possible for all parameters besides the manifold. With respect to the dispatch on one argument at a time paradigm, this layer dispatches the manifold first. We also stay as abstract as possible, for example on the AbstractManifold level if possible.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"If a function has optional positional arguments, (like retract) their default values might be filled/provided on this layer. This layer ends usually in calling the same functions like retract but prefixed with a _ to enter Layer II.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nUsually only functions from this layer are exported from the interface, since these are the ones one should use for generic implementations. If you implement your own manifold, import the necessary lower layer functions as needed.","category":"page"},{"location":"design/#design-layer2","page":"Design principles","title":"Layer II: An internal dispatch interface for parameters","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This layer is an interims layer to dispatch on the (optional/default) parameters of a function. For example the last parameter of retraction: retract determines the type (variant) to be used. The last function in the previous layer calls _retract, which is an internal function. These parameters are usually the last parameters of a function.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"On this layer, e.g. for _retract only these last parameters should be typed, the manifold should stay at the AbstractManifold level. The layer dispatches on different functions per existing parameter type (and might pass this one further on, if it has fields). Function definitions on this layer should only be extended when introducing new such parameter types, for example when introducing a new type of a retraction.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The functions from this layer should never be called directly, are hence also not exported and carry the _ prefix. They should only be called as the final step in the previous layer.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"If the default parameters are not dispatched per type, using _ might be skipped. The same holds for functions that do not have these parameters. The following resolution might even be seen as a last step in layer I or the resolution here in layer II.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"exp(M::AbstractManifold, p, X, t::Real) = exp(M, p, t * X)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"When there is no dispatch for different types of the optional parameter (here t), the _ might be skipped. One could hence see the last code line as a definition on Layer I that passes directly to Layer III, since there are not parameter to dispatch on.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To close this section, let‚Äòs look at an example. The high level (or Layer I) definition of the retraction is given by","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"retract(M::AbstractManifold, p, X, m::AbstractRetractionMethod=default_retraction_method(M, typeof(p))) = _retract(M, p, X, m)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This level now dispatches on different retraction types m. It usually passes to specific functions implemented in Layer III, here for example","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"_retract(M::AbstractManifold, p, X, m::Exponentialretraction) = exp(M, p, X)\n_retract(M::AbstractManifold, p, X, m::PolarRetraction) = retract_polar(M, p, X)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"where the ExponentialRetraction is resolved by again calling a function on Layer I (to fill futher default values if these exist). The PolarRetraction is dispatched to retract_polar, a function on Layer III.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"For further details and dispatches, see retractions and inverse retractions for an overview.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nThe documentation should be attached to the high level functions, since this again fosters ease of use. If you implement a polar retraction, you should write a method of function retract_polar but the doc string should be attached to retract(::M, ::P, ::V, ::PolarRetraction) for your types ::M, ::P, ::V of the manifold, points and vectors, respectively.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the (optional) parameters second.","category":"page"},{"location":"design/#design-layer3","page":"Design principles","title":"Layer III: The base layer with focus on implementations","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This lower level aims for the actual implementation of the function avoiding ambiguities. It should have as few as possible optional parameters and as concrete as possible types for these.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This means","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"the function name should be similar to its high level parent (for example retract and retract_polar  above)\nThe manifold type in method signature should always be as narrow as possible.\nThe points/vectors should either be untyped (for the default representation or if there is only one implementation) or provide all type bounds (for second representations or when using AbstractManifoldPoint and TVector, respectively).","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The first step that often happens on this level is memory allocation and calling the in-place function. If faster, it might also implement the function at hand itself.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Usually functions from this layer are not exported, when they have an analogue on the first layer. For example the function retract_polar(M, p, X) is not exported, since when using the interface one would use the PolarRetraction or to be precise call retract(M, p, X, PolarRetraction()). When implementing your own manifold, you have to import functions like these anyway.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the concrete manifold and point/vector types last.","category":"page"},{"location":"design/#inplace-and-noninplace","page":"Design principles","title":"Mutating and allocating functions","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Every function, where this is applicable, should provide an in-place and an allocating variant. For example for the exponential map exp(M, p, X, t) returns a new point q where the result is computed in. On the other hand exp!(M, q, p, X, t) computes the result in place of q, where the design of the implementation should keep in mind that also exp!(M, p, p, X, t) should correctly overwrite p.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like exp is to allocate the resulting memory and call exp!.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nIt might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the in-place variants.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Non-mutating functions in ManifoldsBase.jl are typically implemented using in-place variants after a suitable allocation of memory.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Not that this allocation usually takes place only on Layer III when dispatching on points. Both Layer I and Layer II are usually implemented for both variants in parallel.","category":"page"},{"location":"design/#Allocation-of-new-points-and-vectors","page":"Design principles","title":"Allocation of new points and vectors","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The allocate function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), checked types like ValidationMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The function allocate_result allocates a correct return value. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the allocate_result_type function. The most prominent example of the usage of this function is the logarithmic function log when used with typed points. Lets assume on a manifold M the have points of type P and corresponding tangent vector types V. then the logarithmic map has the signature","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"log(::M, ::P, ::P)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"but the return type would be V, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by implementing a method allocate_result(::M, ::typeof(log), ::P, ::P) that returns the concrete variable for the result. This way, even with specific types, one just has to implement log! and the one line for the allocation.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nThis dispatch from the allocating to the in-place variant happens in Layer III, that is, functions like exp or retract_polar (but not retract itself) allocate their result (using ::typeof(retract) for the second function) and call the in-place variant exp! and retract_polar! afterwards.","category":"page"},{"location":"manifolds/#Manifolds","page":"Manifolds","title":"Manifolds","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"While the interface ManifoldsBase.jl does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds","category":"page"},{"location":"manifolds/#sec-power-manifold","page":"Manifolds","title":"(Abstract) power manifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"A power manifold is constructed like higher dimensional vector spaces are formed from the real line, just that for every point p = (p_1ldotsp_n)  mathcal M^n on the power manifold mathcal M^n the entries of p are points p_1ldotsp_n  mathcal M on some manifold mathcal M. Note that n can also be replaced by multiple values, such that p is not a vector but a matrix or a multi-index array of points.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"src/PowerManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"manifolds/#ManifoldsBase.AbstractPowerManifold","page":"Manifolds","title":"ManifoldsBase.AbstractPowerManifold","text":"AbstractPowerManifold{ùîΩ,M,TPR} <: AbstractManifold{ùîΩ}\n\nAn abstract AbstractManifold to represent manifolds that are build as powers of another AbstractManifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.AbstractPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.NestedPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is modified in-place, differently than in NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.NestedReplacingPowerRepresentation","page":"Manifolds","title":"ManifoldsBase.NestedReplacingPowerRepresentation","text":"NestedReplacingPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.PowerBasisData","page":"Manifolds","title":"ManifoldsBase.PowerBasisData","text":"PowerBasisData{TB<:AbstractArray}\n\nData storage for an array of basis data.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.PowerManifold","page":"Manifolds","title":"ManifoldsBase.PowerManifold","text":"PowerManifold{ùîΩ,TM<:AbstractManifold,TSize<:Tuple,TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{ùîΩ,TM}\n\nThe power manifold mathcal M^n_1 n_2    n_d with power geometry  TSize statically defines the number of elements along each axis.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.\n\nConstructor\n\nPowerManifold(M::PowerManifold, N_1, N_2, ..., N_d)\nPowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d)\nM^(N_1, N_2, ..., N_d)\n\nGenerate the power manifold M^N_1  N_2    N_d. By default, a [PowerManifold](@ref} is expanded further, i.e. for M=PowerManifold(N,3) PowerManifold(M,2) is equivalend to PowerManifold(N,3,2). Points are then 3√ó2 matrices of points on N. Providing a NestedPowerRepresentation as the second argument to the constructor can be used to nest manifold, i.e. PowerManifold(M,NestedPowerRepresentation(),2) represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.\n\nSince there is no default AbstractPowerRepresentation within this interface, the ^ operator is only available for PowerManifolds and concatenates dimensions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}","page":"Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, Y, p, X)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, B, a, A) for all elements A, a and B of X, p, and Y, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}","page":"Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, q, p)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, b, a) for all elements a and b of p and q, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"Base.exp","text":"exp(M::AbstractPowerManifold, p, X)\n\nCompute the exponential map from p in direction X on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.getindex","text":"getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\np[M::AbstractPowerManifold, i...]\n\nAccess the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"Base.log","text":"log(M::AbstractPowerManifold, p, q)\n\nCompute the logarithmic map from p to q on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.setindex!","text":"setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\nq[M::AbstractPowerManifold, i...] = p\n\nSet the element(s) at index [i...] of a point q on an AbstractPowerManifold M by linear or multidimensional indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Base.view-Tuple{AbstractArray, AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Manifolds","title":"Base.view","text":"view(p, M::PowerManifoldNested, i::Union{Integer,Colon,AbstractVector}...)\n\nGet the view of the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, p, X)\n\nCompute the norm of X from the tangent space of p on an AbstractPowerManifold M, i.e. from the element wise norms the Frobenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ùîΩ, <:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}","page":"Manifolds","title":"ManifoldsBase._allocate_access_nested","text":"_allocate_access_nested(M::PowerManifoldNested, y, i)\n\nHelper function for allocate_result on PowerManifoldNested. In allocation y can be a number in which case _access_nested wouldn't work.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractPowerManifold, p; kwargs...)\n\nCheck whether p is a valid point on an AbstractPowerManifold M, i.e. each element of p has to be a valid point on the base manifold. If p is not a point on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.check_power_size","text":"check_power_size(M, p)\ncheck_power_size(M, p, X)\n\nCheck whether p hase the right size to represent points on M generically, i.e. just cheking the overall sizes, not the individual ones per manifold\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractPowerManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p an the AbstractPowerManifold M, i.e. atfer check_point(M, p), and all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}","page":"Manifolds","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::PowerManifold)\n\nUse the default inverse retraction method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}","page":"Manifolds","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::PowerManifold)\n\nUse the default retraction method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}","page":"Manifolds","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::PowerManifold)\n\nUse the default vector transport method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q)\n\nCompute the distance between q and p on an AbstractPowerManifold, i.e. from the element wise distances the Forbenius norm is computed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.get_component","text":"get_component(M::AbstractPowerManifold, p, idx...)\n\nGet the component of a point p on an AbstractPowerManifold M at index idx.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, p])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point p it's equal to the minimum of all radii in the array entries.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Manifolds","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from X and Y are in the tangent space of the corresponding element from p. The inner product is then the sum of the elementwise inner products.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the inverse retraction from p with respect to q on an AbstractPowerManifold M using an AbstractInverseRetractionMethod. Then this method is performed elementwise, so the inverse retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}","page":"Manifolds","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractPowerManifold)\n\nReturn true if AbstractPowerManifold is flat. It is flat if and only if the wrapped manifold is flat.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.manifold_dimension-Union{Tuple{PowerManifold{ùîΩ, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}","page":"Manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1n_d, i.e. with n=(n_1n_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\ndim(mathcal N) = dim(mathcal M)prod_i=1^d n_i = n_1n_2cdotcdot n_d dim(mathcal M)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.power_dimensions-Union{Tuple{PowerManifold{ùîΩ, <:AbstractManifold, TSize}}, Tuple{TSize}, Tuple{ùîΩ}} where {ùîΩ, TSize}","page":"Manifolds","title":"ManifoldsBase.power_dimensions","text":"power_dimensions(M::PowerManifold)\n\nreturn the power of M,\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}","page":"Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p, X)\n\nProject the point X onto the tangent space at p on the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}","page":"Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p)\n\nProject the point p from the embedding onto the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, p, X, method::AbstractRetractionMethod)\n\nCompute the retraction from p with tangent vector X on an AbstractPowerManifold M using a AbstractRetractionMethod. Then this method is performed elementwise, so the retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}","page":"Manifolds","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractPowerManifold, p, X, Y, Z)\n\nCompute the Riemann tensor at point from p with tangent vectors X, Y and Z on the AbstractPowerManifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}","page":"Manifolds","title":"ManifoldsBase.set_component!","text":"set_component!(M::AbstractPowerManifold, q, p, idx...)\n\nSet the component of a point q on an AbstractPowerManifold M at index idx to p, which itself is a point on the AbstractManifold the power manifold is build on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}","page":"Manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nCompute the vector transport the tangent vector Xat p to q on the PowerManifold M using an AbstractVectorTransportMethod m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ValidationManifold","page":"Manifolds","title":"ValidationManifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"ValidationManifold is a simple decorator using the AbstractDecoratorManifold that ‚Äúdecorates‚Äù a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling is_point or is_vector whenever applicable.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"ValidationManifold.jl\"]\nOrder = [:macro, :type, :function]","category":"page"},{"location":"manifolds/#ManifoldsBase.ValidationCoTVector","page":"Manifolds","title":"ManifoldsBase.ValidationCoTVector","text":"ValidationCoTVector = ValidationFibreVector{CotangentSpaceType}\n\nRepresent a cotangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationFibreVector","page":"Manifolds","title":"ManifoldsBase.ValidationFibreVector","text":"ValidationFibreVector{TType<:VectorSpaceType} <: AbstractFibreVector{TType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationMPoint","page":"Manifolds","title":"ManifoldsBase.ValidationMPoint","text":"ValidationMPoint <: AbstractManifoldPoint\n\nRepresent a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationTVectors and ValidationCoTVectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationManifold","page":"Manifolds","title":"ManifoldsBase.ValidationManifold","text":"ValidationManifold{ùîΩ,M<:AbstractManifold{ùîΩ}} <: AbstractDecoratorManifold{ùîΩ}\n\nA manifold to encapsulate manifolds working on array representations of AbstractManifoldPoints and TVectors in a transparent way, such that for these manifolds it's not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a AbstractManifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationTVector","page":"Manifolds","title":"ManifoldsBase.ValidationTVector","text":"ValidationTVector = ValidationFibreVector{TangentSpaceType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"Manifolds","title":"ManifoldsBase.array_value","text":"array_value(p)\n\nReturn the internal array value of an ValidationMPoint, ValidationTVector, or ValidationCoTVector if the value p is encapsulated as such. Return p if it is already an array.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#DefaultManifold","page":"Manifolds","title":"DefaultManifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using Manifolds.jl the Euclidean is available, the DefaultManifold itself is not exported.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"ManifoldsBase.DefaultManifold","category":"page"},{"location":"manifolds/#ManifoldsBase.DefaultManifold","page":"Manifolds","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: AbstractManifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variables.\n\nConstructor\n\nDefaultManifold(n::Int...; field = ‚Ñù, parameter::Symbol = :field)\n\nArguments:\n\nn: shape of array representing points on the manifold.\nfield: field over which the manifold is defined. Either ‚Ñù, ‚ÑÇ or ‚Ñç.\nparameter: whether a type parameter should be used to store n. By default size is stored in a field. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#sec-embedded-manifold","page":"Manifolds","title":"Embedded manifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"The embedded manifold is a manifold mathcal M which is modelled explicitly specifying its embedding mathcal N in which the points and tangent vectors are represented. Most prominently is_point and is_vector of an embedded manifold are implemented to check whether the point is a valid point in the embedding. This can of course still be extended by further tests. ManifoldsBase.jl provides two possibilities of easily introducing this in order to dispatch some functions to the embedding.","category":"page"},{"location":"manifolds/#subsec-implicit-embedded","page":"Manifolds","title":"Implicit case: the IsEmbeddedManifold Trait","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"For the implicit case, your manifold has to be a subtype of the AbstractDecoratorManifold. Adding a method to the active_traits function for a manifold that returns an AbstractTrait IsEmbeddedManifold, makes that manifold an embedded manifold. You just have to also define get_embedding so that appropriate functions are passed on to that embedding. This is the implicit case, since the manifold type itself does not carry any information about the embedding, just the trait and the function definition do.","category":"page"},{"location":"manifolds/#subsec-explicit-embedded","page":"Manifolds","title":"Explicit case: the EmbeddedManifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"The EmbeddedManifold itself is an AbstractDecoratorManifold so it is a case of the implicit embedding itself, but internally stores both the original manifold and the embedding. They are also parameters of the type. This way, an additional embedding of one manifold in another can be modelled. That is, if the manifold is implemented using the implicit embedding approach from before but can also be implemented using a different embedding, then this method should be chosen, since you can dispatch functions that you want to implement in this embedding then on the type which explicitly has the manifold and its embedding as parameters.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Hence this case should be used for any further embedding after the first or if the default implementation works without an embedding and the alternative needs one.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"EmbeddedManifold.jl\"]\nOrder = [:type, :macro, :function]","category":"page"},{"location":"manifolds/#ManifoldsBase.EmbeddedManifold","page":"Manifolds","title":"ManifoldsBase.EmbeddedManifold","text":"EmbeddedManifold{ùîΩ, MT <: AbstractManifold, NT <: AbstractManifold} <: AbstractDecoratorManifold{ùîΩ}\n\nA type to represent an explicit embedding of a AbstractManifold M of type MT embedded into a manifold N of type NT. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold.\n\nnote: Note\nThis type is not required if a manifold M is to be embedded in one specific manifold N.  One can then just implement embed! and project!. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an AbstractDecoratorManifold. Only for a second ‚Äìmaybe considered non-default‚Äì embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings N.\n\nFields\n\nmanifold the manifold that is an embedded manifold\nembedding a second manifold, the first one is embedded into\n\nConstructor\n\nEmbeddedManifold(M, N)\n\nGenerate the EmbeddedManifold of the AbstractManifold M into the AbstractManifold N.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the manifold of M that is decorated with its embedding. For this specific type the internally stored enhanced manifold M.manifold is returned.\n\nSee also base_manifold, where this is used to (potentially) completely undecorate the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::EmbeddedManifold)\n\nReturn the embedding AbstractManifold N of M, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Metrics","page":"Manifolds","title":"Metrics","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Most metric-related functionality is currently defined in Manifolds.jl but a few basic types are defined here.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Modules = [ManifoldsBase]\nPages = [\"metric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/#ManifoldsBase.AbstractMetric","page":"Manifolds","title":"ManifoldsBase.AbstractMetric","text":"AbstractMetric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\nFunctor\n\n(metric::Metric)(M::AbstractManifold)\n(metric::Metric)(M::MetricManifold)\n\nGenerate the MetricManifold that wraps the manifold M with given metric. This works for both a variable containing the metric as well as a subtype T<:AbstractMetric, where a zero parameter constructor T() is availabe. If M is already a metric manifold, the inner manifold with the new metric is returned.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.EuclideanMetric","page":"Manifolds","title":"ManifoldsBase.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\nA general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\nSince the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the EuclideanMetric but where the field type of the manifold is ‚ÑÇ.\n\nThis metric is the default metric for example for the Euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.RiemannianMetric","page":"Manifolds","title":"ManifoldsBase.RiemannianMetric","text":"RiemannianMetric <: AbstractMetric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for X   T_p mathcal M, the inner product g(X X)  0 whenever X is not the zero vector.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_metric!","text":"change_metric!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)\n\nCompute the change_metric in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_metric","text":"change_metric(M::AbstractcManifold, G2::AbstractMetric, p, X)\n\nOn the AbstractManifold M with implicitly given metric g_1 and a second AbstractMetric g_2 this function performs a change of metric in the sense that it returns the tangent vector Z=BX such that the linear map B fulfills\n\ng_2(Y_1Y_2) = g_1(BY_1BY_2) quad textfor all  Y_1 Y_2  T_pmathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_representer!","text":"change_representer!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)\n\nCompute the change_metric in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_representer-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_representer","text":"change_representer(M::AbstractManifold, G2::AbstractMetric, p, X)\n\nConvert the representer X of a linear function (in other words a cotangent vector at p) in the tangent space at p on the AbstractManifold M given with respect to the AbstractMetric G2 into the representer with respect to the (implicit) metric of M.\n\nIn order to convert X into the representer with respect to the (implicitly given) metric g_1 of M, we have to find the conversion function c T_pmathcal M to T_pmathcal M such that\n\n    g_2(XY) = g_1(c(X)Y)\n\n\n\n\n\n","category":"method"},{"location":"bases/#bases","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"","category":"section"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The following functions and types provide support for bases of the tangent space of different manifolds. Moreover, bases of the cotangent space are also supported, though this description focuses on the tangent space. An orthonormal basis of the tangent space T_p mathcal M of (real) dimension n has a real-coefficient basis e_1 e_2  e_n if mathrmRe(g_p(e_i e_j)) = Œ¥_ij for each ij  1 2  n where g_p is the Riemannian metric at point p. A vector X from the tangent space T_p mathcal M can be expressed in Einstein notation as a sum X = X^i e_i, where (real) coefficients X^i are calculated as X^i = mathrmRe(g_p(X e_i)).","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main types are:","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"DefaultOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nCachedBasis, which stores (explicitly or implicitly) a precomputed basis at a certain point.","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main functions are:","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"Modules = [ManifoldsBase]\nPages = [\"bases.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"bases/#ManifoldsBase.AbstractBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractBasis","text":"AbstractBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents a basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.AbstractOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthogonalBasis","text":"AbstractOrthogonalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.AbstractOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.CachedBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.CachedBasis","text":"CachedBasis{ùîΩ,V,<:AbstractBasis{ùîΩ}} <: AbstractBasis{ùîΩ}\n\nA cached version of the given basis with precomputed basis vectors. The basis vectors are stored in data, either explicitly (like in cached variants of ProjectedOrthonormalBasis) or implicitly.\n\nConstructor\n\nCachedBasis(basis::AbstractBasis, data)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultBasis","text":"DefaultBasis{ùîΩ,VST<:VectorSpaceType}\n\nAn arbitrary basis of vector space of type VST on a manifold. This will usually be the fastest basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthogonalBasis","text":"DefaultOrthogonalBasis{ùîΩ,VST<:VectorSpaceType}\n\nAn arbitrary orthogonal basis of vector space of type VST on a manifold. This will usually be the fastest orthogonal basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthonormalBasis","text":"DefaultOrthonormalBasis(ùîΩ::AbstractNumbers = ‚Ñù, vs::VectorSpaceType = TangentSpace)\n\nAn arbitrary orthonormal basis of vector space of type VST on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DiagonalizingOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis{ùîΩ,TV} <: AbstractOrthonormalBasis{ùîΩ,TangentSpaceType}\n\nAn orthonormal basis Œû as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction frame_direction v has curvature 0.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nConstructor\n\nDiagonalizingOrthonormalBasis(frame_direction, ùîΩ::AbstractNumbers = ‚Ñù)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.GramSchmidtOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.GramSchmidtOrthonormalBasis","text":"GramSchmidtOrthonormalBasis{ùîΩ} <: AbstractOrthonormalBasis{ùîΩ}\n\nAn orthonormal basis obtained from a basis.\n\nConstructor\n\nGramSchmidtOrthonormalBasis(ùîΩ::AbstractNumbers = ‚Ñù)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.ProjectedOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, ùîΩ::AbstractNumbers = ‚Ñù)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter ùîΩ denotes the AbstractNumbers that will be used for the vectors elements.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.VectorSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space fiber is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector(fiber, p) to construct zero vectors at point p,\nallocate(X) and allocate(X, T) for vector X and type T,\ncopyto!(X, Y) for vectors X and Y,\nnumber_eltype(v) for vector v,\nvector_space_dimension.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject (for embedded vector spaces),\nrepresentation_size,\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.allocate_coordinates-Tuple{AbstractManifold, Any, Any, Int64}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocate_coordinates","text":"allocate_coordinates(M::AbstractManifold, p, T, n::Int)\n\nAllocate vector of coordinates of length n of type T of a vector at point p on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocation_promotion_function","text":"allocation_promotion_function(M::AbstractManifold, f, args::Tuple)\n\nDetermine the function that must be used to ensure that the allocated representation is of the right type. This is needed for get_vector when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.change_basis-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.change_basis","text":"change_basis(M::AbstractManifold, p, c, B_in::AbstractBasis, B_out::AbstractBasis)\n\nGiven a vector with coordinates c at point p from manifold M in basis B_in, compute coordinates of the same vector in basis B_out.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.coordinate_eltype-Union{Tuple{MùîΩ}, Tuple{AbstractManifold{MùîΩ}, Any, ManifoldsBase.AbstractNumbers}} where MùîΩ","page":"Bases for tangent spaces","title":"ManifoldsBase.coordinate_eltype","text":"coordinate_eltype(M::AbstractManifold{MùîΩ}, p, ùîΩ::AbstractNumbers) where {MùîΩ}\n\nGet the element type for ùîΩ-field coordinates of the tangent space at a point p from manifold M. This default assumes that usually complex bases of complex manifolds have real coordinates but it can be overridden by a more specific method.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.dual_basis","text":"dual_basis(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the dual basis to B, a basis of a vector space at point p from manifold M.\n\nThe dual to the ith vector v_i from basis B is a vector v^i from the dual space such that v^i(v_j) = Œ¥^i_j, where Œ¥^i_j is the Kronecker delta symbol:\n\nŒ¥^i_j = begincases\n1  text if  i=j \n0  text otherwise\nendcases\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_basis","text":"get_basis(M::AbstractManifold, p, B::AbstractBasis; kwargs...) -> CachedBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by p.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_coordinates-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractManifold, p, X, B::AbstractBasis)\nget_coordinates(M::AbstractManifold, p, X, B::CachedBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector X at point denoted by p on manifold M in basis B.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve. If a CachedBasis is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.\n\nFor the CachedBasis keep in mind that the reconstruction with get_vector requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_vector-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vector","text":"X = get_vector(M::AbstractManifold, p, c, B::AbstractBasis)\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at p on manifold M to a tangent vector X at p.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve.\n\nFor the CachedBasis keep in mind that the reconstruction from get_coordinates requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_coordinates, get_basis\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vectors","text":"get_vectors(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the basis vectors of basis B of the tangent space at point p.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.gram_schmidt-Union{Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, Any, ManifoldsBase.AbstractBasis{ùîΩ}}} where ùîΩ","page":"Bases for tangent spaces","title":"ManifoldsBase.gram_schmidt","text":"gram_schmidt(M::AbstractManifold{ùîΩ}, p, B::AbstractBasis{ùîΩ}) where {ùîΩ}\ngram_schmidt(M::AbstractManifold, p, V::AbstractVector)\n\nCompute an ONB in the tangent space at p on the [AbstractManifold](@ref} M from either an AbstractBasis basis ¬¥B¬¥ or a set of (at most) manifold_dimension(M) many vectors. Note that this method requires the manifold and basis to work on the same AbstractNumbers ùîΩ, i.e. with real coefficients.\n\nThe method always returns a basis, i.e. linearly dependent vectors are removed.\n\nKeyword arguments\n\nwarn_linearly_dependent (false) ‚Äì warn if the basis vectors are not linearly independent\nskip_linearly_dependent (false) ‚Äì whether to just skip (true) a vector that is linearly dependent to the previous ones or to stop (false, default) at that point\nreturn_incomplete_set (false) ‚Äì throw an error if the resulting set of vectors is not a basis but contains less vectors\n\nfurther keyword arguments can be passed to set the accuracy of the independence test. Especially atol is raised slightly by default to atol = 5*1e-16.\n\nReturn value\n\nWhen a set of vectors is orthonormalized a set of vectors is returned. When an AbstractBasis is orthonormalized, a CachedBasis is returned.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.hat","text":"hat(M::AbstractManifold, p, X‚Å±)\n\nGiven a basis e_i on the tangent space at a point p and tangent component vector X^i, compute the equivalent vector representation X=X^i e_i, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.number_of_coordinates-Union{Tuple{ùîæ}, Tuple{ùîΩ}, Tuple{AbstractManifold{ùîΩ}, ManifoldsBase.AbstractBasis{ùîæ}}} where {ùîΩ, ùîæ}","page":"Bases for tangent spaces","title":"ManifoldsBase.number_of_coordinates","text":"number_of_coordinates(M::AbstractManifold{ùîΩ}, B::AbstractBasis)\nnumber_of_coordinates(M::AbstractManifold{ùîΩ}, ::ùîæ)\n\nCompute the number of coordinates in basis of field type ùîæ on a manifold M. This also corresponds to the number of vectors represented by B, or stored within B in case of a CachedBasis.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"Bases for tangent spaces","title":"ManifoldsBase.number_system","text":"number_system(::AbstractBasis)\n\nThe number system for the vectors of the given basis.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.requires_caching-Tuple{ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.requires_caching","text":"requires_caching(B::AbstractBasis)\n\nReturn whether basis B can be used in get_vector and get_coordinates without calling get_basis first.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.vee","text":"vee(M::AbstractManifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldsBase.jl","page":"Home","title":"ManifoldsBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ManifoldsBase.jl is a lightweight interface for manifolds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This packages has two main purposes. You can add it as a dependency if you plan to work on manifolds (generically) or if you plan to define own manifolds in a package. For a package that (only) depends on ManifoldsBase.jl, see Manopt.jl, which implements optimization algorithms on manifolds using this interface. These optimisation algorithms can hence be used with any manifold implemented based on ManifoldsBase.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a library of manifolds implemented using this interface Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your package is using ManifoldsBase? We would like to add that here as well. Either write an issue or add yourself by forking, editing this file and opening a PR.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ManifoldsBase.jl in your work, please cite the following paper, which covers both the basic interface as well as the performance for Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@online{2106.08777,\n    Author = {Seth D. Axen and Mateusz Baran and Ronny Bergmann and Krzysztof Rzecki},\n    Title = {Manifolds.jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    Year = {2021},\n    Eprint = {2106.08777},\n    Eprinttype = {arXiv},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the citation is in BibLaTeX format.","category":"page"},{"location":"projections/#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"projections/","page":"Projections","title":"Projections","text":"A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex Circle is embedded in the complex plane. Let‚Äòs keep the circle in mind in the following as a simple example. For the general case of explicitly stating an embedding and/or to distinguish several, different embeddings, see Embedded Manifolds below.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"To make this a little more concrete, let‚Äòs assume we have a manifold mathcal M which is embedded in some manifold mathcal N and the image i(mathcal M) of the embedding function i is a closed set (with respect to the topology on mathcal N). Then we can do two kinds of projections.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"To make this concrete in an example for the Circle mathcal M=mathcal C =  p  ‚ÑÇ¬† p = 1 the embedding can be chosen to be the manifold mathcal N = ‚ÑÇ and due to our representation of mathcal C as complex numbers already, we have i(p) = p, that is the identity as the embedding function.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The first projection we can consider is for a given a point pmathcal N in the embedding we can look for the closest point on the manifold mathcal M, i.e.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"  operatorname*argmin_qin mathcal M d_mathcal N(i(q)p)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"And this resulting q we call the projection of p onto the manifold mathcal M.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The second projection we can look at is for a given a point pmathcal M and a vector in Xin T_i(p)mathcal N in the embedding, where we can similarly look for the closest tangent vector Y T_pmathcal M, which we have to embed itself before itself. Embedding a tangent vector is usually the same as using the pushforward mathrmdi_p of the embedding (at p). We obtain","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"  operatorname*argmin_Yin T_pmathcal M bigllVert mathrmdi(p)Y - X bigrrVert_i(p)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"And we call the resulting Y the projection of X onto the tangent space T_pmathcal M at p.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Let‚Äòs look at the little more concrete example of the complex circle again. Here, the closest point of p  ‚ÑÇ is just the projection onto the circle, or in other words q = fracplvert p rvert, as long as pneq 0. For p=0 the projection is not defined. A tangent space T_pmathcal C in the embedding is the line through the origin that is orthogonal to a point pmathcal C. This can be better visualized by looking at p+T_pmathcal C which is actually the line tangent to p on the unit circle. Note that this shift does not change the resulting projection relative to the origin of the tangent space.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Here the projection can be computed as the classical projection onto the line, i.e.  Y = X - XpX.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Both projections onto mathcal C and onto T_pmathcal C are illustrated in the following figure.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"(Image: An example illustrating the two kinds of projections on the Circle.)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The functions provided in this interface are the following.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Modules = [ManifoldsBase]\nPages = [\"projections.jl\"]\nOrder = [:function]","category":"page"},{"location":"projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, Y, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. The result is saved in vector Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, q, p)\n\nProject point p from the ambient space onto the AbstractManifold M. The result is storedin q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p)\n\nProject point p from the ambient space of the AbstractManifold M to M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"types/#The-Manifold-interface","page":"An abstract manifold","title":"The Manifold interface","text":"","category":"section"},{"location":"types/#The-AbstractManifold","page":"An abstract manifold","title":"The AbstractManifold","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"The main type is the AbstractManifold. It represents the manifold per se. Throughout the documentation of ManifoldsBase.jl we might use the Euclidean Space and the Sphere (both implemented in Manifolds.jl) as easy examples to illustrate properties and features of this interface on concrete examples.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"AbstractManifold","category":"page"},{"location":"types/#ManifoldsBase.AbstractManifold","page":"An abstract manifold","title":"ManifoldsBase.AbstractManifold","text":"AbstractManifold{ùîΩ}\n\nA type to represent a (Riemannian) manifold. The AbstractManifold is a central type of this interface. It allows to distinguish different implementations of functions like the exponential and logarithmic map for different manifolds. Usually, the manifold is the first parameter in any of these functions within ManifoldsBase.jl. Based on these, say ‚Äúelementary‚Äù functions, as the two mentioned above, more general functions are built, for example the shortest_geodesic and the geodesic. These should only be overwritten (reimplemented) if for a certain manifold specific, more efficient implementations are possible, that do not just call the elementary functions.\n\nThe [AbstractManifold] is parametrized by AbstractNumbers to distinguish for example real (‚Ñù) and complex (‚ÑÇ) manifolds.\n\nFor subtypes the preferred order of parameters is: size and simple value parameters, followed by the AbstractNumbers field, followed by data type parameters, which might depend on the abstract number field type.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"which should store information about the manifold, for example parameters inherent to the manifold.","category":"page"},{"location":"types/#Points-on-a-manifold","page":"An abstract manifold","title":"Points on a manifold","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Points do not necessarily have to be typed. Usually one can just use any type. When a manifold has multiple representations, these should be distinguished by point and vector types.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"AbstractManifoldPoint","category":"page"},{"location":"types/#ManifoldsBase.AbstractManifoldPoint","page":"An abstract manifold","title":"ManifoldsBase.AbstractManifoldPoint","text":"AbstractManifoldPoint\n\nType for a point on a manifold. While an AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used either\n\nfor more complicated representations,\nsemantic verification, or\nwhen dispatching on different representations of points on a manifold.\n\nSince semantic verification and different representations usually might still only store a matrix internally, it is possible to use @manifold_element_forwards and @default_manifold_fallbacks to reduce implementation overhead.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Converting points between different representations can be performed using the convert function with either two or three arguments (convert(T, M, p) or convert(T, p)). For some manifolds providing M may be necessary. The first variant falls back to the second variant.","category":"page"},{"location":"types/#Tangent-and-Cotangent-spaces","page":"An abstract manifold","title":"Tangent and Cotangent spaces","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Modules = [ManifoldsBase]\nPages = [\"vector_spaces.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"types/#ManifoldsBase.AbstractFibreVector","page":"An abstract manifold","title":"ManifoldsBase.AbstractFibreVector","text":"AbstractFibreVector{TType<:VectorSpaceType}\n\nType for a vector from a vector space (fibre of a vector bundle) of type TType of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\nYou may use macro @manifold_vector_forwards to introduce commonly used method definitions for your subtype of AbstractFibreVector.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.CoTVector","page":"An abstract manifold","title":"ManifoldsBase.CoTVector","text":"CoTVector = AbstractFibreVector{CotangentSpaceType}\n\nType for a cotangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.FVector","page":"An abstract manifold","title":"ManifoldsBase.FVector","text":"FVector(type::VectorSpaceType, data, basis::AbstractBasis)\n\nDecorator indicating that the vector data contains coordinates of a vector from a fiber of a vector bundle of type type. basis is an object describing the basis of that space in which the coordinates are given.\n\nConversion between FVector representation and the default representation of an object (for example a tangent vector) for a manifold should be done using get_coordinates and get_vector.\n\nExamples\n\njulia> using Manifolds\n\njulia> M = Sphere(2)\nSphere(2, ‚Ñù)\n\njulia> p = [1.0, 0.0, 0.0]\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> X = [0.0, 2.0, -1.0]\n3-element Vector{Float64}:\n  0.0\n  2.0\n -1.0\n\njulia> B = DefaultOrthonormalBasis()\nDefaultOrthonormalBasis(‚Ñù)\n\njulia> fX = TFVector(get_coordinates(M, p, X, B), B)\nTFVector([2.0, -1.0], DefaultOrthonormalBasis(‚Ñù))\n\njulia> X_back = get_vector(M, p, fX.data, fX.basis)\n3-element Vector{Float64}:\n -0.0\n  2.0\n -1.0\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.TVector","page":"An abstract manifold","title":"ManifoldsBase.TVector","text":"TVector = AbstractFibreVector{TangentSpaceType}\n\nType for a tangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, ManifoldsBase.VectorSpaceType}","page":"An abstract manifold","title":"ManifoldsBase.vector_space_dimension","text":"vector_space_dimension(M::AbstractManifold, V::VectorSpaceType)\n\nDimension of the vector space of type V on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"This interface also covers a large variety how to model bases in tangent spaces.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Converting tangent vectors between different representations can be performed using the convert function with either three or four arguments (convert(T, M, p, X) or convert(T, p, X)). For some manifolds providing M may be necessary. The first variant falls back to the second variant.","category":"page"},{"location":"types/#Macros-for-automatic-forwards-for-simple-points/tangent-vectors","page":"An abstract manifold","title":"Macros for automatic forwards for simple points/tangent vectors","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"When distinguishing different representations of points or tangent vectors on one manifold, it might happen that both a subtype of AbstractManifoldPoint and a subtype of TVector are just encapsulating a value","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"This is taken into account by the following macros, that forward several actions just to this field. Most prominently vector operations for the tangent vectors. If there is still a default case, a macro sets this type to be equivalent to calling the manifold functions just with the types field that carries the value.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Modules = [ManifoldsBase]\nPages = [\"point_vector_fallbacks.jl\"]\nOrder = [:type, :function, :macro]","category":"page"},{"location":"types/#ManifoldsBase.@default_manifold_fallbacks-Tuple{Any, Any, Any, Symbol, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@default_manifold_fallbacks","text":"default_manifold_fallbacks(TM, TP, TV, pfield::Symbol, vfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on manifolds, for manifold of type TM, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and vfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"types/#ManifoldsBase.@manifold_element_forwards-Tuple{Any, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@manifold_element_forwards","text":"manifold_element_forwards(T, field::Symbol)\nmanifold_element_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T (which can be a subtype of Twhere) that represents points or vectors for a manifold. Fallbacks will work by forwarding to the field passed in field`\n\nList of forwarded functions:\n\nallocate,\ncopy,\ncopyto!,\nnumber_eltype (only for values, not the type itself),\nsimilar,\nsize,\n==.\n\n\n\n\n\n","category":"macro"},{"location":"types/#ManifoldsBase.@manifold_vector_forwards-Tuple{Any, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@manifold_vector_forwards","text":"manifold_vector_forwards(T, field::Symbol)\nmanifold_vector_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T that represents vectors from a vector bundle for a manifold. Twhere is put into where clause of each method. Fallbacks work by forwarding to field passed as field.\n\nList of forwarded functions:\n\nbasic arithmetic (*, /, \\, +, -),\nall things from @manifold_element_forwards,\nbroadcasting support.\n\nexample\n\n@eval @manifold_vector_forwards ValidationFibreVector{TType} TType value\n\n\n\n\n\n","category":"macro"},{"location":"types/#number-system","page":"An abstract manifold","title":"Number Systems","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"The AbstractManifold has one parameter to distinguish the number system a manifold is based on.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Modules = [ManifoldsBase]\nPages = [\"numbers.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"types/#ManifoldsBase.AbstractNumbers","page":"An abstract manifold","title":"ManifoldsBase.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (‚Ñù for short) and ComplexNumbers (‚ÑÇ).\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.ComplexNumbers","page":"An abstract manifold","title":"ManifoldsBase.ComplexNumbers","text":"ComplexNumbers <: AbstractNumbers\n‚ÑÇ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.QuaternionNumbers","page":"An abstract manifold","title":"ManifoldsBase.QuaternionNumbers","text":"QuaternionNumbers <: AbstractNumbers\n‚Ñç = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.RealNumbers","page":"An abstract manifold","title":"ManifoldsBase.RealNumbers","text":"RealNumbers <: AbstractNumbers\n‚Ñù = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase._unify_number_systems-Tuple{ManifoldsBase.AbstractNumbers, Vararg{ManifoldsBase.AbstractNumbers}}","page":"An abstract manifold","title":"ManifoldsBase._unify_number_systems","text":"_unify_number_systems(ùîΩs::AbstractNumbers...)\n\nCompute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.\n\n\n\n\n\n","category":"method"},{"location":"types/#ManifoldsBase.number_system-Union{Tuple{AbstractManifold{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ","page":"An abstract manifold","title":"ManifoldsBase.number_system","text":"number_system(M::AbstractManifold{ùîΩ})\n\nReturn the number system the manifold M is based on, i.e. the parameter ùîΩ.\n\n\n\n\n\n","category":"method"},{"location":"types/#ManifoldsBase.real_dimension-Tuple{ManifoldsBase.AbstractNumbers}","page":"An abstract manifold","title":"ManifoldsBase.real_dimension","text":"real_dimension(ùîΩ::AbstractNumbers)\n\nReturn the real dimension dim_‚Ñù ùîΩ of the AbstractNumbers system ùîΩ. The real dimension is the dimension of a real vector space with which a number in ùîΩ can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n\n\n","category":"method"}]
}
