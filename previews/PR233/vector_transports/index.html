<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector transports ¬∑ ManifoldsBase.jl</title><meta name="title" content="Vector transports ¬∑ ManifoldsBase.jl"/><meta property="og:title" content="Vector transports ¬∑ ManifoldsBase.jl"/><meta property="twitter:title" content="Vector transports ¬∑ ManifoldsBase.jl"/><meta name="description" content="Documentation for ManifoldsBase.jl."/><meta property="og:description" content="Documentation for ManifoldsBase.jl."/><meta property="twitter:description" content="Documentation for ManifoldsBase.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li><a class="tocitem" href="../design/">Design principles</a></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="../functions/">Basic functions</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li class="is-active"><a class="tocitem" href>Vector transports</a><ul class="internal"><li><a class="tocitem" href="#Vector-transport"><span>Vector transport</span></a></li><li><a class="tocitem" href="#Types-of-vector-transports"><span>Types of vector transports</span></a></li><li><a class="tocitem" href="#Functions-to-implement-(on-Layer-III)"><span>Functions to implement (on Layer III)</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../manifolds/">Manifolds</a></li><li><a class="tocitem" href="../metamanifolds/">Meta-Manifolds</a></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li><li><a class="tocitem" href="../numerical_verification/">Numerical Verification</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions on maniolds</a></li><li class="is-active"><a href>Vector transports</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vector transports</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/vector_transports.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="Vector-transport"><a class="docs-heading-anchor" href="#Vector-transport">Vector transport</a><a id="Vector-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-transport" title="Permalink"></a></h2><p>Similar to the <a href="../functions/#exp-and-log">exponential and logarithmic map</a> also the <a href="../functions/#subsec-parallel-transport">parallel transport</a> might be costly to compute, especially when there is no closed form solution known and it has to be approximated with numerical methods. Similar to the <a href="../retractions/#sec-retractions">retraction and its inverse</a>, the generalisation of the parallel transport can be phrased as follows</p><p>A <em>vector transport</em> is a way to transport a vector between two tangent spaces. Let <span>$p,q ‚àà \mathcal M$</span> be given, <span>$c$</span> the curve along which we want to transport (cf. <a href="../functions/#subsec-parallel-transport">parallel transport</a>, for example a geodesic or curve given by a retraction. We can specify the geodesic or curve a retraction realises for example by a direction <span>$d$</span>.</p><p>More precisely using [<a href="../references/#AbsilMahonySepulchre_2008">AMS08</a>], Def. 8.1.1, a vector transport <span>$T_{p,d}: T_p\mathcal M \to T_q\mathcal M$</span>, <span>$p‚àà \mathcal M$</span>, <span>$Y‚àà T_p\mathcal M$</span> is a smooth mapping associated to a retraction <span>$\operatorname{retr}_p(Y) = q$</span> such that</p><ol><li>(associated retraction) <span>$\mathcal T_{p,d}X ‚àà T_q\mathcal M$</span> if and only if <span>$q = \operatorname{retr}_p(d)$</span>,</li><li>(consistency) <span>$\mathcal T_{p,0_p}X = X$</span> for all <span>$X‚ààT_p\mathcal M$</span>,</li><li>(linearity) <span>$\mathcal T_{p,d}(Œ±X+Œ≤Y) = \mathcal Œ±T_{p,d}X + \mathcal Œ≤T_{p,d}Y$</span> for all <span>$Œ±, Œ≤ ‚àà ùîΩ$</span>,</li></ol><p>hold.</p><p>Currently the following methods for vector transport are defined in <code>ManifoldsBase.jl</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::AbstractManifold)
default_vector_transport_method(M::AbstractManifold, ::Type{T}) where {T}</code></pre><p>The <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> that is used when calling <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> or <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> without specifying the vector transport method. By default, this is <a href="#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p><p>This method can also be specified more precisely with a point type <code>T</code>, for the case that on a <code>M</code> there are two different representations of points, which provide different vector transport methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L302-L313">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction" href="#ManifoldsBase.vector_transport_direction"><code>ManifoldsBase.vector_transport_direction</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::AbstractManifold, p, X, d)
vector_transport_direction(M::AbstractManifold, p, X, d, m::AbstractVectorTransportMethod)</code></pre><p>Given an <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <span>$\mathcal M$</span> the vector transport is a generalization of the <a href="../functions/#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_direction</code></a> that identifies vectors from different tangent spaces.</p><p>More precisely using [<a href="../references/#AbsilMahonySepulchre_2008">AMS08</a>], Def. 8.1.1, a vector transport <span>$T_{p,d}: T_p\mathcal M \to T_q\mathcal M$</span>, <span>$p‚àà \mathcal M$</span>, <span>$Y‚àà T_p\mathcal M$</span> is a smooth mapping associated to a retraction <span>$\operatorname{retr}_p(Y) = q$</span> such that</p><ol><li>(associated retraction) <span>$\mathcal T_{p,d}X ‚àà T_q\mathcal M$</span> if and only if <span>$q = \operatorname{retr}_p(d)$</span>.</li><li>(consistency) <span>$\mathcal T_{p,0_p}X = X$</span> for all <span>$X‚ààT_p\mathcal M$</span></li><li>(linearity) <span>$\mathcal T_{p,d}(Œ±X+Œ≤Y) = Œ±\mathcal T_{p,d}X + Œ≤\mathcal T_{p,d}Y$</span></li></ol><p>For the <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> we might even omit the third point. The <a href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a>s are linear.</p><p><strong>Input Parameters</strong></p><ul><li><code>M</code> a manifold</li><li><code>p</code> indicating the tangent space of</li><li><code>X</code> the tangent vector to be transported</li><li><code>d</code> indicating a transport direction (and distance through its length)</li><li><code>m</code> an <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>, by default <a href="../metamanifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a>, so usually <a href="#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a></li></ul><p>Usually this method requires a <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> as well. By default this is assumed to be the <a href="../metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a> or implicitly given (and documented) for a vector transport. To explicitly distinguish different retractions for a vector transport, see <a href="#ManifoldsBase.VectorTransportDirection"><code>VectorTransportDirection</code></a>.</p><p>Instead of spcifying a start direction <code>d</code> one can equivalently also specify a target tanget space <span>$T_q\mathcal M$</span>, see <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>. By default <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> falls back to using <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, using the <a href="../metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a> on <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L444-L479">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!" href="#ManifoldsBase.vector_transport_direction!"><code>ManifoldsBase.vector_transport_direction!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction!(M::AbstractManifold, Y, p, X, d)
vector_transport_direction!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="../metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> and <a href="#ManifoldsBase.vector_transport_to!"><code>vector_transport_to!</code></a> are used with the <code>m</code> and <code>r</code>, which default to <a href="../metamanifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code> and <a href="../metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a><code>(M)</code>, respectively. The result is saved to <code>Y</code>.</p><p>See <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L528-L539">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to" href="#ManifoldsBase.vector_transport_to"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractManifold, p, X, q)
vector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)
vector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along a curve implicitly given by an <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> associated to <code>m</code>. By default <code>m</code> is the <a href="../metamanifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. To explicitly specify a (different) retraction to the implicitly assumeed retraction, see <a href="#ManifoldsBase.VectorTransportTo"><code>VectorTransportTo</code></a>. Note that some vector transport methods might also carry their own retraction they are associated to, like the  <a href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> and some are even independent of the retraction, for example the <a href="#ManifoldsBase.ProjectionTransport"><code>ProjectionTransport</code></a>.</p><p>This method is equivalent to using <span>$d = \operatorname{retr}^{-1}_p(q)$</span> in <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a><code>(M, p, X, q, m, r)</code>, where you can find the formal definition. This is the fallback for <a href="#ManifoldsBase.VectorTransportTo"><code>VectorTransportTo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L676-L690">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!" href="#ManifoldsBase.vector_transport_to!"><code>ManifoldsBase.vector_transport_to!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q)
vector_transport_to!(M::AbstractManifold, Y, p, X, q, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> to <code>q</code> using the <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>m</code> and the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>r</code>.</p><p>The result is computed in <code>Y</code>. See <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L732-L741">source</a></section></article><h2 id="Types-of-vector-transports"><a class="docs-heading-anchor" href="#Types-of-vector-transports">Types of vector transports</a><a id="Types-of-vector-transports-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-vector-transports" title="Permalink"></a></h2><p>To distinguish different types of vector transport we introduce the <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>. The following concrete types are available.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractLinearVectorTransportMethod" href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>ManifoldsBase.AbstractLinearVectorTransportMethod</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractLinearVectorTransportMethod &lt;: AbstractVectorTransportMethod</code></pre><p>Abstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractVectorTransportMethod &lt;: AbstractApproximationMethod</code></pre><p>Abstract type for methods for transporting vectors. Such vector transports are not necessarily linear.</p><p><strong>See also</strong></p><p><a href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.DifferentiatedRetractionVectorTransport" href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>ManifoldsBase.DifferentiatedRetractionVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DifferentiatedRetractionVectorTransport{R&lt;:AbstractRetractionMethod} &lt;:
    AbstractVectorTransportMethod</code></pre><p>A type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let <span>$\mathcal M$</span> be a Riemannian manifold, <span>$p‚àà\mathcal M$</span> a point, and <span>$X,Y‚àà T_p\mathcal M$</span> denote two tangent vectors at <span>$p$</span>.</p><p>Given a retraction (cf. <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>) <span>$\operatorname{retr}$</span>, the vector transport of <code>X</code> in direction <code>Y</code> (cf. <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>) by differentiation this retraction, is given by</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{p,Y}X
= D_Y\operatorname{retr}_p(Y)[X]
= \frac{\mathrm{d}}{\mathrm{d}t}\operatorname{retr}_p(Y+tX)\Bigr|_{t=0}.\]</p><p>see [<a href="../references/#AbsilMahonySepulchre_2008">AMS08</a>], Section 8.1.2 for more details.</p><p>This can be phrased similarly as a <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> by introducing <span>$q=\operatorname{retr}_pX$</span> and defining</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{q \gets p}X = \mathcal T^{\operatorname{retr}}_{p,Y}X\]</p><p>which in practice usually requires the <a href="../metamanifolds/#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a> to exists in order to compute <span>$Y = \operatorname{retr}_p^{-1}q$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L21-L53">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.EmbeddedVectorTransport" href="#ManifoldsBase.EmbeddedVectorTransport"><code>ManifoldsBase.EmbeddedVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">EmbeddedVectorTransport{T&lt;:AbstractVectorTransportMethod} &lt;: AbstractVectorTransportMethod</code></pre><p>Compute a vector transport by using the vector transport of type <code>T</code> in the embedding and projecting the result.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">EmbeddedVectorTransport(vt::AbstractVectorTransportMethod)</code></pre><p>Generate the vector transport with vector transport <code>vt</code> to use in the embedding.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Compute the vector transport by parallel transport, see <a href="../functions/#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_to</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.PoleLadderTransport" href="#ManifoldsBase.PoleLadderTransport"><code>ManifoldsBase.PoleLadderTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">PoleLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> as vector transport method within <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> or <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, i.e.</p><p>Let <span>$X‚àà T_p\mathcal M$</span> be a tangent vector at <span>$p‚àà\mathcal M$</span> and <span>$q‚àà\mathcal M$</span> the point to transport to. Then <span>$x = \exp_pX$</span> is used to call <code>y =</code><a href="#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a><code>(M, p, x, q)</code> and the resulting vector is obtained by computing <span>$Y = -\log_qy$</span>.</p><p>The <a href="#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> posesses two advantages compared to <a href="#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>:</p><ul><li>it is cheaper to evaluate, if you want to transport several vectors, since the mid point <span>$c$</span> then stays unchanged.</li><li>while both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds [<a href="../references/#Pennec_2018">Pen18</a>]</li></ul><p>The pole ladder was was proposed in [<a href="../references/#LorenziPennec_2013">LP13</a>]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PoleLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical pole ladder that employs exp and log, i.e. as proposed in[<a href="../references/#LorenziPennec_2013">LP13</a>]. For an even cheaper transport the inner operations can be changed to an <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L93-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> or <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>. See <a href="../metamanifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>project</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ScaledVectorTransport" href="#ManifoldsBase.ScaledVectorTransport"><code>ManifoldsBase.ScaledVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScaledVectorTransport{T} &lt;: AbstractVectorTransportMethod</code></pre><p>Introduce a scaled variant of any <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>T</code>, as introduced in [<a href="../references/#SatoIwai_2013">SI13</a>] for some <span>$X‚àà T_p\mathcal M$</span> as</p><p class="math-container">\[    \mathcal T^{\mathrm{S}}(X) = \frac{\lVert X\rVert_p}{\lVert \mathcal T(X)\rVert_q}\mathcal T(X).\]</p><p>Note that the resulting point <code>q</code> has to be known, i.e. for <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ScaledVectorTransport(m::AbstractVectorTransportMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L142-L159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.SchildsLadderTransport" href="#ManifoldsBase.SchildsLadderTransport"><code>ManifoldsBase.SchildsLadderTransport</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SchildsLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> as vector transport method within <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> or <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, i.e.</p><p>Let <span>$X‚àà T_p\mathcal M$</span> be a tangent vector at <span>$p‚àà\mathcal M$</span> and <span>$q‚àà\mathcal M$</span> the point to transport to. Then</p><p class="math-container">\[P^{\mathrm{S}}_{q\gets p}(X) =
    \log_q\bigl( \operatorname{retr}_p ( 2\operatorname{retr}_p^{-1}c ) \bigr),\]</p><p>where <span>$c$</span> is the mid point between <span>$q$</span> and <span>$d=\exp_pX$</span>.</p><p>This method employs the internal function <a href="#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a><code>(M, p, d, q)</code> that avoids leaving the manifold.</p><p>The name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [<a href="../references/#EhlersPiraniSchild_1972">EPS72</a>].</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SchildsLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical Schilds ladder that employs exp and log, i.e. as proposed in [<a href="../references/#EhlersPiraniSchild_1972">EPS72</a>]. For an even cheaper transport these inner operations can be changed to an <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L165-L198">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.VectorTransportDirection" href="#ManifoldsBase.VectorTransportDirection"><code>ManifoldsBase.VectorTransportDirection</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorTransportDirection{VM&lt;:AbstractVectorTransportMethod,RM&lt;:AbstractRetractionMethod}
    &lt;: AbstractVectorTransportMethod</code></pre><p>Specify a <a href="#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> using a <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> with explicitly using the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> to determine the point in the specified direction where to transsport to. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L215-L225">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.VectorTransportTo" href="#ManifoldsBase.VectorTransportTo"><code>ManifoldsBase.VectorTransportTo</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorTransportTo{VM&lt;:AbstractVectorTransportMethod,RM&lt;:AbstractRetractionMethod}
    &lt;: AbstractVectorTransportMethod</code></pre><p>Specify a <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> using a <a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> with explicitly using the <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> to determine the direction that transports from  in <code>p</code>to <code>q</code>. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L242-L252">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.VectorTransportWithKeywords" href="#ManifoldsBase.VectorTransportWithKeywords"><code>ManifoldsBase.VectorTransportWithKeywords</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VectorTransportWithKeywords{V&lt;:AbstractVectorTransportMethod, K} &lt;: AbstractVectorTransportMethod</code></pre><p>Since vector transports might have keywords, this type is a way to set them as an own type to be used as a specific vector transport. Another reason for this type is that we dispatch on the vector transport first and only the last layer would be implemented with keywords, so this way they can be passed down.</p><p><strong>Fields</strong></p><ul><li><code>vector_transport</code> the vector transport that is decorated with keywords</li><li><code>kwargs</code> the keyword arguments</li></ul><p>Note that you can nest this type. Then the most outer specification of a keyword is used.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorTransportWithKeywords(m::T; kwargs...) where {T &lt;: AbstractVectorTransportMethod}</code></pre><p>Specify the subtype <code>T &lt;:</code><a href="#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> to have keywords <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L269-L289">source</a></section></article><h2 id="Functions-to-implement-(on-Layer-III)"><a class="docs-heading-anchor" href="#Functions-to-implement-(on-Layer-III)">Functions to implement (on Layer III)</a><a id="Functions-to-implement-(on-Layer-III)-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-to-implement-(on-Layer-III)" title="Permalink"></a></h2><p>While you should always add your documentation to the first layer vector transport methods above when implementing new manifolds, the actual implementation happens on the following functions on <a href="../design/#design-layer3">layer III</a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.pole_ladder" href="#ManifoldsBase.pole_ladder"><code>ManifoldsBase.pole_ladder</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M, p, d, q, c = mid_point(M, p, q);
    retraction=default_retraction_method(M, typeof(p)),
    inverse_retraction=default_inverse_retraction_method(M, typeof(p))
)</code></pre><p>Compute an inner step of the pole ladder, that can be used as a <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>. Let <span>$c = \gamma_{p,q}(\frac{1}{2})$</span> mid point between <code>p</code> and <code>q</code>, then the pole ladder is given by</p><p class="math-container">\[    \operatorname{Pl}(p,d,q) = \operatorname{retr}_d (2\operatorname{retr}_d^{-1}c)\]</p><p>Where the classical pole ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = -\log_q \operatorname{Pl}(p,d,q)$</span>, you will obtain the <a href="#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. When performing multiple steps, this method avoids the switching to the tangent space. Keep in mind that after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = (-1)^n\log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p><p>It is cheaper to evaluate than <a href="#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a>, sinc if you want to form multiple ladder steps between <code>p</code> and <code>q</code>, but with different <code>d</code>, there is just one evaluation of a geodesic each., since the center <code>c</code> can be reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L322-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.pole_ladder!" href="#ManifoldsBase.pole_ladder!"><code>ManifoldsBase.pole_ladder!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M, pl, p, d, q, c = mid_point(M, p, q), X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Compute the <a href="#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a>, i.e. the result is saved in <code>pl</code>. <code>X</code> is used for storing intermediate inverse retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L357-L366">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.schilds_ladder" href="#ManifoldsBase.schilds_ladder"><code>ManifoldsBase.schilds_ladder</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schilds_ladder(
    M, p, d, q, c = mid_point(M, q, d);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Perform an inner step of schilds ladder, which can be used as a <a href="../metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, see <a href="#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>. Let <span>$c = \gamma_{q,d}(\frac{1}{2})$</span> denote the mid point on the shortest geodesic connecting <span>$q$</span> and the point <span>$d$</span>. Then Schild&#39;s ladder reads as</p><p class="math-container">\[\operatorname{Sl}(p,d,q) = \operatorname{retr}_p( 2\operatorname{retr}_p^{-1} c)\]</p><p>Where the classical Schilds ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>In consistency with <a href="#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> you can change the way the mid point is computed using the optional parameter <code>c</code>, but note that here it&#39;s the mid point between <code>q</code> and <code>d</code>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = \log_q \operatorname{Sl}(p,d,q)$</span>, you will obtain the <a href="#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. Then the approximation to the transported vector is given by <span>$\log_q\operatorname{Sl}(p,d,q)$</span>.</p><p>When performing multiple steps, this method avoidsd the switching to the tangent space. Hence after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = \log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L377-L407">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.schilds_ladder!" href="#ManifoldsBase.schilds_ladder!"><code>ManifoldsBase.schilds_ladder!</code></a> ‚Äî <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">schilds_ladder!(M, sl, p, d, q, c = mid_point(M, q, d),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Compute <a href="#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> and return the value in the parameter <code>sl</code>. If the required mid point <code>c</code> was computed before, it can be passed using <code>c</code>, and the allocation of new memory can be avoided providing a tangent vector <code>X</code> for the interims result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L415-L426">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}" href="#ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}"><code>ManifoldsBase.vector_transport_direction_diff!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction_diff!(M::AbstractManifold, Y, p, X, d, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> into the direction <code>d</code> using the differential of the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L608-L613">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction_embedded!-Tuple{AbstractManifold, Any, Any, Any, Any, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_direction_embedded!-Tuple{AbstractManifold, Any, Any, Any, Any, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_direction_embedded!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction_embedded!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> into the direction <code>d</code> using the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> in the embedding.</p><p>The default implementataion requires one allocation for the points and tangent vectors in the embedding and the resulting point, but the final projection is performed in place of <code>Y</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L651-L659">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Vararg{Any, 5}}" href="#ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Vararg{Any, 5}}"><code>ManifoldsBase.vector_transport_to_diff!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_diff(M::AbstractManifold, p, X, q, r)</code></pre><p>Compute a vector transport by using a <a href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> <code>r</code> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L871-L875">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_embedded!-Tuple{AbstractManifold, Vararg{Any, 5}}" href="#ManifoldsBase.vector_transport_to_embedded!-Tuple{AbstractManifold, Vararg{Any, 5}}"><code>ManifoldsBase.vector_transport_to_embedded!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_embedded!(M::AbstractManifold, Y, p, X, q, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> to the point <code>q</code> using the  of the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> in th embedding.</p><p>The default implementataion requires one allocation for the points and tangent vectors in the embedding and the resulting point, but the final projection is performed in place of <code>Y</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L880-L888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Vararg{Any, 4}}" href="#ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Vararg{Any, 4}}"><code>ManifoldsBase.vector_transport_to_project!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_project!(M::AbstractManifold, Y, p, X, q)</code></pre><p>Compute a vector transport by projecting <span>$X\in T_p\mathcal M$</span> onto the tangent space <span>$T_q\mathcal M$</span> at <span>$q$</span> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2047a58528c08f11917af725cde04480cf7ac706/src/vector_transport.jl#L897-L902">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../retractions/">¬´ Retractions</a><a class="docs-footer-nextpage" href="../manifolds/">Manifolds ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 17 September 2025 08:13">Wednesday 17 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
