<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Meta-Manifolds ¬∑ ManifoldsBase.jl</title><meta name="title" content="Meta-Manifolds ¬∑ ManifoldsBase.jl"/><meta property="og:title" content="Meta-Manifolds ¬∑ ManifoldsBase.jl"/><meta property="twitter:title" content="Meta-Manifolds ¬∑ ManifoldsBase.jl"/><meta name="description" content="Documentation for ManifoldsBase.jl."/><meta property="og:description" content="Documentation for ManifoldsBase.jl."/><meta property="twitter:description" content="Documentation for ManifoldsBase.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li><a class="tocitem" href="../design/">Design principles</a></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="../functions/">Basic functions</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li><a class="tocitem" href="../vector_transports/">Vector transports</a></li></ul></li><li><a class="tocitem" href="../manifolds/">Manifolds</a></li><li class="is-active"><a class="tocitem" href>Meta-Manifolds</a><ul class="internal"><li><a class="tocitem" href="#sec-power-manifold"><span>(Abstract) power manifold</span></a></li><li><a class="tocitem" href="#ProductManifold"><span>Product Manifold</span></a></li><li><a class="tocitem" href="#Fiber"><span>Fiber</span></a></li><li><a class="tocitem" href="#Tangent-Space"><span>Tangent Space</span></a></li></ul></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li><li><a class="tocitem" href="../numerical_verification/">Numerical Verification</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Meta-Manifolds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Meta-Manifolds</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/metamanifolds.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Meta-Manifolds"><a class="docs-heading-anchor" href="#Meta-Manifolds">Meta Manifolds</a><a id="Meta-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Meta-Manifolds" title="Permalink"></a></h1><p>While the interface does not provide concrete manifolds itself, it does provide several manifolds that can be build based on a given <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> instance.</p><h2 id="sec-power-manifold"><a class="docs-heading-anchor" href="#sec-power-manifold">(Abstract) power manifold</a><a id="sec-power-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#sec-power-manifold" title="Permalink"></a></h2><p>A power manifold is constructed like higher dimensional vector spaces are formed from the real line, just that for every point <span>$p = (p_1,\ldots,p_n) ‚àà \mathcal M^n$</span> on the power manifold <span>$\mathcal M^n$</span> the entries of <span>$p$</span> are points <span>$p_1,\ldots,p_n ‚àà \mathcal M$</span> on some manifold <span>$\mathcal M$</span>. Note that <span>$n$</span> can also be replaced by multiple values, such that <span>$p$</span> is not a vector but a matrix or a multi-index array of points.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractPowerManifold" href="#ManifoldsBase.AbstractPowerManifold"><code>ManifoldsBase.AbstractPowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerManifold{ùîΩ,M,TPR} &lt;: AbstractManifold{ùîΩ}</code></pre><p>An abstract <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> to represent manifolds that are build as powers of another <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with representation type <code>TPR</code>, a subtype of <a href="#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.AbstractPowerRepresentation" href="#ManifoldsBase.AbstractPowerRepresentation"><code>ManifoldsBase.AbstractPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPowerRepresentation</code></pre><p>An abstract representation type of points and tangent vectors on a power manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.NestedPowerRepresentation" href="#ManifoldsBase.NestedPowerRepresentation"><code>ManifoldsBase.NestedPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is modified in-place, differently than in <a href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.NestedReplacingPowerRepresentation" href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>ManifoldsBase.NestedReplacingPowerRepresentation</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NestedReplacingPowerRepresentation</code></pre><p>Representation of points and tangent vectors on a power manifold using arrays of size equal to <code>TSize</code> of a <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a>. Each element of such array stores a single point or tangent vector.</p><p>For modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for <a href="#ManifoldsBase.NestedReplacingPowerRepresentation"><code>NestedReplacingPowerRepresentation</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.PowerBasisData" href="#ManifoldsBase.PowerBasisData"><code>ManifoldsBase.PowerBasisData</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerBasisData{TB&lt;:AbstractArray}</code></pre><p>Data storage for an array of basis data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L139-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.PowerManifold" href="#ManifoldsBase.PowerManifold"><code>ManifoldsBase.PowerManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PowerManifold{ùîΩ,TM&lt;:AbstractManifold,TSize,TPR&lt;:AbstractPowerRepresentation} &lt;: AbstractPowerManifold{ùîΩ,TM}</code></pre><p>The power manifold <span>$\mathcal M^{n_1√ó n_2 √ó ‚Ä¶ √ó n_d}$</span> with power geometry.  <code>TSize</code> defines the number of elements along each axis, either statically using  <code>TypeParameter</code> or storing it in a field.</p><p>For example, a manifold-valued time series would be represented by a power manifold with <span>$d$</span> equal to 1 and <span>$n_1$</span> equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (<span>$d=2$</span>) with <span>$n_1$</span> and <span>$n_2$</span> equal to width and height of the image.</p><p>While the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PowerManifold(M::PowerManifold, N_1, N_2, ..., N_d; parameter::Symbol=:field)
PowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d; parameter::Symbol=:field)
M^(N_1, N_2, ..., N_d)</code></pre><p>Generate the power manifold <span>$M^{N_1 √ó N_2 √ó ‚Ä¶ √ó N_d}$</span>. By default, a <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> is expanded further, i.e. for <code>M=PowerManifold(N, 3)</code> <code>PowerManifold(M, 2)</code> is equivalent to <code>PowerManifold(N, 3, 2)</code>. Points are then 3√ó2 matrices of points on <code>N</code>. Providing a <a href="#ManifoldsBase.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a> as the second argument to the constructor can be used to nest manifold, i.e. <code>PowerManifold(M, NestedPowerRepresentation(), 2)</code> represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.</p><p>The third signature <code>M^(...)</code> is equivalent to the first one, and hence either yields a combination of power manifolds to <em>one</em> larger power manifold, or a power manifold with the default representation.</p><p>Since there is no default <a href="#ManifoldsBase.AbstractPowerRepresentation"><code>AbstractPowerRepresentation</code></a> within this interface, the <code>^</code> operator is only available for <code>PowerManifold</code>s and concatenates dimensions.</p><p><code>parameter</code>: whether a type parameter should be used to store <code>n</code>. By default size is stored in a field. Value can either be <code>:field</code> or <code>:type</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L45-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, Y, p, X)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, B, a, A)</code> for all elements <code>A</code>, <code>a</code> and <code>B</code> of <code>X</code>, <code>p</code>, and <code>Y</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L475-L480">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}" href="#Base.copyto!-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}"><code>Base.copyto!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copyto!(M::PowerManifoldNested, q, p)</code></pre><p>Copy the values elementwise, i.e. call <code>copyto!(M.manifold, b, a)</code> for all elements <code>a</code> and <code>b</code> of <code>p</code> and <code>q</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L461-L466">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.exp-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the exponential map from <code>p</code> in direction <code>X</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds exponential map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L549-L554">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill!-Tuple{Any, Any, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedReplacingPowerRepresentation} where ùîΩ}" href="#Base.fill!-Tuple{Any, Any, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedReplacingPowerRepresentation} where ùîΩ}"><code>Base.fill!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill!(P, p, M::AbstractPowerManifold)</code></pre><p>Fill a point <code>P</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, setting every entry to <code>p</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>while usually the manifold is the first argument in all functions in <code>ManifoldsBase.jl</code>, we follow the signature of <code>fill!</code>, where the power manifold serves are the size information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L592-L600">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.fill-Tuple{Any, AbstractPowerManifold}" href="#Base.fill-Tuple{Any, AbstractPowerManifold}"><code>Base.fill</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fill(p, M::AbstractPowerManifold)</code></pre><p>Create a point on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, where every entry is set to the point <code>p</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>while usually the manifold is a first argument in all functions in <code>ManifoldsBase.jl</code>, we follow the signature of <code>fill</code>, where the power manifold serves are the size information.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L577-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
p[M::AbstractPowerManifold, i...]</code></pre><p>Access the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L853-L860">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, &lt;:AbstractPowerManifold}, Vararg{Union{Colon, Integer, AbstractVector}}}} where ùîΩ" href="#Base.getindex-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, &lt;:AbstractPowerManifold}, Vararg{Union{Colon, Integer, AbstractVector}}}} where ùîΩ"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(M::TangentSpace{ùîΩ, AbstractPowerManifold}, i...)
TpM[i...]</code></pre><p>Access the <code>i</code>th manifold component from an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>s&#39; tangent space <code>TpM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L869-L874">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the logarithmic map from <code>p</code> to <code>q</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, which can be computed using the base manifolds logarithmic map elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1028-L1033">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.setindex!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)
q[M::AbstractPowerManifold, i...] = p</code></pre><p>Set the element(s) at index <code>[i...]</code> of a point <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing to <code>q</code>. See also <a href="https://docs.julialang.org/en/v1/manual/arrays/#man-array-indexing-1">Array Indexing</a> in Julia.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1541-L1548">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.view-Tuple{AbstractArray, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Vararg{Union{Colon, Integer, AbstractVector}}}" href="#Base.view-Tuple{AbstractArray, AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Vararg{Union{Colon, Integer, AbstractVector}}}"><code>Base.view</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">view(p, M::PowerManifoldNested, i::Union{Integer,Colon,AbstractVector}...)</code></pre><p>Get the view of the element(s) at index <code>[i...]</code> of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by linear or multidimensional indexing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1730-L1735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{AbstractPowerManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::AbstractPowerManifold, p, X)</code></pre><p>Compute the norm of <code>X</code> from the tangent space of <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. from the element wise norms the Frobenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1094-L1100">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Weingarten-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.Weingarten-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Y = Weingarten(M::AbstractPowerManifold, p, X, V)
Weingarten!(M::AbstractPowerManifold, Y, p, X, V)</code></pre><p>Since the metric decouples, also the computation of the Weingarten map <span>$\mathcal W_p$</span> can be computed elementwise on the single elements of the <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1745-L1751">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}" href="#ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ùîΩ, &lt;:AbstractManifold{ùîΩ}, NestedPowerRepresentation} where ùîΩ, Any, Any}"><code>ManifoldsBase._allocate_access_nested</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocate_access_nested(M::PowerManifoldNested, y, i)</code></pre><p>Helper function for <code>allocate_result</code> on <code>PowerManifoldNested</code>. In allocation <code>y</code> can be a number in which case <code>_access_nested</code> wouldn&#39;t work.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L221-L226">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase._parameter_symbol-Tuple{PowerManifold}" href="#ManifoldsBase._parameter_symbol-Tuple{PowerManifold}"><code>ManifoldsBase._parameter_symbol</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_parameter_symbol(M::PowerManifold)</code></pre><p>Return <code>:field</code> if size of <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> is stored in a field and <code>:type</code> if in a <code>TypeParameter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.change_metric-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_metric-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_metric(M::AbstractPowerManifold, ::AbstractMetric, p, X)</code></pre><p>Since the metric on a power manifold decouples, the change of metric can be done elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L319-L323">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.change_representer-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_representer-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_representer(M::AbstractPowerManifold, ::AbstractMetric, p, X)</code></pre><p>Since the metric on a power manifold decouples, the change of a representer can be done elementwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::AbstractPowerManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. each element of <code>p</code> has to be a valid point on the base manifold. If <code>p</code> is not a point on <code>M</code> a <a href="../functions/#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L340-L349">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.check_power_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_power_size(M, p)
check_power_size(M, p, X)</code></pre><p>Check whether <code>p</code><code>has the right size to represent points on</code>M`` generically, i.e. just checking the overall sizes, not the individual ones per manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L363-L369">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::AbstractPowerManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> an the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. atfer <a href="../functions/#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a><code>(M, p)</code>, and all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="../functions/#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a> consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L430-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_inverse_retraction_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_inverse_retraction_method(M::PowerManifold)</code></pre><p>Use the default inverse retraction method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L507-L512">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_retraction_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_retraction_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_retraction_method(M::PowerManifold)</code></pre><p>Use the default retraction method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L494-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::PowerManifold)</code></pre><p>Use the default vector transport method of the internal <code>M.manifold</code> also in defaults of functions defined for the power manifold, meaning that this is used elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L520-L525">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::AbstractPowerManifold, p, q)</code></pre><p>Compute the distance between <code>q</code> and <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a>, i.e. from the element wise distances the Forbenius norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L533-L538">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}" href="#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}"><code>ManifoldsBase.get_component</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(M::AbstractPowerManifold, p, idx...)</code></pre><p>Get the component of a point <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L633-L637">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::AbstractPowerManifold[, p])</code></pre><p>the injectivity radius on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is for the global case equal to the one of its base manifold. For a given point <code>p</code> it&#39;s equal to the minimum of all radii in the array entries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L884-L890">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::AbstractPowerManifold, p, X, Y)</code></pre><p>Compute the inner product of <code>X</code> and <code>Y</code> from the tangent space at <code>p</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>, i.e. for each arrays entry the tangent vector entries from <code>X</code> and <code>Y</code> are in the tangent space of the corresponding element from <code>p</code>. The inner product is then the sum of the elementwise inner products.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L911-L919">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using an <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>. Then this method is performed elementwise, so the inverse retraction method has to be one that is available on the base <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L970-L977">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}" href="#ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(M::AbstractPowerManifold)</code></pre><p>Return true if <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> is flat. It is flat if and only if the wrapped manifold is flat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L934-L939">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{PowerManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{PowerManifold}"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::PowerManifold)</code></pre><p>Returns the manifold-dimension of an <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> <span>$=\mathcal N = (\mathcal M)^{n_1,‚Ä¶,n_d}$</span>, i.e. with <span>$n=(n_1,‚Ä¶,n_d)$</span> the array size of the power manifold and <span>$d_{\mathcal M}$</span> the dimension of the base manifold <span>$\mathcal M$</span>, the manifold is of dimension</p><p class="math-container">\[\dim(\mathcal N) = \dim(\mathcal M)\prod_{i=1}^d n_i = n_1n_2‚ãÖ‚Ä¶‚ãÖ n_d \dim(\mathcal M).\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1056-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.power_dimensions-Tuple{PowerManifold}" href="#ManifoldsBase.power_dimensions-Tuple{PowerManifold}"><code>ManifoldsBase.power_dimensions</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">power_dimensions(M::PowerManifold)</code></pre><p>return the power of <code>M</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1186-L1190">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p, X)</code></pre><p>Project the point <code>X</code> onto the tangent space at <code>p</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1218-L1223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}" href="#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(M::AbstractPowerManifold, p)</code></pre><p>Project the point <code>p</code> from the embedding onto the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> by projecting all components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1195-L1200">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}" href="#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::AbstractPowerManifold, p, X, method::AbstractRetractionMethod)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> using a <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>. Then this method is performed elementwise, so the retraction method has to be one that is available on the base <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1344-L1351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}" href="#ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}"><code>ManifoldsBase.riemann_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">riemann_tensor(M::AbstractPowerManifold, p, X, Y, Z)</code></pre><p>Compute the Riemann tensor at point from <code>p</code> with tangent vectors <code>X</code>, <code>Y</code> and <code>Z</code> on the <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1434-L1439">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature-Tuple{AbstractPowerManifold, Any, Any, Any}" href="#ManifoldsBase.sectional_curvature-Tuple{AbstractPowerManifold, Any, Any, Any}"><code>ManifoldsBase.sectional_curvature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature(M::AbstractPowerManifold, p, X, Y)</code></pre><p>Compute the sectional curvature of a power manifold manifold <span>$\mathcal M$</span> at a point <span>$p \in \mathcal M$</span> on two linearly independent tangent vectors at <span>$p$</span>. It may be 0 for  if projections of <code>X</code> and <code>Y</code> on subspaces corresponding to component manifolds are not linearly independent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1470-L1477">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_max-Tuple{AbstractPowerManifold}" href="#ManifoldsBase.sectional_curvature_max-Tuple{AbstractPowerManifold}"><code>ManifoldsBase.sectional_curvature_max</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_max(M::AbstractPowerManifold)</code></pre><p>Upper bound on sectional curvature of <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>. It is the maximum of sectional curvature of the wrapped manifold and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors <code>(X_1, 0, ... 0)</code> and <code>(0, X_2, 0, ..., 0)</code> is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1492-L1499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_min-Tuple{AbstractPowerManifold}" href="#ManifoldsBase.sectional_curvature_min-Tuple{AbstractPowerManifold}"><code>ManifoldsBase.sectional_curvature_min</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_min(M::AbstractPowerManifold)</code></pre><p>Lower bound on sectional curvature of <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code>. It is the minimum of sectional curvature of the wrapped manifold and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors <code>(X_1, 0, ... 0)</code> and <code>(0, X_2, 0, ..., 0)</code> is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1510-L1517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}" href="#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}"><code>ManifoldsBase.set_component!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_component!(M::AbstractPowerManifold, q, p, idx...)</code></pre><p>Set the component of a point <code>q</code> on an <a href="#ManifoldsBase.AbstractPowerManifold"><code>AbstractPowerManifold</code></a> <code>M</code> at index <code>idx</code> to <code>p</code>, which itself is a point on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> the power manifold is build on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1528-L1533">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport the tangent vector <code>X</code>at <code>p</code> to <code>q</code> on the <a href="#ManifoldsBase.PowerManifold"><code>PowerManifold</code></a> <code>M</code> using an <a href="../vector_transports/#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>m</code>. This method is performed elementwise, i.e. the method <code>m</code> has to be implemented on the base manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/PowerManifold.jl#L1663-L1670">source</a></section></article><h2 id="ProductManifold"><a class="docs-heading-anchor" href="#ProductManifold">Product Manifold</a><a id="ProductManifold-1"></a><a class="docs-heading-anchor-permalink" href="#ProductManifold" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.InverseProductRetraction" href="#ManifoldsBase.InverseProductRetraction"><code>ManifoldsBase.InverseProductRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InverseProductRetraction(retractions::AbstractInverseRetractionMethod...)</code></pre><p>Product inverse retraction of <code>inverse retractions</code>. Works on <a href="#ProductManifold"><code>ProductManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProductBasisData" href="#ManifoldsBase.ProductBasisData"><code>ManifoldsBase.ProductBasisData</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductBasisData</code></pre><p>A typed tuple to store tuples of data of stored/precomputed bases for a <a href="#ProductManifold"><code>ProductManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProductManifold" href="#ManifoldsBase.ProductManifold"><code>ManifoldsBase.ProductManifold</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductManifold{ùîΩ,TM&lt;:Tuple} &lt;: AbstractManifold{ùîΩ}</code></pre><p>Product manifold <span>$M_1 √ó M_2 √ó ‚Ä¶  √ó M_n$</span> with product geometry.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ProductManifold(M_1, M_2, ..., M_n)</code></pre><p>generates the product manifold <span>$M_1 √ó M_2 √ó ‚Ä¶ √ó M_n$</span>. Alternatively, the same manifold can be contructed using the <code>√ó</code> operator: <code>M_1 √ó M_2 √ó M_3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProductMetric" href="#ManifoldsBase.ProductMetric"><code>ManifoldsBase.ProductMetric</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductMetric &lt;: AbstractMetric</code></pre><p>A type to represent the product of metrics for a <a href="#ProductManifold"><code>ProductManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L67-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProductRetraction" href="#ManifoldsBase.ProductRetraction"><code>ManifoldsBase.ProductRetraction</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductRetraction(retractions::AbstractRetractionMethod...)</code></pre><p>Product retraction of <code>retractions</code>. Works on <a href="#ProductManifold"><code>ProductManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ProductVectorTransport" href="#ManifoldsBase.ProductVectorTransport"><code>ManifoldsBase.ProductVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProductVectorTransport(methods::AbstractVectorTransportMethod...)</code></pre><p>Product vector transport type of <code>methods</code>. Works on <a href="#ProductManifold"><code>ProductManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{ProductManifold, Vararg{Any}}" href="#Base.exp-Tuple{ProductManifold, Vararg{Any}}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(M::ProductManifold, p, X)</code></pre><p>compute the exponential map from <code>p</code> in the direction of <code>X</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>, which is the elementwise exponential map on the internal manifolds that build <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L394-L399">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{ProductManifold, Integer}" href="#Base.getindex-Tuple{ProductManifold, Integer}"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(M::ProductManifold, i)
M[i]</code></pre><p>access the <code>i</code>th manifold component from the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, &lt;:ProductManifold}, Integer}} where ùîΩ" href="#Base.getindex-Union{Tuple{ùîΩ}, Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, &lt;:ProductManifold}, Integer}} where ùîΩ"><code>Base.getindex</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(M::TangentSpace{ùîΩ,&lt;:ProductManifold}, i::Integer)
TpM[i]</code></pre><p>Access the <code>i</code>th manifold component from a <a href="#ProductManifold"><code>ProductManifold</code></a>s&#39; tangent space <code>TpM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{ProductManifold, Vararg{Any}}" href="#Base.log-Tuple{ProductManifold, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(M::ProductManifold, p, q)</code></pre><p>Compute the logarithmic map from <code>p</code> to <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>, which can be computed using the logarithmic maps of the manifolds elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L689-L694">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cross-Tuple{Vararg{AbstractInverseRetractionMethod}}" href="#LinearAlgebra.cross-Tuple{Vararg{AbstractInverseRetractionMethod}}"><code>LinearAlgebra.cross</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√ó(m, n)
cross(m, n)
cross(m1, m2, m3,...)</code></pre><p>Return the <a href="#ManifoldsBase.InverseProductRetraction"><code>InverseProductRetraction</code></a> For two or more <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>s, where for the case that one of them is a <a href="#ManifoldsBase.InverseProductRetraction"><code>InverseProductRetraction</code></a> itself, the other is either prepended (if <code>r</code> is a product) or appenden (if <code>s</code>) is. If both <a href="#ManifoldsBase.InverseProductRetraction"><code>InverseProductRetraction</code></a>s, they are combined into one keeping the order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L302-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cross-Tuple{Vararg{AbstractManifold}}" href="#LinearAlgebra.cross-Tuple{Vararg{AbstractManifold}}"><code>LinearAlgebra.cross</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√ó(M, N)
cross(M, N)
cross(M1, M2, M3,...)</code></pre><p>Return the <a href="#ProductManifold"><code>ProductManifold</code></a> For two <code>AbstractManifold</code>s <code>M</code> and <code>N</code>, where for the case that one of them is a <a href="#ProductManifold"><code>ProductManifold</code></a> itself, the other is either prepended (if <code>N</code> is a product) or appenden (if <code>M</code>) is. If both are product manifold, they are combined into one product manifold, keeping the order.</p><p>For the case that more than one is a product manifold of these is build with the same approach as above</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L251-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cross-Tuple{Vararg{AbstractRetractionMethod}}" href="#LinearAlgebra.cross-Tuple{Vararg{AbstractRetractionMethod}}"><code>LinearAlgebra.cross</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√ó(m, n)
cross(m, n)
cross(m1, m2, m3,...)</code></pre><p>Return the <a href="#ManifoldsBase.ProductRetraction"><code>ProductRetraction</code></a> For two or more <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>s, where for the case that one of them is a <a href="#ManifoldsBase.ProductRetraction"><code>ProductRetraction</code></a> itself, the other is either prepended (if <code>m</code> is a product) or appenden (if <code>n</code>) is. If both <a href="#ManifoldsBase.ProductRetraction"><code>ProductRetraction</code></a>s, they are combined into one keeping the order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L278-L287">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.cross-Tuple{Vararg{AbstractVectorTransportMethod}}" href="#LinearAlgebra.cross-Tuple{Vararg{AbstractVectorTransportMethod}}"><code>LinearAlgebra.cross</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">√ó(m, n)
cross(m, n)
cross(m1, m2, m3,...)</code></pre><p>Return the <a href="#ManifoldsBase.ProductVectorTransport"><code>ProductVectorTransport</code></a> For two or more <a href="../vector_transports/#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>s, where for the case that one of them is a <a href="#ManifoldsBase.ProductVectorTransport"><code>ProductVectorTransport</code></a> itself, the other is either prepended (if <code>r</code> is a product) or appenden (if <code>s</code>) is. If both <a href="#ManifoldsBase.ProductVectorTransport"><code>ProductVectorTransport</code></a>s, they are combined into one keeping the order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L336-L345">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{ProductManifold, Any, Any}" href="#LinearAlgebra.norm-Tuple{ProductManifold, Any, Any}"><code>LinearAlgebra.norm</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">norm(M::ProductManifold, p, X)</code></pre><p>Compute the norm of <code>X</code> from the tangent space of <code>p</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a>, i.e. from the element wise norms the 2-norm is computed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L727-L732">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Weingarten-Tuple{ProductManifold, Any, Any, Any}" href="#ManifoldsBase.Weingarten-Tuple{ProductManifold, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Y = Weingarten(M::ProductManifold, p, X, V)
Weingarten!(M::ProductManifold, Y, p, X, V)</code></pre><p>Since the metric decouples, also the computation of the Weingarten map <span>$\mathcal W_p$</span> can be computed elementwise on the single elements of the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1174-L1180">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.change_metric-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_metric-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_metric(M::ProductManifold, ::AbstractMetric, p, X)</code></pre><p>Since the metric on a product manifold decouples, the change of metric can be done elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L136-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.change_representer-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}" href="#ManifoldsBase.change_representer-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">change_representer(M::ProductManifold, ::AbstractMetric, p, X)</code></pre><p>Since the metric on a product manifold decouples, the change of a representer can be done elementwise</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L118-L122">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_point-Tuple{ProductManifold, Any}" href="#ManifoldsBase.check_point-Tuple{ProductManifold, Any}"><code>ManifoldsBase.check_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_point(M::ProductManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is a valid point on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>. If <code>p</code> is not a point on <code>M</code> a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a>.consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_size-Tuple{ProductManifold, Any}" href="#ManifoldsBase.check_size-Tuple{ProductManifold, Any}"><code>ManifoldsBase.check_size</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_size(M::ProductManifold, p; kwargs...)</code></pre><p>Check whether <code>p</code> is of valid size on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>. If <code>p</code> has components of wrong size a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a>.consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L178-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.check_vector-Tuple{ProductManifold, Any, Any}" href="#ManifoldsBase.check_vector-Tuple{ProductManifold, Any, Any}"><code>ManifoldsBase.check_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">check_vector(M::ProductManifold, p, X; kwargs... )</code></pre><p>Check whether <code>X</code> is a tangent vector to <code>p</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>, i.e. all projections to base manifolds must be respective tangent vectors. If <code>X</code> is not a tangent vector to <code>p</code> on <code>M</code> a <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/functions.html#ManifoldsBase.CompositeManifoldError"><code>CompositeManifoldError</code></a>.consisting of all error messages of the components, for which the tests fail is returned.</p><p>The tolerance for the last test can be set using the <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L221-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{ProductManifold, Any, Any}" href="#ManifoldsBase.distance-Tuple{ProductManifold, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::ProductManifold, p, q)</code></pre><p>Compute the distance between two points <code>p</code> and <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>, which is the 2-norm of the elementwise distances on the internal manifolds that build <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L375-L380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.get_component-Tuple{ProductManifold, Any, Any}" href="#ManifoldsBase.get_component-Tuple{ProductManifold, Any, Any}"><code>ManifoldsBase.get_component</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_component(M::ProductManifold, p, i)</code></pre><p>Get the <code>i</code>th component of a point <code>p</code> on a <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L443-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{ProductManifold, Vararg{Any}}" href="#ManifoldsBase.injectivity_radius-Tuple{ProductManifold, Vararg{Any}}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(M::ProductManifold)
injectivity_radius(M::ProductManifold, x)</code></pre><p>Compute the injectivity radius on the <a href="#ProductManifold"><code>ProductManifold</code></a>, which is the minimum of the factor manifolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L560-L566">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{ProductManifold, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{ProductManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::ProductManifold, p, X, Y)</code></pre><p>compute the inner product of two tangent vectors <code>X</code>, <code>Y</code> from the tangent space at <code>p</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>, which is just the sum of the internal manifolds that build <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L598-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, AbstractInverseRetractionMethod}" href="#ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, AbstractInverseRetractionMethod}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::ProductManifold, p, q, m::AbstractInverseRetractionMethod)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using an <a href="../retractions/#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>, which is used on each manifold of the product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L626-L632">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, InverseProductRetraction}" href="#ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, InverseProductRetraction}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inverse_retract(M::ProductManifold, p, q, m::InverseProductRetraction)</code></pre><p>Compute the inverse retraction from <code>p</code> with respect to <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using an <a href="#ManifoldsBase.InverseProductRetraction"><code>InverseProductRetraction</code></a>, which by default encapsulates a inverse retraction for each manifold of the product. Then this method is performed elementwise, so the encapsulated inverse retraction methods have to be available per factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L616-L623">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{ProductManifold}" href="#ManifoldsBase.is_flat-Tuple{ProductManifold}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(::ProductManifold)</code></pre><p>Return true if and only if all component manifolds of <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> are flat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L680-L684">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{ProductManifold}" href="#ManifoldsBase.manifold_dimension-Tuple{ProductManifold}"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(M::ProductManifold)</code></pre><p>Return the manifold dimension of the <a href="#ProductManifold"><code>ProductManifold</code></a>, which is the sum of the manifold dimensions the product is made of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L708-L713">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.number_of_components-Union{Tuple{ProductManifold{ùîΩ, &lt;:Tuple{Vararg{Any, N}}}}, Tuple{N}, Tuple{ùîΩ}} where {ùîΩ, N}" href="#ManifoldsBase.number_of_components-Union{Tuple{ProductManifold{ùîΩ, &lt;:Tuple{Vararg{Any, N}}}}, Tuple{N}, Tuple{ùîΩ}} where {ùîΩ, N}"><code>ManifoldsBase.number_of_components</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">number_of_components(M::ProductManifold{&lt;:NTuple{N,Any}}) where {N}</code></pre><p>Calculate the number of manifolds multiplied in the given <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L745-L749">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, AbstractRetractionMethod}" href="#ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, AbstractRetractionMethod}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::ProductManifold, p, X, m::AbstractRetractionMethod)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using the <a href="../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> on every manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L842-L847">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, ProductRetraction}" href="#ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, ProductRetraction}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">retract(M::ProductManifold, p, X, m::ProductRetraction)</code></pre><p>Compute the retraction from <code>p</code> with tangent vector <code>X</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using an <a href="#ManifoldsBase.ProductRetraction"><code>ProductRetraction</code></a>, which by default encapsulates retractions of the base manifolds. Then this method is performed elementwise, so the encapsulated retractions method has to be one that is available on the manifolds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L832-L839">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.riemann_tensor-Tuple{ProductManifold, Vararg{Any, 4}}" href="#ManifoldsBase.riemann_tensor-Tuple{ProductManifold, Vararg{Any, 4}}"><code>ManifoldsBase.riemann_tensor</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">riemann_tensor(M::ProductManifold, p, X, Y, Z)</code></pre><p>Compute the Riemann tensor at point from <code>p</code> with tangent vectors <code>X</code>, <code>Y</code> and <code>Z</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L883-L888">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature-Tuple{ProductManifold, Any, Any, Any}" href="#ManifoldsBase.sectional_curvature-Tuple{ProductManifold, Any, Any, Any}"><code>ManifoldsBase.sectional_curvature</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature(M::ProductManifold, p, X, Y)</code></pre><p>Compute the sectional curvature of a manifold <span>$\mathcal M$</span> at a point <span>$p \in \mathcal M$</span> on two linearly independent tangent vectors at <span>$p$</span>. It may be 0 for a product of non-flat manifolds if projections of <code>X</code> and <code>Y</code> on subspaces corresponding to component manifolds are not linearly independent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L904-L911">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_max-Tuple{ProductManifold}" href="#ManifoldsBase.sectional_curvature_max-Tuple{ProductManifold}"><code>ManifoldsBase.sectional_curvature_max</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_max(M::ProductManifold)</code></pre><p>Upper bound on sectional curvature of <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>. It is the maximum of sectional curvatures of component manifolds and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors <code>(X_1, 0)</code> and <code>(0, X_2)</code> is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L927-L934">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.sectional_curvature_min-Tuple{ProductManifold}" href="#ManifoldsBase.sectional_curvature_min-Tuple{ProductManifold}"><code>ManifoldsBase.sectional_curvature_min</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sectional_curvature_min(M::ProductManifold)</code></pre><p>Lower bound on sectional curvature of <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code>. It is the minimum of sectional curvatures of component manifolds and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors <code>(X_1, 0)</code> and <code>(0, X_2)</code> is 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L944-L951">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.select_from_tuple-Union{Tuple{P}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Val{P}}} where {N, P}" href="#ManifoldsBase.select_from_tuple-Union{Tuple{P}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Val{P}}} where {N, P}"><code>ManifoldsBase.select_from_tuple</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">select_from_tuple(t::NTuple{N, Any}, positions::Val{P})</code></pre><p>Selects elements of tuple <code>t</code> at positions specified by the second argument. For example <code>select_from_tuple((&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), Val((3, 1, 1)))</code> returns <code>(&quot;c&quot;, &quot;a&quot;, &quot;a&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L961-L967">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.set_component!-Tuple{ProductManifold, Any, Any, Any}" href="#ManifoldsBase.set_component!-Tuple{ProductManifold, Any, Any, Any}"><code>ManifoldsBase.set_component!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_component!(M::ProductManifold, q, p, i)</code></pre><p>Set the <code>i</code>th component of a point <code>q</code> on a <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> to <code>p</code>, where <code>p</code> is a point on the <a href="https://juliamanifolds.github.io/ManifoldsBase.jl/stable/types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a>  this factor of the product manifold consists of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L975-L979">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.submanifold-Tuple{ProductManifold, Integer}" href="#ManifoldsBase.submanifold-Tuple{ProductManifold, Integer}"><code>ManifoldsBase.submanifold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submanifold(M::ProductManifold, i::Integer)</code></pre><p>Extract the <code>i</code>th factor of the product manifold <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1065-L1069">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.submanifold-Tuple{ProductManifold, Val}" href="#ManifoldsBase.submanifold-Tuple{ProductManifold, Val}"><code>ManifoldsBase.submanifold</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submanifold(M::ProductManifold, i::Val)
submanifold(M::ProductManifold, i::AbstractVector)</code></pre><p>Extract the factor of the product manifold <code>M</code> indicated by indices in <code>i</code>. For example, for <code>i</code> equal to <code>Val((1, 3))</code> the product manifold constructed from the first and the third factor is returned.</p><p>The version with <code>AbstractVector</code> is not type-stable, for better preformance use <code>Val</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1072-L1081">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.submanifold_component-Tuple" href="#ManifoldsBase.submanifold_component-Tuple"><code>ManifoldsBase.submanifold_component</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submanifold_component(M::AbstractManifold, p, i::Integer)
submanifold_component(M::AbstractManifold, p, ::Val{i}) where {i}
submanifold_component(p, i::Integer)
submanifold_component(p, ::Val{i}) where {i}</code></pre><p>Project the product array <code>p</code> on <code>M</code> to its <code>i</code>th component. A new array is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1208-L1215">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.submanifold_components-Tuple" href="#ManifoldsBase.submanifold_components-Tuple"><code>ManifoldsBase.submanifold_components</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">submanifold_components(M::AbstractManifold, p)
submanifold_components(p)</code></pre><p>Get the projected components of <code>p</code> on the submanifolds of <code>M</code>. The components are returned in a Tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1223-L1228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, AbstractVectorTransportMethod}" href="#ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::ProductManifold, p, X, q, m::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport the tangent vector <code>X</code> at <code>p</code> to <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using an <a href="../vector_transports/#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>m</code> on each manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1133-L1139">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, ProductVectorTransport}" href="#ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, ProductVectorTransport}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::ProductManifold, p, X, q, m::ProductVectorTransport)</code></pre><p>Compute the vector transport the tangent vector <code>X</code> at <code>p</code> to <code>q</code> on the <a href="#ProductManifold"><code>ProductManifold</code></a> <code>M</code> using a <a href="#ManifoldsBase.ProductVectorTransport"><code>ProductVectorTransport</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1125-L1130">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.ziptuples-Union{Tuple{M}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, M}}}} where {N, M}" href="#ManifoldsBase.ziptuples-Union{Tuple{M}, Tuple{N}, Tuple{Tuple{Vararg{Any, N}}, Tuple{Vararg{Any, M}}}} where {N, M}"><code>ManifoldsBase.ziptuples</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ziptuples(a, b[, c[, d[, e]]])</code></pre><p>Zips tuples <code>a</code>, <code>b</code>, and remaining in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/ProductManifold.jl#L1232-L1237">source</a></section></article><h2 id="Fiber"><a class="docs-heading-anchor" href="#Fiber">Fiber</a><a id="Fiber-1"></a><a class="docs-heading-anchor-permalink" href="#Fiber" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Fiber" href="#ManifoldsBase.Fiber"><code>ManifoldsBase.Fiber</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Fiber{ùîΩ,TFiber&lt;:FiberType,TM&lt;:AbstractManifold{ùîΩ},TX} &lt;: AbstractManifold{ùîΩ}</code></pre><p>A fiber of a fiber bundle at a point <code>p</code> on the manifold.</p><p>This fiber itself is also a <code>manifold</code>. For vector fibers it&#39;s by default flat and hence isometric to the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> manifold.</p><p><strong>Fields</strong></p><ul><li><code>manifold</code>    ‚Äì base space of the fiber bundle</li><li><code>point</code>       ‚Äì a point <span>$p$</span> from the base space; the fiber corresponds to the preimage                 by bundle projection <span>$\pi^{-1}(\{p\})$</span>.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">Fiber(M::AbstractManifold, p, fiber_type::FiberType)</code></pre><p>A fiber of type <code>fiber_type</code> at point <code>p</code> from the manifold <code>manifold</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/Fiber.jl#L9-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.FiberType" href="#ManifoldsBase.FiberType"><code>ManifoldsBase.FiberType</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type FiberType end</code></pre><p>An abstract type for fiber types that can be used within <a href="#Fiber"><code>Fiber</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/Fiber.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.VectorSpaceFiber" href="#ManifoldsBase.VectorSpaceFiber"><code>ManifoldsBase.VectorSpaceFiber</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorSpaceFiber{ùîΩ,M,TSpaceType} = Fiber{ùîΩ,TSpaceType,M}
    where {ùîΩ,M&lt;:AbstractManifold{ùîΩ},TSpaceType&lt;:VectorSpaceType}</code></pre><p>Alias for a <a href="#Fiber"><code>Fiber</code></a> when the fiber is a vector space.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/VectorFiber.jl#L2-L7">source</a></section></article><h2 id="Tangent-Space"><a class="docs-heading-anchor" href="#Tangent-Space">Tangent Space</a><a id="Tangent-Space-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-Space" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.CotangentSpace" href="#ManifoldsBase.CotangentSpace"><code>ManifoldsBase.CotangentSpace</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CotangentSpace{ùîΩ,M} = Fiber{ùîΩ,CotangentSpaceType,M} where {ùîΩ,M&lt;:AbstractManifold{ùîΩ}}</code></pre><p>A manifold for the Cotangent space <span>$T^*_p\mathcal M$</span> at a point <span>$p\in\mathcal M$</span>. This is modelled as an alias for <a href="#ManifoldsBase.VectorSpaceFiber"><code>VectorSpaceFiber</code></a> corresponding to <a href="../bases/#ManifoldsBase.CotangentSpaceType"><code>CotangentSpaceType</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">CotangentSpace(M::AbstractManifold, p)</code></pre><p>Return the manifold (vector space) representing the cotangent space <span>$T^*_p\mathcal M$</span> at point <code>p</code>, <span>$p\in\mathcal M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L20-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.TangentSpace" href="#ManifoldsBase.TangentSpace"><code>ManifoldsBase.TangentSpace</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TangentSpace{ùîΩ,M} = Fiber{ùîΩ,TangentSpaceType,M} where {ùîΩ,M&lt;:AbstractManifold{ùîΩ}}</code></pre><p>A manifold for the tangent space <span>$T_p\mathcal M$</span> at a point <span>$p\in\mathcal M$</span>. This is modelled as an alias for <a href="#ManifoldsBase.VectorSpaceFiber"><code>VectorSpaceFiber</code></a> corresponding to <a href="../bases/#ManifoldsBase.TangentSpaceType"><code>TangentSpaceType</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">TangentSpace(M::AbstractManifold, p)</code></pre><p>Return the manifold (vector space) representing the tangent space <span>$T_p\mathcal M$</span> at point <code>p</code>, <span>$p\in\mathcal M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.exp-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}" href="#Base.exp-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}"><code>Base.exp</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exp(TpM::TangentSpace, X, V)</code></pre><p>Exponential map of tangent vectors <code>X</code> from <code>TpM</code> and a direction <code>V</code>, which is also from the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code> since we identify the tangent space of <code>TpM</code> with <code>TpM</code>. The exponential map then simplifies to the sum <code>X+V</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.log-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Vararg{Any}}" href="#Base.log-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log(TpM::TangentSpace, X, Y)</code></pre><p>Logarithmic map on the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code>, calculated as the difference of tangent vectors <code>q</code> and <code>p</code> from <code>TpM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.Weingarten-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}" href="#ManifoldsBase.Weingarten-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}"><code>ManifoldsBase.Weingarten</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Y = Weingarten(TpM::TangentSpace, X, V, A)
Weingarten!(TpM::TangentSpace, Y, p, X, V)</code></pre><p>Compute the Weingarten map <span>$\mathcal W_X$</span> at <code>X</code> on the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code> with respect to the tangent vector <span>$V \in T_p\mathcal M$</span> and the normal vector <span>$A \in N_p\mathcal M$</span>.</p><p>Since this a flat space by itself, the result is always the zero tangent vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L254-L262">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.base_point-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}" href="#ManifoldsBase.base_point-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}"><code>ManifoldsBase.base_point</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">base_point(TpM::TangentSpace)</code></pre><p>Return the base point of the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}" href="#ManifoldsBase.distance-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}"><code>ManifoldsBase.distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distance(M::TangentSpace, X, Y)</code></pre><p>Distance between vectors <code>X</code> and <code>Y</code> from the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code>. It is calculated as the <a href="../functions/#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}"><code>norm</code></a> (induced by the metric on <code>TpM</code>) of their difference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}" href="#ManifoldsBase.injectivity_radius-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}"><code>ManifoldsBase.injectivity_radius</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">injectivity_radius(TpM::TangentSpace)</code></pre><p>Return the injectivity radius on the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code>, which is <span>$‚àû$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L133-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}" href="#ManifoldsBase.inner-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inner(M::TangentSpace, X, V, W)</code></pre><p>For any <span>$X ‚àà T_p\mathcal M$</span> we identify the tangent space <span>$T_X(T_p\mathcal M)$</span> with <span>$T_p\mathcal M$</span> again. Hence an inner product of <span>$V,W$</span> is just the inner product of the tangent space itself. <span>$‚ü®V,W‚ü©_X = ‚ü®V,W‚ü©_p$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.is_flat-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}" href="#ManifoldsBase.is_flat-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}"><code>ManifoldsBase.is_flat</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_flat(::TangentSpace)</code></pre><p>The <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> is a flat manifold, so this returns <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}" href="#ManifoldsBase.manifold_dimension-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}"><code>ManifoldsBase.manifold_dimension</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">manifold_dimension(TpM::TangentSpace)</code></pre><p>Return the dimension of the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <span>$T_p\mathcal M$</span> at <span>$p‚àà\mathcal M$</span>, which is the same as the dimension of the manifold <span>$\mathcal M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.parallel_transport_to-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}" href="#ManifoldsBase.parallel_transport_to-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any, Any}"><code>ManifoldsBase.parallel_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parallel_transport_to(::TangentSpace, X, V, Y)</code></pre><p>Transport the tangent vector <span>$Z ‚àà T_X(T_p\mathcal M)$</span> from <code>X</code> to <code>Y</code>. Since we identify <span>$T_X(T_p\mathcal M) = T_p\mathcal M$</span> and the tangent space is a vector space, parallel transport simplifies to the identity, so this function yields <span>$V$</span> as a result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L188-L194">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}" href="#ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(TpM::TangentSpace, X, V)</code></pre><p>Project the vector <code>V</code> from the embedding of the tangent space <code>TpM</code> (identified with <span>$T_X(T_p\mathcal M)$</span>), that is project the vector <code>V</code> onto the tangent space at <code>TpM.point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}" href="#ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Any}"><code>ManifoldsBase.project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">project(TpM::TangentSpace, X)</code></pre><p>Project the point <code>X</code> from embedding of the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code> onto <code>TpM</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Vararg{Any}}" href="#ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}, Vararg{Any}}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(TpM::TangentSpace, X)</code></pre><p>Zero tangent vector at point <code>X</code> from the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code>, that is the zero tangent vector at point <code>TpM.point</code>, since we identify the tangent space <span>$T_X(T_p\mathcal M)$</span> with <span>$T_p\mathcal M$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L275-L281">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}" href="#ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ùîΩ, TangentSpaceType, M} where {ùîΩ, M&lt;:AbstractManifold{ùîΩ}}}"><code>ManifoldsBase.zero_vector</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_vector(TpM::TangentSpace)</code></pre><p>Zero tangent vector in the <a href="#ManifoldsBase.TangentSpace"><code>TangentSpace</code></a> <code>TpM</code>, that is the zero tangent vector at point <code>TpM.point</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/2ac6a527d55d76378f4bb29496c12456fbc0d0d7/src/TangentSpace.jl#L267-L272">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manifolds/">¬´ Manifolds</a><a class="docs-footer-nextpage" href="../decorator/">Decorating/Extending a Manifold ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Sunday 28 July 2024 16:30">Sunday 28 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
