var documenterSearchIndex = {"docs":
[{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"P.-A.Â Absil, R.Â Mahony and R.Â Sepulchre. Optimization Algorithms on Matrix Manifolds (Princeton University Press, 2008), available online at press.princeton.edu/chapters/absil/.\n\n\n\nN.Â Boumal. An Introduction to Optimization on Smooth Manifolds. FirstÂ Edition (Cambridge University Press, 2023).\n\n\n\nJ.Â Ehlers, F.Â A.Â Pirani and A.Â Schild. Republication of: The geometry of free fall and light propagation. GeneralÂ RelativityÂ andÂ Gravitation 44, 1587â€“1609 (1972).\n\n\n\nM.Â Lorenzi and X.Â Pennec. Efficient Parallel Transport of Deformations in Time Series of Images: From Schild's to Pole Ladder. JournalÂ ofÂ MathematicalÂ ImagingÂ andÂ Vision 50, 5â€“17 (2013), arXiv:00870489.\n\n\n\nP.Â Muralidharan and P.Â T.Â Fletcher. Sasaki metrics for analysis of longitudinal data on manifolds. In: 2012 IEEE Conference on Computer Vision and Pattern Recognition (2012).\n\n\n\nX.Â Pennec. Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXivÂ Preprint (2018), arXiv:1805.11436.\n\n\n\nH.Â Sato and T.Â Iwai. A new,  globally convergent Riemannian conjugate gradient method. Optimization 64, 1011â€“1031 (2013), arXiv:1302.0125.\n\n\n\n","category":"page"},{"location":"metamanifolds/#Meta-Manifolds","page":"Meta-Manifolds","title":"Meta Manifolds","text":"","category":"section"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"While the interface does not provide concrete manifolds itself, it does provide several manifolds that can be build based on a given AbstractManifold instance.","category":"page"},{"location":"metamanifolds/#sec-power-manifold","page":"Meta-Manifolds","title":"(Abstract) power manifold","text":"","category":"section"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"A power manifold is constructed like higher dimensional vector spaces are formed from the real line, just that for every point p = (p_1ldotsp_n)  mathcal M^n on the power manifold mathcal M^n the entries of p are points p_1ldotsp_n  mathcal M on some manifold mathcal M. Note that n can also be replaced by multiple values, such that p is not a vector but a matrix or a multi-index array of points.","category":"page"},{"location":"metamanifolds/#ManifoldsBase.AbstractPowerManifold","page":"Meta-Manifolds","title":"ManifoldsBase.AbstractPowerManifold","text":"AbstractPowerManifold{ğ”½,M,TPR} <: AbstractManifold{ğ”½}\n\nAn abstract AbstractManifold to represent manifolds that are build as powers of another AbstractManifold M with representation type TPR, a subtype of AbstractPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.AbstractPowerRepresentation","page":"Meta-Manifolds","title":"ManifoldsBase.AbstractPowerRepresentation","text":"AbstractPowerRepresentation\n\nAn abstract representation type of points and tangent vectors on a power manifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.NestedPowerRepresentation","page":"Meta-Manifolds","title":"ManifoldsBase.NestedPowerRepresentation","text":"NestedPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is modified in-place, differently than in NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.NestedReplacingPowerRepresentation","page":"Meta-Manifolds","title":"ManifoldsBase.NestedReplacingPowerRepresentation","text":"NestedReplacingPowerRepresentation\n\nRepresentation of points and tangent vectors on a power manifold using arrays of size equal to TSize of a PowerManifold. Each element of such array stores a single point or tangent vector.\n\nFor modifying operations, each element of the outer array is replaced using non-modifying operations, differently than for NestedReplacingPowerRepresentation.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.PowerBasisData","page":"Meta-Manifolds","title":"ManifoldsBase.PowerBasisData","text":"PowerBasisData{TB<:AbstractArray}\n\nData storage for an array of basis data.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.PowerManifold","page":"Meta-Manifolds","title":"ManifoldsBase.PowerManifold","text":"PowerManifold{ğ”½,TM<:AbstractManifold,TSize,TPR<:AbstractPowerRepresentation} <: AbstractPowerManifold{ğ”½,TM}\n\nThe power manifold mathcal M^n_1 n_2    n_d with power geometry.  TSize defines the number of elements along each axis, either statically using  TypeParameter or storing it in a field.\n\nFor example, a manifold-valued time series would be represented by a power manifold with d equal to 1 and n_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (d=2) with n_1 and n_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays.\n\nConstructor\n\nPowerManifold(M::PowerManifold, N_1, N_2, ..., N_d; parameter::Symbol=:field)\nPowerManifold(M::AbstractManifold, NestedPowerRepresentation(), N_1, N_2, ..., N_d; parameter::Symbol=:field)\nM^(N_1, N_2, ..., N_d)\n\nGenerate the power manifold M^N_1  N_2    N_d. By default, a PowerManifold is expanded further, i.e. for M=PowerManifold(N, 3) PowerManifold(M, 2) is equivalent to PowerManifold(N, 3, 2). Points are then 3Ã—2 matrices of points on N. Providing a NestedPowerRepresentation as the second argument to the constructor can be used to nest manifold, i.e. PowerManifold(M, NestedPowerRepresentation(), 2) represents vectors of length 2 whose elements are vectors of length 3 of points on N in a nested array representation.\n\nThe third signature M^(...) is equivalent to the first one, and hence either yields a combination of power manifolds to one larger power manifold, or a power manifold with the default representation.\n\nSince there is no default AbstractPowerRepresentation within this interface, the ^ operator is only available for PowerManifolds and concatenates dimensions.\n\nparameter: whether a type parameter should be used to store n. By default size is stored in a field. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#Base.copyto!-Tuple{AbstractPowerManifold{ğ”½, <:AbstractManifold{ğ”½}, NestedPowerRepresentation} where ğ”½, Any, Any, Any}","page":"Meta-Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, Y, p, X)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, B, a, A) for all elements A, a and B of X, p, and Y, respectively.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.copyto!-Tuple{AbstractPowerManifold{ğ”½, <:AbstractManifold{ğ”½}, NestedPowerRepresentation} where ğ”½, Any, Any}","page":"Meta-Manifolds","title":"Base.copyto!","text":"copyto!(M::PowerManifoldNested, q, p)\n\nCopy the values elementwise, i.e. call copyto!(M.manifold, b, a) for all elements a and b of p and q, respectively.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.exp-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta-Manifolds","title":"Base.exp","text":"exp(M::AbstractPowerManifold, p, X)\n\nCompute the exponential map from p in direction X on the AbstractPowerManifold M, which can be computed using the base manifolds exponential map element-wise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.fill!-Tuple{Any, Any, AbstractPowerManifold{ğ”½, <:AbstractManifold{ğ”½}, NestedReplacingPowerRepresentation} where ğ”½}","page":"Meta-Manifolds","title":"Base.fill!","text":"fill!(P, p, M::AbstractPowerManifold)\n\nFill a point P on the AbstractPowerManifold M, setting every entry to p.\n\nnote: Note\nwhile usually the manifold is the first argument in all functions in ManifoldsBase.jl, we follow the signature of fill!, where the power manifold serves are the size information.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.fill-Tuple{Any, AbstractPowerManifold}","page":"Meta-Manifolds","title":"Base.fill","text":"fill(p, M::AbstractPowerManifold)\n\nCreate a point on the AbstractPowerManifold M, where every entry is set to the point p.\n\nnote: Note\nwhile usually the manifold is a first argument in all functions in ManifoldsBase.jl, we follow the signature of fill, where the power manifold serves are the size information.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.getindex-Tuple{AbstractArray, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta-Manifolds","title":"Base.getindex","text":"getindex(p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\np[M::AbstractPowerManifold, i...]\n\nAccess the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.getindex-Union{Tuple{ğ”½}, Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType, <:AbstractPowerManifold}, Vararg{Union{Colon, Integer, AbstractVector}}}} where ğ”½","page":"Meta-Manifolds","title":"Base.getindex","text":"getindex(M::TangentSpace{ğ”½, AbstractPowerManifold}, i...)\nTpM[i...]\n\nAccess the ith manifold component from an AbstractPowerManifolds' tangent space TpM.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.log-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta-Manifolds","title":"Base.log","text":"log(M::AbstractPowerManifold, p, q)\n\nCompute the logarithmic map from p to q on the AbstractPowerManifold M, which can be computed using the base manifolds logarithmic map elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.setindex!-Tuple{AbstractArray, Any, AbstractPowerManifold, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta-Manifolds","title":"Base.setindex!","text":"setindex!(q, p, M::AbstractPowerManifold, i::Union{Integer,Colon,AbstractVector}...)\nq[M::AbstractPowerManifold, i...] = p\n\nSet the element(s) at index [i...] of a point q on an AbstractPowerManifold M by linear or multidimensional indexing to q. See also Array Indexing in Julia.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.view-Tuple{AbstractArray, AbstractPowerManifold{ğ”½, <:AbstractManifold{ğ”½}, NestedPowerRepresentation} where ğ”½, Vararg{Union{Colon, Integer, AbstractVector}}}","page":"Meta-Manifolds","title":"Base.view","text":"view(p, M::PowerManifoldNested, i::Union{Integer,Colon,AbstractVector}...)\n\nGet the view of the element(s) at index [i...] of a point p on an AbstractPowerManifold M by linear or multidimensional indexing.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.norm","page":"Meta-Manifolds","title":"LinearAlgebra.norm","text":"norm(M::AbstractPowerManifold, p, X, r::Real=2)\n\nCompute the norm of X from the tangent space of p on an AbstractPowerManifold M, i.e. from the element wise norms r-norm is computed, where the default r=2 yields the Frobenius norm is computed.\n\n\n\n\n\n","category":"function"},{"location":"metamanifolds/#ManifoldsBase.Weingarten-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::AbstractPowerManifold, p, X, V)\nWeingarten!(M::AbstractPowerManifold, Y, p, X, V)\n\nSince the metric decouples, also the computation of the Weingarten map mathcal W_p can be computed elementwise on the single elements of the PowerManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase._allocate_access_nested-Tuple{AbstractPowerManifold{ğ”½, <:AbstractManifold{ğ”½}, NestedPowerRepresentation} where ğ”½, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase._allocate_access_nested","text":"_allocate_access_nested(M::PowerManifoldNested, y, i)\n\nHelper function for allocate_result on PowerManifoldNested. In allocation y can be a number in which case _access_nested wouldn't work.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase._parameter_symbol-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase._parameter_symbol","text":"_parameter_symbol(M::PowerManifold)\n\nReturn :field if size of PowerManifold M is stored in a field and :type if in a TypeParameter.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.change_metric-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.change_metric","text":"change_metric(M::AbstractPowerManifold, ::AbstractMetric, p, X)\n\nSince the metric on a power manifold decouples, the change of metric can be done elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.change_representer-Tuple{AbstractPowerManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.change_representer","text":"change_representer(M::AbstractPowerManifold, ::AbstractMetric, p, X)\n\nSince the metric on a power manifold decouples, the change of a representer can be done elementwise\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_point-Tuple{AbstractPowerManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractPowerManifold, p; kwargs...)\n\nCheck whether p is a valid point on an AbstractPowerManifold M, i.e. each element of p has to be a valid point on the base manifold. If p is not a point on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_power_size-Tuple{AbstractPowerManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_power_size","text":"check_power_size(M, p)\ncheck_power_size(M, p, X)\n\nCheck whether phas the right size to represent points onM`` generically, i.e. just checking the overall sizes, not the individual ones per manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_vector-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractPowerManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p an the AbstractPowerManifold M, i.e. atfer check_point(M, p), and all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.default_inverse_retraction_method-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::PowerManifold)\n\nUse the default inverse retraction method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::PowerManifold)\n\nUse the default retraction method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::PowerManifold)\n\nUse the default vector transport method of the internal M.manifold also in defaults of functions defined for the power manifold, meaning that this is used elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.distance","page":"Meta-Manifolds","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q, r::Real=2)\ndistance(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod=LogarithmicInverseRetraction(), r::Real=2)\n\nCompute the distance between q and p on an AbstractPowerManifold.\n\nFirst, the componentwise distances are computed using the Riemannian distance function on M.manifold. These can be approximated using the norm of an AbstractInverseRetractionMethod m. This yields an array of distance values.\n\nSecond, we compute the r-norm on this array of distances. This is also the only place, there the r is used.\n\n\n\n\n\n","category":"function"},{"location":"metamanifolds/#ManifoldsBase.distance-Tuple{AbstractPowerManifold, Any, Any, Real}","page":"Meta-Manifolds","title":"ManifoldsBase.distance","text":"distance(M::AbstractPowerManifold, p, q, r::Real=2)\ndistance(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod=LogarithmicInverseRetraction(), r::Real=2)\n\nCompute the distance between q and p on an AbstractPowerManifold.\n\nFirst, the componentwise distances are computed using the Riemannian distance function on M.manifold. These can be approximated using the norm of an AbstractInverseRetractionMethod m. This yields an array of distance values.\n\nSecond, we compute the r-norm on this array of distances. This is also the only place, there the r is used.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.get_component-Tuple{AbstractPowerManifold, Any, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.get_component","text":"get_component(M::AbstractPowerManifold, p, idx...)\n\nGet the component of a point p on an AbstractPowerManifold M at index idx.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.has_components-Tuple{AbstractPowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.has_components","text":"has_components(::AbstractPowerManifold)\n\nReturn true, since points on an AbstractPowerManifold consist of components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.injectivity_radius-Tuple{AbstractPowerManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractPowerManifold[, p])\n\nthe injectivity radius on an AbstractPowerManifold is for the global case equal to the one of its base manifold. For a given point p it's equal to the minimum of all radii in the array entries.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inner-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.inner","text":"inner(M::AbstractPowerManifold, p, X, Y)\n\nCompute the inner product of X and Y from the tangent space at p on an AbstractPowerManifold M, i.e. for each arrays entry the tangent vector entries from X and Y are in the tangent space of the corresponding element from p. The inner product is then the sum of the elementwise inner products.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractPowerManifold, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the inverse retraction from p with respect to q on an AbstractPowerManifold M using an AbstractInverseRetractionMethod. Then this method is performed elementwise, so the inverse retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.is_flat-Tuple{AbstractPowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractPowerManifold)\n\nReturn true if AbstractPowerManifold is flat. It is flat if and only if the wrapped manifold is flat.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.manifold_dimension-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::PowerManifold)\n\nReturns the manifold-dimension of an PowerManifold M =mathcal N = (mathcal M)^n_1n_d, i.e. with n=(n_1n_d) the array size of the power manifold and d_mathcal M the dimension of the base manifold mathcal M, the manifold is of dimension\n\ndim(mathcal N) = dim(mathcal M)prod_i=1^d n_i = n_1n_2 n_d dim(mathcal M)\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.power_dimensions-Tuple{PowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.power_dimensions","text":"power_dimensions(M::PowerManifold)\n\nreturn the power of M,\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p, X)\n\nProject the point X onto the tangent space at p on the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.project","text":"project(M::AbstractPowerManifold, p)\n\nProject the point p from the embedding onto the AbstractPowerManifold M by projecting all components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.retract","text":"retract(M::AbstractPowerManifold, p, X, method::AbstractRetractionMethod)\n\nCompute the retraction from p with tangent vector X on an AbstractPowerManifold M using a AbstractRetractionMethod. Then this method is performed elementwise, so the retraction method has to be one that is available on the base AbstractManifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.riemann_tensor-Tuple{AbstractPowerManifold, Vararg{Any, 4}}","page":"Meta-Manifolds","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractPowerManifold, p, X, Y, Z)\n\nCompute the Riemann tensor at point from p with tangent vectors X, Y and Z on the AbstractPowerManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature-Tuple{AbstractPowerManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(M::AbstractPowerManifold, p, X, Y)\n\nCompute the sectional curvature of a power manifold manifold mathcal M at a point p in mathcal M on two linearly independent tangent vectors at p. It may be 0 for  if projections of X and Y on subspaces corresponding to component manifolds are not linearly independent.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature_max-Tuple{AbstractPowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(M::AbstractPowerManifold)\n\nUpper bound on sectional curvature of AbstractPowerManifold M. It is the maximum of sectional curvature of the wrapped manifold and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors (X_1, 0, ... 0) and (0, X_2, 0, ..., 0) is 0.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature_min-Tuple{AbstractPowerManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::AbstractPowerManifold)\n\nLower bound on sectional curvature of AbstractPowerManifold M. It is the minimum of sectional curvature of the wrapped manifold and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors (X_1, 0, ... 0) and (0, X_2, 0, ..., 0) is 0.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.set_component!-Tuple{AbstractPowerManifold, Any, Any, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.set_component!","text":"set_component!(M::AbstractPowerManifold, q, p, idx...)\n\nSet the component of a point q on an AbstractPowerManifold M at index idx to p, which itself is a point on the AbstractManifold the power manifold is build on.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}","page":"Meta-Manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractPowerManifold, p, X, q, method::AbstractVectorTransportMethod)\n\nCompute the vector transport the tangent vector Xat p to q on the PowerManifold M using an AbstractVectorTransportMethod m. This method is performed elementwise, i.e. the method m has to be implemented on the base manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ProductManifold","page":"Meta-Manifolds","title":"Product Manifold","text":"","category":"section"},{"location":"metamanifolds/#ManifoldsBase.InverseProductRetraction","page":"Meta-Manifolds","title":"ManifoldsBase.InverseProductRetraction","text":"InverseProductRetraction(retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.ProductBasisData","page":"Meta-Manifolds","title":"ManifoldsBase.ProductBasisData","text":"ProductBasisData\n\nA typed tuple to store tuples of data of stored/precomputed bases for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.ProductManifold","page":"Meta-Manifolds","title":"ManifoldsBase.ProductManifold","text":"ProductManifold{ğ”½,TM<:Tuple} <: AbstractManifold{ğ”½}\n\nProduct manifold M_1  M_2     M_n with product geometry.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1  M_2    M_n. Alternatively, the same manifold can be contructed using the Ã— operator: M_1 Ã— M_2 Ã— M_3.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.ProductMetric","page":"Meta-Manifolds","title":"ManifoldsBase.ProductMetric","text":"ProductMetric <: AbstractMetric\n\nA type to represent the product of metrics for a ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.ProductRetraction","page":"Meta-Manifolds","title":"ManifoldsBase.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.ProductVectorTransport","page":"Meta-Manifolds","title":"ManifoldsBase.ProductVectorTransport","text":"ProductVectorTransport(methods::AbstractVectorTransportMethod...)\n\nProduct vector transport type of methods. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#Base.exp-Tuple{ProductManifold, Any, Any}","page":"Meta-Manifolds","title":"Base.exp","text":"exp(M::ProductManifold, p, X)\n\ncompute the exponential map from p in the direction of X on the ProductManifold M, which is the elementwise exponential map on the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.getindex-Tuple{ProductManifold, Integer}","page":"Meta-Manifolds","title":"Base.getindex","text":"getindex(M::ProductManifold, i)\nM[i]\n\naccess the ith manifold component from the ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.getindex-Union{Tuple{ğ”½}, Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType, <:ProductManifold}, Integer}} where ğ”½","page":"Meta-Manifolds","title":"Base.getindex","text":"getindex(M::TangentSpace{ğ”½,<:ProductManifold}, i::Integer)\nTpM[i]\n\nAccess the ith manifold component from a ProductManifolds' tangent space TpM.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.log-Tuple{ProductManifold, Vararg{Any}}","page":"Meta-Manifolds","title":"Base.log","text":"log(M::ProductManifold, p, q)\n\nCompute the logarithmic map from p to q on the ProductManifold M, which can be computed using the logarithmic maps of the manifolds elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.cross-Tuple{Vararg{AbstractInverseRetractionMethod}}","page":"Meta-Manifolds","title":"LinearAlgebra.cross","text":"Ã—(m, n)\ncross(m, n)\ncross(m1, m2, m3,...)\n\nReturn the InverseProductRetraction For two or more AbstractInverseRetractionMethods, where for the case that one of them is a InverseProductRetraction itself, the other is either prepended (if r is a product) or appenden (if s) is. If both InverseProductRetractions, they are combined into one keeping the order.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.cross-Tuple{Vararg{AbstractManifold}}","page":"Meta-Manifolds","title":"LinearAlgebra.cross","text":"Ã—(M, N)\ncross(M, N)\ncross(M1, M2, M3,...)\n\nReturn the ProductManifold For two AbstractManifolds M and N, where for the case that one of them is a ProductManifold itself, the other is either prepended (if N is a product) or appenden (if M) is. If both are product manifold, they are combined into one product manifold, keeping the order.\n\nFor the case that more than one is a product manifold of these is build with the same approach as above\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.cross-Tuple{Vararg{AbstractRetractionMethod}}","page":"Meta-Manifolds","title":"LinearAlgebra.cross","text":"Ã—(m, n)\ncross(m, n)\ncross(m1, m2, m3,...)\n\nReturn the ProductRetraction For two or more AbstractRetractionMethods, where for the case that one of them is a ProductRetraction itself, the other is either prepended (if m is a product) or appenden (if n) is. If both ProductRetractions, they are combined into one keeping the order.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.cross-Tuple{Vararg{AbstractVectorTransportMethod}}","page":"Meta-Manifolds","title":"LinearAlgebra.cross","text":"Ã—(m, n)\ncross(m, n)\ncross(m1, m2, m3,...)\n\nReturn the ProductVectorTransport For two or more AbstractVectorTransportMethods, where for the case that one of them is a ProductVectorTransport itself, the other is either prepended (if r is a product) or appenden (if s) is. If both ProductVectorTransports, they are combined into one keeping the order.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#LinearAlgebra.norm-2","page":"Meta-Manifolds","title":"LinearAlgebra.norm","text":"norm(M::ProductManifold, p, X, r::Real=2)\n\nCompute the (r-)norm of X from the tangent space of p on the ProductManifold, i.e. from the element wise norms the 2-norm is computed.\n\n\n\n\n\n","category":"function"},{"location":"metamanifolds/#ManifoldsBase.Weingarten-Tuple{ProductManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(M::ProductManifold, p, X, V)\nWeingarten!(M::ProductManifold, Y, p, X, V)\n\nSince the metric decouples, also the computation of the Weingarten map mathcal W_p can be computed elementwise on the single elements of the ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.change_metric-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.change_metric","text":"change_metric(M::ProductManifold, ::AbstractMetric, p, X)\n\nSince the metric on a product manifold decouples, the change of metric can be done elementwise.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.change_representer-Tuple{ProductManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.change_representer","text":"change_representer(M::ProductManifold, ::AbstractMetric, p, X)\n\nSince the metric on a product manifold decouples, the change of a representer can be done elementwise\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_point-Tuple{ProductManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_point","text":"check_point(M::ProductManifold, p; kwargs...)\n\nCheck whether p is a valid point on the ProductManifold M. If p is not a point on M a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_size-Tuple{ProductManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_size","text":"check_size(M::ProductManifold, p; kwargs...)\n\nCheck whether p is of valid size on the ProductManifold M. If p has components of wrong size a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.check_vector-Tuple{ProductManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.check_vector","text":"check_vector(M::ProductManifold, p, X; kwargs... )\n\nCheck whether X is a tangent vector to p on the ProductManifold M, i.e. all projections to base manifolds must be respective tangent vectors. If X is not a tangent vector to p on M a CompositeManifoldError.consisting of all error messages of the components, for which the tests fail is returned.\n\nThe tolerance for the last test can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.distance-2","page":"Meta-Manifolds","title":"ManifoldsBase.distance","text":"distance(M::ProductManifold, p, q, r::Real=2)\ndistance(M::ProductManifold, p, q, m::AbstractInverseRetractionMethod=LogarithmicInverseRetraction(), r::Real=2)\n\nCompute the distance between q and p on an ProductManifold.\n\nFirst, the componentwise distances are computed. These can be approximated using the norm of an AbstractInverseRetractionMethod m. Then, the r-norm of the tuple of these elements is computed.\n\n\n\n\n\n","category":"function"},{"location":"metamanifolds/#ManifoldsBase.distance-3","page":"Meta-Manifolds","title":"ManifoldsBase.distance","text":"distance(M::ProductManifold, p, q, r::Real=2)\ndistance(M::ProductManifold, p, q, m::AbstractInverseRetractionMethod=LogarithmicInverseRetraction(), r::Real=2)\n\nCompute the distance between q and p on an ProductManifold.\n\nFirst, the componentwise distances are computed. These can be approximated using the norm of an AbstractInverseRetractionMethod m. Then, the r-norm of the tuple of these elements is computed.\n\n\n\n\n\n","category":"function"},{"location":"metamanifolds/#ManifoldsBase.get_component-Tuple{ProductManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.get_component","text":"get_component(M::ProductManifold, p, i)\n\nGet the ith component of a point p on a ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.has_components-Tuple{ProductManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.has_components","text":"has_components(::ProductManifold)\n\nReturn true since points on an ProductManifold consist of components.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.injectivity_radius-Tuple{ProductManifold, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::ProductManifold)\ninjectivity_radius(M::ProductManifold, x)\n\nCompute the injectivity radius on the ProductManifold, which is the minimum of the factor manifolds.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inner-Tuple{ProductManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.inner","text":"inner(M::ProductManifold, p, X, Y)\n\ncompute the inner product of two tangent vectors X, Y from the tangent space at p on the ProductManifold M, which is just the sum of the internal manifolds that build M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, AbstractInverseRetractionMethod}","page":"Meta-Manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProductManifold, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the inverse retraction from p with respect to q on the ProductManifold M using an AbstractInverseRetractionMethod, which is used on each manifold of the product.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inverse_retract-Tuple{ProductManifold, Any, Any, Any, InverseProductRetraction}","page":"Meta-Manifolds","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::ProductManifold, p, q, m::InverseProductRetraction)\n\nCompute the inverse retraction from p with respect to q on the ProductManifold M using an InverseProductRetraction, which by default encapsulates a inverse retraction for each manifold of the product. Then this method is performed elementwise, so the encapsulated inverse retraction methods have to be available per factor.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.is_flat-Tuple{ProductManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.is_flat","text":"is_flat(::ProductManifold)\n\nReturn true if and only if all component manifolds of ProductManifold M are flat.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.manifold_dimension-Tuple{ProductManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::ProductManifold)\n\nReturn the manifold dimension of the ProductManifold, which is the sum of the manifold dimensions the product is made of.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.number_of_components-Union{Tuple{ProductManifold{ğ”½, <:NTuple{N, Any}}}, Tuple{N}, Tuple{ğ”½}} where {ğ”½, N}","page":"Meta-Manifolds","title":"ManifoldsBase.number_of_components","text":"number_of_components(M::ProductManifold{<:NTuple{N,Any}}) where {N}\n\nCalculate the number of manifolds multiplied in the given ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, AbstractRetractionMethod}","page":"Meta-Manifolds","title":"ManifoldsBase.retract","text":"retract(M::ProductManifold, p, X, m::AbstractRetractionMethod)\n\nCompute the retraction from p with tangent vector X on the ProductManifold M using the AbstractRetractionMethod m on every manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.retract-Tuple{ProductManifold, Any, Any, ProductRetraction}","page":"Meta-Manifolds","title":"ManifoldsBase.retract","text":"retract(M::ProductManifold, p, X, m::ProductRetraction)\n\nCompute the retraction from p with tangent vector X on the ProductManifold M using an ProductRetraction, which by default encapsulates retractions of the base manifolds. Then this method is performed elementwise, so the encapsulated retractions method has to be one that is available on the manifolds.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.riemann_tensor-Tuple{ProductManifold, Vararg{Any, 4}}","page":"Meta-Manifolds","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::ProductManifold, p, X, Y, Z)\n\nCompute the Riemann tensor at point from p with tangent vectors X, Y and Z on the ProductManifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature-Tuple{ProductManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(M::ProductManifold, p, X, Y)\n\nCompute the sectional curvature of a manifold mathcal M at a point p in mathcal M on two linearly independent tangent vectors at p. It may be 0 for a product of non-flat manifolds if projections of X and Y on subspaces corresponding to component manifolds are not linearly independent.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature_max-Tuple{ProductManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(M::ProductManifold)\n\nUpper bound on sectional curvature of ProductManifold M. It is the maximum of sectional curvatures of component manifolds and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors (X_1, 0) and (0, X_2) is 0.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.sectional_curvature_min-Tuple{ProductManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::ProductManifold)\n\nLower bound on sectional curvature of ProductManifold M. It is the minimum of sectional curvatures of component manifolds and 0 in case there are two or more component manifolds, as the sectional curvature corresponding to the plane spanned by vectors (X_1, 0) and (0, X_2) is 0.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.select_from_tuple-Union{Tuple{P}, Tuple{N}, Tuple{NTuple{N, Any}, Val{P}}} where {N, P}","page":"Meta-Manifolds","title":"ManifoldsBase.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.set_component!-Tuple{ProductManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.set_component!","text":"set_component!(M::ProductManifold, q, p, i)\n\nSet the ith component of a point q on a ProductManifold M to p, where p is a point on the AbstractManifold  this factor of the product manifold consists of.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.submanifold-Tuple{ProductManifold, Integer}","page":"Meta-Manifolds","title":"ManifoldsBase.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.submanifold-Tuple{ProductManifold, Val}","page":"Meta-Manifolds","title":"ManifoldsBase.submanifold","text":"submanifold(M::ProductManifold, i::Val)\nsubmanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\nThe version with AbstractVector is not type-stable, for better preformance use Val.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.submanifold_component-Tuple","page":"Meta-Manifolds","title":"ManifoldsBase.submanifold_component","text":"submanifold_component(M::AbstractManifold, p, i::Integer)\nsubmanifold_component(M::AbstractManifold, p, ::Val{i}) where {i}\nsubmanifold_component(p, i::Integer)\nsubmanifold_component(p, ::Val{i}) where {i}\n\nProject the product array p on M to its ith component. A new array is returned.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.submanifold_components-Tuple","page":"Meta-Manifolds","title":"ManifoldsBase.submanifold_components","text":"submanifold_components(M::AbstractManifold, p)\nsubmanifold_components(p)\n\nGet the projected components of p on the submanifolds of M. The components are returned in a Tuple.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, AbstractVectorTransportMethod}","page":"Meta-Manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::ProductManifold, p, X, q, m::AbstractVectorTransportMethod)\n\nCompute the vector transport the tangent vector X at p to q on the ProductManifold M using an AbstractVectorTransportMethod m on each manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.vector_transport_to-Tuple{ProductManifold, Any, Any, Any, ProductVectorTransport}","page":"Meta-Manifolds","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::ProductManifold, p, X, q, m::ProductVectorTransport)\n\nCompute the vector transport the tangent vector X at p to q on the ProductManifold M using a ProductVectorTransport m.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.ziptuples-Union{Tuple{M}, Tuple{N}, Tuple{NTuple{N, Any}, NTuple{M, Any}}} where {N, M}","page":"Meta-Manifolds","title":"ManifoldsBase.ziptuples","text":"ziptuples(a, b[, c[, d[, e]]])\n\nZips tuples a, b, and remaining in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Quotient-manifolds","page":"Meta-Manifolds","title":"Quotient manifolds","text":"","category":"section"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"A manifold mathcal M is then a a quotient manifold of another manifold mathcal N, i.e. for an equivalence relation  on mathcal N we have","category":"page"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"    mathcal M = mathcal N   = bigl p  p  mathcal N bigr","category":"page"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"where p   q  mathcal N  q  p denotes the equivalence class containing p. For more details see Subsection 3.4.1 [AMS08].","category":"page"},{"location":"metamanifolds/","page":"Meta-Manifolds","title":"Meta-Manifolds","text":"This manifold type models an explicit quotient structure. This should be done if either the default implementation of mathcal M uses another representation different from the quotient structure or if it provides a (default) quotient structure that is different from the one introduced here.","category":"page"},{"location":"metamanifolds/#ManifoldsBase.canonical_project!-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.canonical_project!","text":"canonical_project(M::AbstractManifold, p)\ncanonical_project!(M::AbstractManifold, q, p)\n\nCompute the canonical projection Ï€ on a quotient manifold mathcal M. The canonical (or natural) projection Ï€ from the total space mathcal N onto mathcal M given by\n\n    Ï€ = Ï€_mathcal N mathcal M  mathcal N  mathcal M p  Ï€_mathcal N mathcal M(p) = p\n\nin other words, this function implicitly assumes, that the total space mathcal N is given.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.canonical_project-Tuple{AbstractManifold, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.canonical_project","text":"canonical_project(M::AbstractManifold, p)\ncanonical_project!(M::AbstractManifold, q, p)\n\nCompute the canonical projection Ï€ on a quotient manifold mathcal M. The canonical (or natural) projection Ï€ from the total space mathcal N onto mathcal M given by\n\n    Ï€ = Ï€_mathcal N mathcal M  mathcal N  mathcal M p  Ï€_mathcal N mathcal M(p) = p\n\nin other words, this function implicitly assumes, that the total space mathcal N is given.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.diff_canonical_project!-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.diff_canonical_project!","text":"diff_canonical_project(M::AbstractManifold, p, X)\ndiff_canonical_project!(M::AbstractManifold, Y, p, X)\n\nCompute the differential of the canonical projection Ï€ on a quotient manifold mathcal M. The canonical (or natural) projection Ï€ from the total space mathcal N onto mathcal M, such that its differential\n\n DÏ€(p)  T_pmathcal N  T_Ï€(p)mathcal M\n\nwhere again the total space might be implicitly assumed.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.diff_canonical_project-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.diff_canonical_project","text":"diff_canonical_project(M::AbstractManifold, p, X)\ndiff_canonical_project!(M::AbstractManifold, Y, p, X)\n\nCompute the differential of the canonical projection Ï€ on a quotient manifold mathcal M. The canonical (or natural) projection Ï€ from the total space mathcal N onto mathcal M, such that its differential\n\n DÏ€(p)  T_pmathcal N  T_Ï€(p)mathcal M\n\nwhere again the total space might be implicitly assumed.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.get_total_space-Tuple{AbstractManifold}","page":"Meta-Manifolds","title":"ManifoldsBase.get_total_space","text":"get_total_space(M::AbstractManifold)\n\nReturn the total space of a quotient manifold.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.horizontal_component!-Tuple{AbstractManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.horizontal_component!","text":"horizontal_component(M::AbstractManifold, p, X)\nhorizontal_component!(M::AbstractManifold, Y, p, X)\n\nCompute the horizontal component of tangent vector X at point p in the total space of quotient manifold N.\n\nThis is often written as the space mathrmHor_p^Ï€mathcal N.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.horizontal_component-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.horizontal_component","text":"horizontal_component(M::AbstractManifold, p, X)\nhorizontal_component!(M::AbstractManifold, Y, p, X)\n\nCompute the horizontal component of tangent vector X at point p in the total space of quotient manifold N.\n\nThis is often written as the space mathrmHor_p^Ï€mathcal N.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.horizontal_lift!-Tuple{AbstractManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.horizontal_lift!","text":"horizontal_lift(N::AbstractManifold, q, X)\nhorizontal_lift!(N::AbstractManifold, Y, q, X)\n\nGiven a point q in total space of the quotient manifold N such that p=Ï€(q) is a point on a quotient manifold M (implicitly given for the first case) and a tangent vector X this method computes a tangent vector Y on the horizontal space of T_qmathcal N, i.e. the subspace that is orthogonal to the kernel of DÏ€(q).\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.horizontal_lift-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.horizontal_lift","text":"horizontal_lift(N::AbstractManifold, q, X)\nhorizontal_lift!(N::AbstractManifold, Y, q, X)\n\nGiven a point q in total space of the quotient manifold N such that p=Ï€(q) is a point on a quotient manifold M (implicitly given for the first case) and a tangent vector X this method computes a tangent vector Y on the horizontal space of T_qmathcal N, i.e. the subspace that is orthogonal to the kernel of DÏ€(q).\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.vertical_component!-Tuple{AbstractManifold, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.vertical_component!","text":"vertical_component(N::AbstractManifold, p, X)\nvertical_component!(N::AbstractManifold, Y, p, X)\n\nCompute the vertical component of tangent vector X at point p in the total space of quotient manifold N.\n\nThis is often written as the space mathrmver_p^Ï€mathcal N.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.vertical_component-Tuple{AbstractManifold, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.vertical_component","text":"vertical_component(N::AbstractManifold, p, X)\nvertical_component!(N::AbstractManifold, Y, p, X)\n\nCompute the vertical component of tangent vector X at point p in the total space of quotient manifold N.\n\nThis is often written as the space mathrmver_p^Ï€mathcal N.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Fiber","page":"Meta-Manifolds","title":"Fiber","text":"","category":"section"},{"location":"metamanifolds/#ManifoldsBase.Fiber","page":"Meta-Manifolds","title":"ManifoldsBase.Fiber","text":"Fiber{ğ”½,TFiber<:FiberType,TM<:AbstractManifold,TX} <: AbstractManifold{ğ”½}\n\nA fiber of a fiber bundle at a point p on the manifold.\n\nThis fiber itself is also a manifold. For vector fibers it's by default flat and hence isometric to the Euclidean manifold.\n\nFields\n\nmanifold    â€“ base space of the fiber bundle\npoint       â€“ a point p from the base space; the fiber corresponds to the preimage                 by bundle projection pi^-1(p).\n\nConstructor\n\nFiber(M::AbstractManifold, p, fiber_type::FiberType)\n\nA fiber of type fiber_type at point p from the manifold manifold.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.FiberType","page":"Meta-Manifolds","title":"ManifoldsBase.FiberType","text":"abstract type FiberType end\n\nAn abstract type for fiber types that can be used within Fiber.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.VectorSpaceFiber","page":"Meta-Manifolds","title":"ManifoldsBase.VectorSpaceFiber","text":"VectorSpaceFiber{ğ”½,M,TSpaceType} = Fiber{ğ”½,TSpaceType,M}\n    where {ğ”½,M<:AbstractManifold,TSpaceType<:VectorSpaceType}\n\nAlias for a Fiber when the fiber is a vector space.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#Tangent-Space","page":"Meta-Manifolds","title":"Tangent Space","text":"","category":"section"},{"location":"metamanifolds/#ManifoldsBase.CotangentSpace","page":"Meta-Manifolds","title":"ManifoldsBase.CotangentSpace","text":"CotangentSpace{ğ”½,M} = Fiber{ğ”½,CotangentSpaceType,M} where {ğ”½,M<:AbstractManifold}\n\nA manifold for the Cotangent space T^*_pmathcal M at a point pinmathcal M. This is modelled as an alias for VectorSpaceFiber corresponding to CotangentSpaceType.\n\nConstructor\n\nCotangentSpace(M::AbstractManifold, p)\n\nReturn the manifold (vector space) representing the cotangent space T^*_pmathcal M at point p, pinmathcal M.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#ManifoldsBase.TangentSpace","page":"Meta-Manifolds","title":"ManifoldsBase.TangentSpace","text":"TangentSpace{ğ”½,M} = Fiber{ğ”½,TangentSpaceType,M} where {ğ”½,M<:AbstractManifold}\n\nA manifold for the tangent space T_pmathcal M at a point pinmathcal M. This is modelled as an alias for VectorSpaceFiber corresponding to TangentSpaceType.\n\nConstructor\n\nTangentSpace(M::AbstractManifold, p)\n\nReturn the manifold (vector space) representing the tangent space T_pmathcal M at point p, pinmathcal M.\n\n\n\n\n\n","category":"type"},{"location":"metamanifolds/#Base.exp-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any}","page":"Meta-Manifolds","title":"Base.exp","text":"exp(TpM::TangentSpace, X, V)\n\nExponential map of tangent vectors X from TpM and a direction V, which is also from the TangentSpace TpM since we identify the tangent space of TpM with TpM. The exponential map then simplifies to the sum X+V.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#Base.log-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Vararg{Any}}","page":"Meta-Manifolds","title":"Base.log","text":"log(TpM::TangentSpace, X, Y)\n\nLogarithmic map on the TangentSpace TpM, calculated as the difference of tangent vectors q and p from TpM.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.Weingarten-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.Weingarten","text":"Y = Weingarten(TpM::TangentSpace, X, V, A)\nWeingarten!(TpM::TangentSpace, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_X at X on the TangentSpace TpM with respect to the tangent vector V in T_pmathcal M and the normal vector A in N_pmathcal M.\n\nSince this a flat space by itself, the result is always the zero tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.base_point-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½}","page":"Meta-Manifolds","title":"ManifoldsBase.base_point","text":"base_point(TpM::TangentSpace)\n\nReturn the base point of the TangentSpace.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.distance-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.distance","text":"distance(M::TangentSpace, X, Y)\n\nDistance between vectors X and Y from the TangentSpace TpM. It is calculated as the norm (induced by the metric on TpM) of their difference.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.injectivity_radius-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½}","page":"Meta-Manifolds","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(TpM::TangentSpace)\n\nReturn the injectivity radius on the TangentSpace TpM, which is .\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.inner-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.inner","text":"inner(M::TangentSpace, X, V, W)\n\nFor any X  T_pmathcal M we identify the tangent space T_X(T_pmathcal M) with T_pmathcal M again. Hence an inner product of VW is just the inner product of the tangent space itself. VW_X = VW_p.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.is_flat-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½}","page":"Meta-Manifolds","title":"ManifoldsBase.is_flat","text":"is_flat(::TangentSpace)\n\nThe TangentSpace is a flat manifold, so this returns true.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.manifold_dimension-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½}","page":"Meta-Manifolds","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(TpM::TangentSpace)\n\nReturn the dimension of the TangentSpace T_pmathcal M at pmathcal M, which is the same as the dimension of the manifold mathcal M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.parallel_transport_to-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(::TangentSpace, X, V, Y)\n\nTransport the tangent vector Z  T_X(T_pmathcal M) from X to Y. Since we identify T_X(T_pmathcal M) = T_pmathcal M and the tangent space is a vector space, parallel transport simplifies to the identity, so this function yields V as a result.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.project","text":"project(TpM::TangentSpace, X, V)\n\nProject the vector V from the embedding of the tangent space TpM (identified with T_X(T_pmathcal M)), that is project the vector V onto the tangent space at TpM.point.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.project-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Any}","page":"Meta-Manifolds","title":"ManifoldsBase.project","text":"project(TpM::TangentSpace, X)\n\nProject the point X from embedding of the TangentSpace TpM onto TpM.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½, Vararg{Any}}","page":"Meta-Manifolds","title":"ManifoldsBase.zero_vector","text":"zero_vector(TpM::TangentSpace, X)\n\nZero tangent vector at point X from the TangentSpace TpM, that is the zero tangent vector at point TpM.point, since we identify the tangent space T_X(T_pmathcal M) with T_pmathcal M.\n\n\n\n\n\n","category":"method"},{"location":"metamanifolds/#ManifoldsBase.zero_vector-Tuple{ManifoldsBase.Fiber{ğ”½, TangentSpaceType} where ğ”½}","page":"Meta-Manifolds","title":"ManifoldsBase.zero_vector","text":"zero_vector(TpM::TangentSpace)\n\nZero tangent vector in the TangentSpace TpM, that is the zero tangent vector at point TpM.point.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Functions-on-manifolds","page":"Basic functions","title":"Functions on manifolds","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"This page collects several basic functions on manifolds.","category":"page"},{"location":"functions/#exp-and-log","page":"Basic functions","title":"The exponential map, the logarithmic map, and geodesics","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"Geodesics are the generalizations of a straight line to manifolds, i.e. their intrinsic acceleration is zero. Together with geodesics one also obtains the exponential map and its inverse, the logarithmic map. Informally speaking, the exponential map takes a vector (think of a direction and a length) at one point and returns another point, which lies towards this direction at distance of the specified length. The logarithmic map does the inverse, i.e. given two points, it tells which vector â€œpoints towardsâ€ the other point.","category":"page"},{"location":"functions/#Base.exp-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.exp","text":"exp(M::AbstractManifold, p, X)\n\nCompute the exponential map of tangent vector X at point p from the manifold AbstractManifold M, i.e.\n\nexp_p X = Î³_pX(1)\n\nwhere Î³_pX is the unique geodesic starting in Î³(0)=p such that dot Î³(0) = X.\n\nSee also shortest_geodesic, retract.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.log-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.log","text":"log(M::AbstractManifold, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The logarithmic map is the inverse of the exponential map. Note that the logarithmic map might not be globally defined.\n\nSee also inverse_retract.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.exp!","text":"exp!(M::AbstractManifold, q, p, X)\n\nCompute the exponential map of tangent vector X, optionally scaled by t,  at point p from the manifold AbstractManifold M. The result is saved to q.\n\nIf you want to implement exponential map for your manifold, you should implement the in-place method with, that is exp_fused!(M::MyManifold, q, p, X).\n\nSee also exp.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.exp_fused!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Basic functions","title":"ManifoldsBase.exp_fused!","text":"exp_fused!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the exponential map of tangent vector X scaled by t at point p in-place of q. Compared to exp!, this method provides the opportunity to avoid the allocation when computing t*X. By default, this method performs this operation and passes to exp!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.exp_fused-Tuple{AbstractManifold, Any, Any, Number}","page":"Basic functions","title":"ManifoldsBase.exp_fused","text":"exp_fused(M::AbstractManifold, p, X, t::Number = 1)\n\nCompute the exponential map of tangent vector X scaled by t at point p. Compared to exp, this method provides the opportunity to avoid the allocation when computing t*X. By default, this method allocates the resulting point q and passes to exp_fused!.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, Q, p, X, T::AbstractVector) -> AbstractVector\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at time points t fom T in place of Q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, q, p, X, t::Real)\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This function evaluates the geodeic at t in place of q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic!","text":"geodesic!(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields that the curve has constant velocity and is locally distance-minimizing.\n\nThis function returns a function (q,t) of (time) t that mutates q`.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X, T::AbstractVector) -> AbstractVector\n\nEvaluate the geodesic Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\nat time points t from T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X, t::Real)\n\nEvaluate the geodesic Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\nat time t.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.geodesic","text":"geodesic(M::AbstractManifold, p, X) -> Function\n\nGet the geodesic with initial point p and velocity X on the AbstractManifold M. A geodesic is a curve of zero acceleration. That is for the curve Î³_pX I  mathcal M, with Î³_pX(0) = p and dot Î³_pX(0) = X a geodesic further fulfills\n\n_dot Î³_pX(t) dot Î³_pX(t) = 0\n\ni.e. the curve is acceleration free with respect to the Riemannian metric. This yields, that the curve has constant velocity that is locally distance-minimizing.\n\nThis function returns a function of (time) t.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.log!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.log!","text":"log!(M::AbstractManifold, X, p, q)\n\nCompute the logarithmic map of point q at base point p on the AbstractManifold M. The result is saved to X. The logarithmic map is the inverse of the exp!onential map. Note that the logarithmic map might not be globally defined.\n\nsee also log and inverse_retract!,\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -> AbstractVector\n\nEvaluate a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q at all t from T in place of R. When there are multiple shortest geodesics, a deterministic choice will be taken.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)\n\nEvaluate a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q at t in place of r. When there are multiple shortest geodesics, a deterministic choice will be taken.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic!","text":"shortest_geodesic!(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function (r,t) -> ... of time t which works in place of r.\n\nFurther variants\n\nshortest_geodesic!(M::AabstractManifold, r, p, q, t::Real)\nshortest_geodesic!(M::AbstractManifold, R, p, q, T::AbstractVector) -> AbstractVector\n\nmutate (and return) the point r and the vector of points R, respectively, returning the point at time t or points at times t in T along the shortest geodesic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, AbstractVector}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q, T::AbstractVector) -> AbstractVector\n\nEvaluate a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q at time points T. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any, Real}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AabstractManifold, p, q, t::Real)\n\nEvaluate a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q at time t. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.shortest_geodesic-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::AbstractManifold, p, q) -> Function\n\nGet a geodesic Î³_pq(t) whose length is the shortest path between the points pand q, where Î³_pq(0)=p and Î³_pq(1)=q. When there are multiple shortest geodesics, a deterministic choice will be returned.\n\nThis function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#subsec-parallel-transport","page":"Basic functions","title":"Parallel transport","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"While moving vectors from one base point to another is the identity in the Euclidean space â€“Â or in other words all tangent spaces (directions one can â€œwalkâ€ into) are the same. This is different on a manifold.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"If we have two points pq  mathcal M, we take a c 01  mathcal M connecting the two points, i.e. c(0) = p and c(1) = q. this could be a (or the) geodesic. If we further consider a vector field X 01  Tmathcal M, i.e. where X(t)  T_c(t)mathcal M. Then the vector field is called parallel if its covariant derivative fracmathrmDmathrmdtX(t) = 0 for all t 01.","category":"page"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"If we now impose a value for X=X(0)  T_pmathcal M, we obtain an ODE with an initial condition. The resulting value X(1)  T_qmathcal M is called the parallel transport of X along c or in case of a geodesic the _parallel transport of X from p to q.","category":"page"},{"location":"functions/#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_direction","text":"parallel_transport_direction(M::AbstractManifold, p, X, d)\n\nCompute the parallel transport of X along the curve c(t) = Î³_pX(t) to c(1)=q, where c(t)=Î³_pX(t) is the the unique geodesic starting from Î³_pd(0)=p into direction Ì‡dot Î³_pd(0)=d.\n\nBy default this function calls parallel_transport_to(M, p, X, q), where q=exp_pX.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.parallel_transport_to","text":"parallel_transport_to(M::AbstractManifold, p, X, q)\n\nCompute the parallel transport of X along the curve c(t) = Î³_pq(t), i.e. the (assumed to be unique) geodesic Î³_pq connecting p and q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Further-functions-on-manifolds","page":"Basic functions","title":"Further functions on manifolds","text":"","category":"section"},{"location":"functions/#General-functions-provided-by-the-interface","page":"Basic functions","title":"General functions provided by the interface","text":"","category":"section"},{"location":"functions/#Base.angle-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.angle","text":"angle(M::AbstractManifold, p, X, Y)\n\nCompute the angle between tangent vectors X and Y at point p from the AbstractManifold M with respect to the inner product from inner.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M::AbstractManifold, p, X)\n\nCopy the value(s) from the tangent vector X at a point p on the AbstractManifold M into a new tangent vector. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copy-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"Base.copy","text":"copy(M::AbstractManifold, p)\n\nCopy the value(s) from the point p on the AbstractManifold M into a new point. See allocate_result for the allocation of new point memory and copyto! for the copying.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copyto!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, Y, p, X)\n\nCopy the value(s) from X to Y, where both are tangent vectors from the tangent space at p on the AbstractManifold M. This function defaults to calling copyto!(Y, X), but it might be useful to overwrite the function at the level, where also information from p and M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.copyto!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.copyto!","text":"copyto!(M::AbstractManifold, q, p)\n\nCopy the value(s) from p to q, where both are points on the AbstractManifold M. This function defaults to calling copyto!(q, p), but it might be useful to overwrite the function at the level, where also information from M can be accessed.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, X, Y; error:Symbol=:none; kwargs...)\n\nCheck if vectors X and Y tangent at p from AbstractManifold M are approximately equal.\n\nThe optional positional argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported\n\n:error - throws an error if isapprox evaluates to false, providing possibly a more detailed error. Note that this turns isapprox basically to an @assert.\n:info â€“ prints the information in an @info\n:warn â€“ prints the information in an @warn\n:none (default) â€“ the function just returns true/false\n\nBy default these pieces of information are collected by calling check_approx.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.isapprox","text":"isapprox(M::AbstractManifold, p, q; error::Symbol=:none, kwargs...)\n\nCheck if points p and q from AbstractManifold M are approximately equal.\n\nThe keyword argument can be used to get more information for the case that the result is false, if the concrete manifold provides such information. Currently the following are supported\n\n:error - throws an error if isapprox evaluates to false, providing possibly a more detailed error. Note that this turns isapprox basically to an @assert.\n:info â€“ prints the information in an @info\n:warn â€“ prints the information in an @warn\n:none (default) â€“ the function just returns true/false\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.rand-Tuple{AbstractManifold}","page":"Basic functions","title":"Base.rand","text":"Random.rand(M::AbstractManifold, [d::Integer]; vector_at=nothing)\nRandom.rand(rng::AbstractRNG, M::AbstractManifold, [d::Integer]; vector_at=nothing)\n\nGenerate a random point on manifold M (when vector_at is nothing) or a tangent vector at point vector_at (when it is not nothing).\n\nOptionally a random number generator rng to be used can be specified. An optional integer d indicates that a vector of d points or tangent vectors is to be generated.\n\nnote: Note\nUsually a uniform distribution should be expected for compact manifolds and a Gaussian-like distribution for non-compact manifolds and tangent vectors, although it is not guaranteed. The distribution may change between releases.rand methods for specific manifolds may take additional keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"functions/#LinearAlgebra.norm-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"LinearAlgebra.norm","text":"norm(M::AbstractManifold, p, X)\n\nCompute the norm of tangent vector X at point p from a AbstractManifold M. By default this is computed using inner.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.Weingarten!-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Basic functions","title":"ManifoldsBase.Weingarten!","text":"Weingarten!(M, Y, p, X, V)\n\nCompute the Weingarten map mathcal W_pcolon T_pmathcal M  N_pmathcal M to T_pmathcal M in place of Y, see Weingarten.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.Weingarten-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.Weingarten","text":"Weingarten(M, p, X, V)\n\nCompute the Weingarten map mathcal W_pcolon T_pmathcal M  N_pmathcal M to T_pmathcal M, where N_pmathcal M is the orthogonal complement of the tangent space T_pmathcal M of the embedded submanifold mathcal M, where we denote the embedding by mathcal E.\n\nThe Weingarten map can be defined by restricting the differential of the orthogonal projection operatornameproj_T_pmathcal Mcolon T_p mathcal E to T_pmathcal M with respect to the base point p, i.e. defining\n\nmathcal P_X = D_poperatornameproj_T_pmathcal M(Y)X\nqquad Y in T_p mathcal E X in T_pmathcal M\n\nthe Weingarten map can be written as mathcal W_p(XV) = mathcal P_X(V).\n\nThe Weingarten map is named after Julius Weingarten (1836â€“1910).\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate-Tuple{Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate","text":"allocate(a)\nallocate(a, dims::Integer...)\nallocate(a, dims::Tuple)\nallocate(a, ::Nothing)\nallocate(a, T::Type)\nallocate(a, T::Type, dims::Integer...)\nallocate(a, T::Type, dims::Tuple)\nallocate(a, T::Type, ::Nothing)\nallocate(M::AbstractManifold, a)\nallocate(M::AbstractManifold, a, dims::Integer...)\nallocate(M::AbstractManifold, a, dims::Tuple)\nallocate(M::AbstractManifold, a, ::Nothing)\nallocate(M::AbstractManifold, a, T::Type)\nallocate(M::AbstractManifold, a, T::Type, dims::Integer...)\nallocate(M::AbstractManifold, a, T::Type, dims::Tuple)\nallocate(M::AbstractManifold, a, T::Type, ::Nothing)\n\nAllocate an object similar to a. It is similar to function similar, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls similar on the innermost array-like object only. Type T is the new number element type number_eltype, if it is not given the element type of a is retained. The dims argument can be given for non-nested allocation and is forwarded to the function similar.\n\nIt's behavior can be overridden by a specific manifold, for example power manifold with nested replacing representation can decide that allocate for Array{<:SArray} returns another Array{<:SArray} instead of Array{<:MArray}, as would be done by default.\n\nIf the last argument is nothing, it is ignored to support cases where representation_size is not defined and returns nothing but allocation can still go off of a.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate_on-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.allocate_on","text":"allocate_on(M::AbstractManifold, [T:::Type])\nallocate_on(M::AbstractManifold, F::FiberType, [T:::Type])\n\nAllocate a new point on manifold M with optional type given by T. Note that T is not number element type as in allocate but rather the type of the entire point to be returned.\n\nIf F is provided, then an element of the corresponding fiber is allocated, assuming it is independent of the base point.\n\nTo allocate a tangent vector, use ``\n\nExample\n\njulia> using ManifoldsBase\n\njulia> M = ManifoldsBase.DefaultManifold(4)\nDefaultManifold(4; field = â„)\n\njulia> allocate_on(M)\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\njulia> allocate_on(M, Array{Float64})\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\njulia> allocate_on(M, TangentSpaceType())\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\njulia> allocate_on(M, TangentSpaceType(), Array{Float64})\n4-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.base_manifold","page":"Basic functions","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::AbstractManifold, depth = Val(-1))\n\nReturn the internally stored AbstractManifold for decorated manifold M and the base manifold for vector bundles or power manifolds. The optional parameter depth can be used to remove only the first depth many decorators and return the AbstractManifold from that level, whether its decorated or not. Any negative value deactivates this depth limit.\n\n\n\n\n\n","category":"function"},{"location":"functions/#ManifoldsBase.default_type-Tuple{AbstractManifold, ManifoldsBase.FiberType}","page":"Basic functions","title":"ManifoldsBase.default_type","text":"default_type(M::AbstractManifold, ft::FiberType)\n\nGet the default type of points from the fiber ft of the fiber bundle based on manifold M. For example, call default_type(MyManifold(), TangentSpaceType()) to get the default type of a tangent vector.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.default_type-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.default_type","text":"default_type(M::AbstractManifold)\n\nGet the default type of points on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any, AbstractInverseRetractionMethod}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q, m::AbstractInverseRetractionMethod)\n\nApproximate distance between points p and q on manifold M using AbstractInverseRetractionMethod m.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.distance-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.distance","text":"distance(M::AbstractManifold, p, q)\n\nShortest distance between the points p and q on the AbstractManifold M, i.e.\n\nd(pq) = inf_Î³ L(Î³)\n\nwhere the infimum is over all piecewise smooth curves Î³ ab to mathcal M connecting Î³(a)=p and Î³(b)=q and\n\nL(Î³) = displaystyleint_a^b lVert dotÎ³(t)rVert_Î³(t) mathrmdt\n\nis the length of the curve Î³.\n\nIf mathcal M is not connected, i.e. consists of several disjoint components, the distance between two points from different components should be .\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, Y, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into the ambient space and return the result in Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as tangents on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. The embedded tangents are then in the tangent spaces of the embedded base points.\n\nThe default is set in such a way that it assumes that the points on M are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding also for tangent vectors is the identity by default.\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed!","text":"embed!(M::AbstractManifold, q, p)\n\nEmbed point p from the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your manifold. Additionally, embed might include changing data representation, if applicable, i.e. if points on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that it assumes that the points on M are represented in their embedding (for example like the unit vectors in a space to represent the sphere) and hence embedding in the identity by default.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your point p is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project!\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p, X)\n\nEmbed a tangent vector X at a point p on the AbstractManifold M into an ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Not implementing this function means, there is no proper embedding for your tangent space(s).\n\nAdditionally, embed might include changing data representation, if applicable, i.e. if tangent vectors on M are not represented in the same way as their counterparts in the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that memory is allocated and embed!(M, Y, p. X) is called.\n\nIf you have more than one embedding, see EmbeddedManifold for defining a second embedding. If your tangent vector X is already represented in some embedding, see AbstractDecoratorManifold how you can avoid reimplementing code from the embedded manifold\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed","text":"embed(M::AbstractManifold, p)\n\nEmbed point p from the AbstractManifold M into the ambient space. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, embed includes changing data representation, if applicable, i.e. if the points on M are not represented in the same way as points on the embedding, the representation is changed accordingly.\n\nThe default is set in such a way that memory is allocated and embed!(M, q, p) is called.\n\nSee also: EmbeddedManifold, project\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.embed_project","text":"embed_project(M::AbstractManifold, p, X)\n\nEmbed vector X tangent at p from manifold M an project it back to tangent space at p. For points from that tangent space this is identity but in case embedding is defined for tangent vectors from outside of it, this can serve as a way to for example remove numerical inaccuracies caused by some algorithms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.embed_project-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.embed_project","text":"embed_project(M::AbstractManifold, p)\n\nEmbed p from manifold M an project it back to M. For points from M this is identity but in case embedding is defined for points outside of M, this can serve as a way to for example remove numerical inaccuracies caused by some algorithms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.has_components-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.has_components","text":"has_components(M::AbstractManifold)\n\nReturn whether the AbstractManifold(M) consists of components, like the PowerManifold or the ProductManifold, that one can iterate over. By default, this function returns false.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.injectivity_radius-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::AbstractManifold)\n\nInfimum of the injectivity radii injectivity_radius(M,p) of all points p on the AbstractManifold.\n\ninjectivity_radius(M::AbstractManifold, p)\n\nReturn the distance d such that exp(M, p, X) is injective for all tangent vectors shorter than d (i.e. has an inverse).\n\ninjectivity_radius(M::AbstractManifold[, x], method::AbstractRetractionMethod)\ninjectivity_radius(M::AbstractManifold, x, method::AbstractRetractionMethod)\n\nDistance d such that retract(M, p, X, method) is injective for all tangent vectors shorter than d (i.e. has an inverse) for point p if provided or all manifold points otherwise.\n\nIn order to dispatch on different retraction methods, please either implement _injectivity_radius(M[, p], m::T) for your retraction R or specifically injectivity_radius_exp(M[, p]) for the exponential map. By default the variant with a point p assumes that the default (without p) can ve called as a lower bound.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.inner","text":"inner(M::AbstractManifold, p, X, Y)\n\nCompute the inner product of tangent vectors X and Y at point p from the AbstractManifold M.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.is_flat-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.is_flat","text":"is_flat(M::AbstractManifold)\n\nReturn true if the AbstractManifold M is flat, i.e. if its Riemann curvature tensor is everywhere zero.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}","page":"Basic functions","title":"ManifoldsBase.is_point","text":"is_point(M::AbstractManifold, p; error::Symbol = :none, kwargs...)\nis_point(M::AbstractManifold, p, throw_error::Bool; kwargs...)\n\nReturn whether p is a valid point on the AbstractManifold M. By default the function calls check_point, which returns an ErrorException or nothing.\n\nHow to report a potential error can be set using the error= keyword\n\n:error          - throws an error if p is not a point\n:info           - displays the error message as an @info\n:warn           - displays the error message as a @warning\n:none (default) â€“ the function just returns true/false\n\nall other symbols are equivalent to error=:none.\n\nThe second signature is a shorthand, where the boolean is used for error=:error (true) and error=:none (default, false). This case ignores the error= keyword\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}","page":"Basic functions","title":"ManifoldsBase.is_vector","text":"is_vector(M::AbstractManifold, p, X, check_base_point::Bool=true; error::Symbol=:none, kwargs...)\nis_vector(M::AbstractManifold, p, X, check_base_point::Bool=true, throw_error::Boolean; kwargs...)\n\nReturn whether X is a valid tangent vector at point p on the AbstractManifold M. Returns either true or false.\n\nIf check_base_point is set to true, this function also (first) calls is_point on p. Then, the function calls check_vector and checks whether the returned value is nothing or an error.\n\nHow to report a potential error can be set using the error= keyword\n\n:error          - throws an error if X is not a tangent vector and/or p is not point\n\n^ :info           - displays the error message as an @info\n\n:warn           - displays the error message as a @warning.\n:none           - (default) the function just returns true/false\n\nall other symbols are equivalent to error=:none\n\nThe second signature is a shorthand, where throw_error is used for error=:error (true) and error=:none (default, false). This case ignores the error= keyword.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::AbstractManifold)\n\nThe dimension n=dim_mathcal M of real space mathbb R^n to which the neighborhood of each point of the AbstractManifold M is homeomorphic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.mid_point!-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point!","text":"mid_point!(M::AbstractManifold, q, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp!. Saves the result in q.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.mid_point-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.mid_point","text":"mid_point(M::AbstractManifold, p1, p2)\n\nCalculate the middle between the two point p1 and p2 from manifold M. By default uses log, divides the vector by 2 and uses exp.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.number_eltype-Tuple{Any}","page":"Basic functions","title":"ManifoldsBase.number_eltype","text":"number_eltype(x)\n\nNumeric element type of the a nested representation of a point or a vector. To be used in conjunction with allocate or allocate_result.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.representation_size-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.representation_size","text":"representation_size(M::AbstractManifold)\n\nThe size of an array representing a point on AbstractManifold M. Returns nothing by default indicating that points are not represented using an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.riemann_tensor-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Basic functions","title":"ManifoldsBase.riemann_tensor","text":"riemann_tensor(M::AbstractManifold, p, X, Y, Z)\n\nCompute the value of the Riemann tensor R(X_fY_f)Z_f at point p, where X_f, Y_f and Z_f are vector fields defined by parallel transport of, respectively, X, Y and Z to the desired point. All computations are performed using the connection associated to manifold M.\n\nThe formula reads R(X_fY_f)Z_f = nabla_Xnabla_Y Z - nabla_Ynabla_X Z - nabla_X YZ, where X Y is the Lie bracket of vector fields.\n\nNote that some authors define this quantity with inverse sign.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.sectional_curvature-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.sectional_curvature","text":"sectional_curvature(M::AbstractManifold, p, X, Y)\n\nCompute the sectional curvature of a manifold mathcal M at a point p in mathcal M on two linearly independent tangent vectors at p. The formula reads\n\n\n    kappa_p(X Y) = fracR(X Y Y) X_plVert X rVert^2_p lVert Y rVert^2_p - X Y^2_p\n\n\nwhere R(X Y Y) is the riemann_tensor on mathcal M.\n\nInput\n\nM:   a manifold mathcal M\np:   a point p in mathcal M\nX:   a tangent vector X in T_p mathcal M\nY:   a tangent vector Y in T_p mathcal M\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.sectional_curvature_max-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.sectional_curvature_max","text":"sectional_curvature_max(M::AbstractManifold)\n\nUpper bound on sectional curvature of manifold M. The formula reads\n\nomega = operatornamesup_pinmathcal M Xin T_pmathcal M Yin T_pmathcal M X Y  0 kappa_p(X Y)\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.sectional_curvature_min-Tuple{AbstractManifold}","page":"Basic functions","title":"ManifoldsBase.sectional_curvature_min","text":"sectional_curvature_min(M::AbstractManifold)\n\nLower bound on sectional curvature of manifold M. The formula reads\n\nomega = operatornameinf_pinmathcal M Xin T_pmathcal M Yin T_pmathcal M X Y  0 kappa_p(X Y)\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.zero_vector!-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector!","text":"zero_vector!(M::AbstractManifold, X, p)\n\nSave to X the tangent vector from the tangent space T_pmathcal M at p that represents the zero vector, i.e. such that retracting X to the AbstractManifold M at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.zero_vector-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.zero_vector","text":"zero_vector(M::AbstractManifold, p)\n\nReturn the tangent vector from the tangent space T_pmathcal M at p on the AbstractManifold M, that represents the zero vector, i.e. such that a retraction at p produces p.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Internal-functions","page":"Basic functions","title":"Internal functions","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"While you should always add your documentation to functions from the last section, some of the functions dispatch onto functions on layer III. These are the ones you usually implement for your manifold â€“ unless there is no lower level function called, like for the manifold_dimension.","category":"page"},{"location":"functions/#Base.convert-Tuple{Type, AbstractManifold, Any, Any}","page":"Basic functions","title":"Base.convert","text":"convert(T::Type, M::AbstractManifold, p, X)\n\nConvert vector X tangent at point p from manifold M to type T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Base.convert-Tuple{Type, AbstractManifold, Any}","page":"Basic functions","title":"Base.convert","text":"convert(T::Type, M::AbstractManifold, p)\n\nConvert point p from manifold M to type T.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase._isapprox","text":"_isapprox(M::AbstractManifold, p, X, Y; kwargs...)\n\nAn internal function for testing whether tangent vectors X and Y from tangent space at point p from manifold M are approximately equal. Returns either true or false and does not support errors like isapprox.\n\nFor more details see documentation of check_approx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._isapprox-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase._isapprox","text":"_isapprox(M::AbstractManifold, p, q; kwargs...)\n\nAn internal function for testing whether points p and q from manifold M are approximately equal. Returns either true or false and does not support errors like isapprox.\n\nFor more details see documentation of check_approx.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase._pick_basic_allocation_argument-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase._pick_basic_allocation_argument","text":"_pick_basic_allocation_argument(::AbstractManifold, f, x...)\n\nPick which one of elements of x should be used as a basis for allocation in the allocate_result(M::AbstractManifold, f, x...) method. This can be specialized to, for example, skip Identity arguments in Manifolds.jl group-related functions.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate_result-Tuple{AbstractManifold, Any, Vararg{Any}}","page":"Basic functions","title":"ManifoldsBase.allocate_result","text":"allocate_result(M::AbstractManifold, f, x...)\n\nAllocate an array for the result of function f on AbstractManifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.allocate_result_type-Union{Tuple{TF}, Tuple{N}, Tuple{AbstractManifold, TF, NTuple{N, Any}}} where {N, TF}","page":"Basic functions","title":"ManifoldsBase.allocate_result_type","text":"allocate_result_type(M::AbstractManifold, f, args::NTuple{N,Any}) where N\n\nReturn type of element of the array that will represent the result of function f and the AbstractManifold M on given arguments args (passed as a tuple).\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.are_linearly_independent-Tuple{AbstractManifold, Any, Any, Any}","page":"Basic functions","title":"ManifoldsBase.are_linearly_independent","text":"are_linearly_independent(M::AbstractManifold, p, X, Y)\n\nCheck is vectors X, Y tangent at p to M are linearly independent.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_approx-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_approx","text":"check_approx(M::AbstractManifold, p, q; kwargs...)\ncheck_approx(M::AbstractManifold, p, X, Y; kwargs...)\n\nCheck whether two elements are approximately equal, either p, q on the AbstractManifold or the two tangent vectors X, Y in the tangent space at p are approximately the same. The keyword arguments kwargs can be used to set tolerances, similar to Julia's isapprox.\n\nThis function might use isapprox from Julia internally and is similar to isapprox, with the difference that is returns an ApproximatelyError if the two elements are not approximately equal, containting a more detailed description/reason. If the two elements are approximalely equal, this method returns nothing.\n\nThis method is an internal function and is called by isapprox whenever the user specifies an error= keyword therein. _isapprox is another related internal function. It is supposed to provide a fast true/false decision whether points or vectors are equal or not, while check_approx also provides a textual explanation. If no additional explanation is needed, a manifold may just implement a method of _isapprox, while it should also implement check_approx if a more detailed explanation could be helpful.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_point","text":"check_point(M::AbstractManifold, p; kwargs...) -> Union{Nothing,String}\n\nReturn nothing when p is a point on the AbstractManifold M. Otherwise, return an error with description why the point does not belong to manifold M.\n\nBy default, check_point returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the AbstractManifoldPoint type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_size-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.check_size","text":"check_size(M::AbstractManifold, p)\ncheck_size(M::AbstractManifold, p, X)\n\nCheck whether p has the right representation_size for a AbstractManifold M. Additionally if a tangent vector is given, both p and X are checked to be of corresponding correct representation sizes for points and tangent vectors on M.\n\nBy default, check_size returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}","page":"Basic functions","title":"ManifoldsBase.check_vector","text":"check_vector(M::AbstractManifold, p, X; kwargs...) -> Union{Nothing,String}\n\nCheck whether X is a valid tangent vector in the tangent space of p on the AbstractManifold M. An implementation does not have to validate the point p. If it is not a tangent vector, an error string should be returned.\n\nBy default, check_vector returns nothing, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the AbstractTangentVector type.\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.size_to_tuple-Union{Tuple{Type{S}}, Tuple{S}} where S<:Tuple","page":"Basic functions","title":"ManifoldsBase.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"method"},{"location":"functions/#ManifoldsBase.tangent_vector_type-Tuple{AbstractManifold, Type}","page":"Basic functions","title":"ManifoldsBase.tangent_vector_type","text":"tangent_vector_type(::AbstractManifold, point_type::Type)\n\nChange point_type that is a type of points on manifold M to matching type for representing tangent vectors.\n\n\n\n\n\n","category":"method"},{"location":"functions/#Approximation-Methods","page":"Basic functions","title":"Approximation Methods","text":"","category":"section"},{"location":"functions/#ManifoldsBase.AbstractApproximationMethod","page":"Basic functions","title":"ManifoldsBase.AbstractApproximationMethod","text":"AbstractApproximationMethod\n\nAbstract type for defining estimation methods on manifolds.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.CyclicProximalPointEstimation","page":"Basic functions","title":"ManifoldsBase.CyclicProximalPointEstimation","text":"CyclicProximalPointEstimation <: AbstractApproximationMethod\n\nMethod for estimation using the cyclic proximal point technique, which is based on proximal maps.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.EfficientEstimator","page":"Basic functions","title":"ManifoldsBase.EfficientEstimator","text":"EfficientEstimator <: AbstractApproximationMethod\n\nMethod for estimation in the best possible sense, see Efficiency (Statictsics) for more details. This can for example be used when computing the usual mean on an Euclidean space, which is the best estimator.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ExtrinsicEstimation","page":"Basic functions","title":"ManifoldsBase.ExtrinsicEstimation","text":"ExtrinsicEstimation{T} <: AbstractApproximationMethod\n\nMethod for estimation in the ambient space with a method of type T and projecting the result back to the manifold.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.GeodesicInterpolation","page":"Basic functions","title":"ManifoldsBase.GeodesicInterpolation","text":"GeodesicInterpolation <: AbstractApproximationMethod\n\nMethod for estimation based on geodesic interpolation.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.GeodesicInterpolationWithinRadius","page":"Basic functions","title":"ManifoldsBase.GeodesicInterpolationWithinRadius","text":"GeodesicInterpolationWithinRadius{T} <: AbstractApproximationMethod\n\nMethod for estimation based on geodesic interpolation that is restricted to some radius\n\nConstructor\n\nGeodesicInterpolationWithinRadius(radius::Real)\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.GradientDescentEstimation","page":"Basic functions","title":"ManifoldsBase.GradientDescentEstimation","text":"GradientDescentEstimation <: AbstractApproximationMethod\n\nMethod for estimation using gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.WeiszfeldEstimation","page":"Basic functions","title":"ManifoldsBase.WeiszfeldEstimation","text":"WeiszfeldEstimation <: AbstractApproximationMethod\n\nMethod for estimation using the Weiszfeld algorithm, compare for example the computation of the Geometric median.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.default_approximation_method-Tuple{AbstractManifold, Any}","page":"Basic functions","title":"ManifoldsBase.default_approximation_method","text":"default_approximation_method(M::AbstractManifold, f)\ndefault_approximation_method(M::AbtractManifold, f, T)\n\nSpecify a default estimation method for an AbstractManifold and a specific function f and optionally as well a type T to distinguish different (point or vector) representations on M.\n\nBy default, all functions f call the signature for just a manifold. The exceptional functions are:\n\nretract and retract! which fall back to default_retraction_method\ninverse_retract and inverse_retract! which fall back to default_inverse_retraction_method\nany of the vector transport mehods fall back to default_vector_transport_method\n\n\n\n\n\n","category":"method"},{"location":"functions/#Error-Messages","page":"Basic functions","title":"Error Messages","text":"","category":"section"},{"location":"functions/","page":"Basic functions","title":"Basic functions","text":"This interface introduces a small set of own error messages.","category":"page"},{"location":"functions/#ManifoldsBase.AbstractManifoldDomainError","page":"Basic functions","title":"ManifoldsBase.AbstractManifoldDomainError","text":"AbstractManifoldDomainError <: Exception\n\nAn absytract Case for Errors when checking validity of points/vectors on mainfolds\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ApproximatelyError","page":"Basic functions","title":"ManifoldsBase.ApproximatelyError","text":"ApproximatelyError{V,S} <: Exception\n\nStore an error that occurs when two data structures, e.g. points or tangent vectors.\n\nFields\n\nval amount the two approximate elements are apart â€“ is set to NaN if this is not known\nmsg a message providing more detail about the performed test and why it failed.\n\nConstructors\n\nApproximatelyError(val::V, msg::S) where {V,S}\n\nGenerate an Error with value val and message msg.\n\nApproximatelyError(msg::S) where {S}\n\nGenerate a message without a value (using val=NaN internally) and message msg.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ComponentManifoldError","page":"Basic functions","title":"ManifoldsBase.ComponentManifoldError","text":"CompnentError{I,E} <: Exception\n\nStore an error that occured in a component, where the additional index is stored.\n\nFields\n\nindex::I index where the error occured`\nerror::E error that occured.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.CompositeManifoldError","page":"Basic functions","title":"ManifoldsBase.CompositeManifoldError","text":"CompositeManifoldError{T} <: Exception\n\nA composite type to collect a set of errors that occured. Mainly used in conjunction with ComponentManifoldError to store a set of errors that occured.\n\nFields\n\nerrors a Vector of <:Exceptions.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.ManifoldDomainError","page":"Basic functions","title":"ManifoldsBase.ManifoldDomainError","text":"ManifoldDomainError{<:Exception} <: Exception\n\nAn error to represent a nested (Domain) error on a manifold, for example if a point or tangent vector is invalid because its representation in some embedding is already invalid.\n\n\n\n\n\n","category":"type"},{"location":"functions/#ManifoldsBase.OutOfInjectivityRadiusError","page":"Basic functions","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse_retract) is given arguments outside of its injectivity_radius.\n\n\n\n\n\n","category":"type"},{"location":"numerical_verification/#Numerical-Verification","page":"Numerical Verification","title":"Numerical Verification","text":"","category":"section"},{"location":"numerical_verification/#ManifoldsBase.check_inverse_retraction","page":"Numerical Verification","title":"ManifoldsBase.check_inverse_retraction","text":"check_inverse_retraction(\n    M::AbstractManifold,\n    inverse_rectraction_method::AbstractInverseRetractionMethod,\n    p=rand(M),\n    X=rand(M; vector_at=p);\n    #\n    exactness_tol::Real = 1e-12,\n    io::Union{IO,Nothing} = nothing,\n    limits::Tuple = (-8.0, 0.0),\n    log_range::AbstractVector = range(limits[1], limits[2]; length=N),\n    N::Int = 101,\n    name::String = \"inverse retraction\",\n    plot::Bool = false,\n    second_order::Bool = true\n    slope_tol::Real = 0.1,\n    error::Symbol = :none,\n    window = nothing,\n)\n\nCheck numerically wether the inverse retraction inverse_retraction_method is correct. This requires the exp and norm functions to be implemented for the AbstractManifold M.\n\nThis implements a method similar to [Bou23, Section 4.8 or Section 6.8].\n\nNote that if the errors are below the given tolerance and the method is exact, no plot is generated,\n\nKeyword arguments\n\nexactness_tol:     if all errors are below this tolerance, the inverse retraction is considered to be exact\nio:                provide an IO to print the result to\nlimits:            specify the limits in the log_range, that is the exponent for the range\nlog_range:         specify the range of points (in log scale) to sample the length of the tangent vector X\nN:                 number of points to verify within the log_range default range 10^-810^0\nname:              name to display in the plot\nplot:              whether to plot the result (see plot_slope) The plot is in log-log-scale. This is returned and can then also be saved.\nsecond_order:      check whether the retraction is of second order. if set to false, first order is checked.\nslope_tol:         tolerance for the slope (global) of the approximation\nerror:             specify how to report errors: :none, :info, :warn, or :error are available\nwindow:            specify window sizes within the log_range that are used for the slope estimation. the default is, to use all window sizes 2:N.\n\n\n\n\n\n","category":"function"},{"location":"numerical_verification/#ManifoldsBase.check_retraction","page":"Numerical Verification","title":"ManifoldsBase.check_retraction","text":"check_retraction(\n    M::AbstractManifold,\n    rectraction_method::AbstractRetractionMethod,\n    p=rand(M),\n    X=rand(M; vector_at=p);\n    #\n    exactness_tol::Real = 1e-12,\n    io::Union{IO,Nothing} = nothing,\n    limits::Tuple = (-8.0, 0.0),\n    log_range::AbstractVector = range(limits[1], limits[2]; length=N),\n    N::Int = 101,\n    name::String = \"retraction\",\n    plot::Bool = false,\n    second_order::Bool = true\n    slope_tol::Real = 0.1,\n    error::Symbol = :none,\n    window = nothing,\n)\n\nCheck numerically wether the retraction vector_transport_to is correct, by selecting a set of points q_i = exp_p (t_i X) where t takes all values from log_range, to then compare parallel_transport_to to the vector_transport_method applied to the vector Y.\n\nThis requires the exp, parallel_transport_to and norm function to be implemented for the AbstractManifold M.\n\nThis implements a method similar to [Bou23, Section 4.8 or Section 6.8].\n\nNote that if the errors are below the given tolerance and the method is exact, no plot is generated,\n\nKeyword arguments\n\nexactness_tol:     if all errors are below this tolerance, the retraction is considered to be exact\nio:                provide an IO to print the result to\nlimits:            specify the limits in the log_range, that is the exponent for the range\nlog_range:         specify the range of points (in log scale) to sample the length of the tangent vector X\nN:                 number of points to verify within the log_range default range 10^-810^0\nname:              name to display in the plot\nplot:              whether to plot the result (if Plots.jl is loaded). The plot is in log-log-scale. This is returned and can then also be saved.\nsecond_order:      check whether the retraction is of second order. if set to false, first order is checked.\nslope_tol:         tolerance for the slope (global) of the approximation\nerror:             specify how to report errors: :none, :info, :warn, or :error are available\nwindow:            specify window sizes within the log_range that are used for the slope estimation. the default is, to use all window sizes 2:N.\n\n\n\n\n\n","category":"function"},{"location":"numerical_verification/#ManifoldsBase.check_vector_transport","page":"Numerical Verification","title":"ManifoldsBase.check_vector_transport","text":"check_vector_transport(\n    M::AbstractManifold,\n    vector_transport_method::AbstractVectorTransportMethod,\n    p=rand(M),\n    X=rand(M; vector_at=p),\n    Y=rand(M; vector_at=p);\n    #\n    exactness_tol::Real = 1e-12,\n    io::Union{IO,Nothing} = nothing,\n    limits::Tuple = (-8.0, 0.0),\n    log_range::AbstractVector = range(limits[1], limits[2]; length=N),\n    N::Int = 101,\n    name::String = \"inverse retraction\",\n    plot::Bool = false,\n    second_order::Bool = true\n    slope_tol::Real = 0.1,\n    error::Symbol = :none,\n    window = nothing,\n)\n\nCheck numerically wether the retraction vector_transport_to is correct, by selecting a set of points q_i = exp_p (t_i X) where t takes all values from log_range, to then compare parallel_transport_to to the vector_transport_method applied to the vector Y.\n\nThis requires the exp, parallel_transport_to and norm function to be implemented for the AbstractManifold M.\n\nThis implements a method similar to [Bou23, Section 4.8 or Section 6.8].\n\nNote that if the errors are below the given tolerance and the method is exact, no plot is generated,\n\nKeyword arguments\n\nexactness_tol:     if all errors are below this tolerance, the differential is considered to be exact\nio:                provide an IO to print the result to\nlimits:            specify the limits in the log_range, that is the exponent for the range\nlog_range:         specify the range of points (in log scale) to sample the differential line\nN:                 number of points to verify within the log_range default range 10^-810^0\nname:              name to display in the plot\nplot:              whether to plot the result (if Plots.jl is loaded). The plot is in log-log-scale. This is returned and can then also be saved.\nsecond_order:      check whether the retraction is of second order. if set to false, first order is checked.\nslope_tol:         tolerance for the slope (global) of the approximation\nerror:             specify how to report errors: :none, :info, :warn, or :error are available\nwindow:            specify window sizes within the log_range that are used for the slope estimation. the default is, to use all window sizes 2:N.\n\n\n\n\n\n","category":"function"},{"location":"numerical_verification/#Internal-functions","page":"Numerical Verification","title":"Internal functions","text":"","category":"section"},{"location":"numerical_verification/","page":"Numerical Verification","title":"Numerical Verification","text":"The following functions split the check into several parts, for example looking for the best fitting window and finding out the best slope, or plotting the slope.","category":"page"},{"location":"numerical_verification/#ManifoldsBase.find_best_slope_window","page":"Numerical Verification","title":"ManifoldsBase.find_best_slope_window","text":"(a, b, i, j) = find_best_slope_window(X, Y, window=nothing; slope::Real=2.0, slope_tol::Real=0.1)\n\nCheck data X,Y for the largest contiguous interval (window) with a regression line fitting â€œbestâ€. Among all intervals with a slope within slope_tol to slope the longest one is taken. If no such interval exists, the one with the slope closest to slope is taken.\n\nIf the window is set to nothing (default), all window sizes 2,...,length(X) are checked. You can also specify a window size or an array of window sizes.\n\nFor each window size, all its translates in the data is checked. For all these (shifted) windows the regression line is computed (with a,b in a + t*b) and the best line is computed.\n\nFrom the best line the following data is returned\n\na, b specifying the regression line a + t*b\ni, j determining the window, i.e the regression line stems from data X[i], ..., X[j]\n\nnote: Note\nThis function has to be implemented using some statistics package. loading Statistics.jl provides a default implementation.\n\n\n\n\n\n","category":"function"},{"location":"numerical_verification/#ManifoldsBase.plot_slope-Tuple{Any, Any}","page":"Numerical Verification","title":"ManifoldsBase.plot_slope","text":"plot_slope(x, y;\n    slope=2,\n    line_base=0,\n    a=0,\n    b=2.0,\n    i=1,\n    j=length(x)\n)\n\nPlot the result from the verification functions on data x,y with two comparison lines\n\nline_base + tslope  as the global slope(s) the plot could have\na + b*t on the interval [x[i], x[j]] for some (best fitting) comparison slope\n\nnote: Note\nThis function has to be implemented for a certain plotting package. loading Plots.jl provides a default implementation.\n\n\n\n\n\n","category":"method"},{"location":"tutorials/implement-a-manifold/#How-to-Implement-a-Manifold","page":"How to define a manifold","title":"How to Implement a Manifold","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"This tutorial illustrates, how to implement your very first manifold. We start from the very beginning and cover the basic ideas of the interface provided by ManifoldsBase.jl interface.","category":"page"},{"location":"tutorials/implement-a-manifold/#Preliminaries","page":"How to define a manifold","title":"Preliminaries","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We will use a simple example in this tutorial, since the main focus here is to illustrate how to define a manifold. We will use the sphere of radius r embedded in mathbb R^d+1, i.e.Â all vectors of length r. Formally we define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"mathbb S_r^d =\nbigl\n    p in mathbb R^d+1\n    big\n    lVert p rVert = r\nbigr","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"When defining a Riemannian manifold mathematically, there is several things to keep in mind, for example the metric imposed on the tangent spaces. For this interface we assume these things to be given implicitly for a first implementation, but they can be made more precise when necessary.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"The only thing we have to be aware of for now is the number_system, i.e.Â whether our manifold is a real-valued or a complex-valued manifold. The abstract type all manifolds inherit from, the AbstractManifold{ğ”½} has this number system as a parameter. The usual parameter we will use are the RealNumbers(), which have a short hand in ManifoldsBase.jl, namely â„. The second one are the ComplexNumbers(), or â„‚ for short.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"using LinearAlgebra, ManifoldsBase\nusing ManifoldsBase: â„","category":"page"},{"location":"tutorials/implement-a-manifold/#Defining-a-manifold","page":"How to define a manifold","title":"Defining a manifold","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"A manifold itself is a struct that is a subtype of AbstractManifold and should contain. We usually recommend to also document your new manifold.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Since the Sphere is already a name used within Manifolds.jl, letâ€™s use a slightly more specific name. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"\"\"\"\n    ScaledSphere <: AbstractManifold{â„}\n\nDefine a sphere of fixed radius\n\n# Fields\n\n* `dimension` dimension of the sphere\n* `radius` the radius of the sphere\n\n# Constructor\n\n    ScaledSphere(dimension,radius=1.0)\n\nInitialize the manifold to a certain `dimension` and `radius`,\nwhich by default is set to `1.0`\n\"\"\"\nstruct ScaledSphere <: AbstractManifold{â„}\n    dimension::Int\n    radius::Float64\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And we can directly use this manifold and set","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"M = ScaledSphere(2,1.5)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ScaledSphere(2, 1.5)","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-I:-Manifold-properties","page":"How to define a manifold","title":"Functions I: Manifold properties","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"While the interface provides a lot of possible functions to define for your manifold, you only need to define those that are necessary for your implementation. If you are using other packages depending on ManifoldsBase.jl you will often just get a â€œMethod not definedâ€ and sometimes an ambiguity error indicating that a function is missing that is required for a certain task.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We can first start with a technical function which internally is often used. Any of our points or tangent vectors are represented as a (d+1)-dimensional vector. This is internally often used when allocating memory, see representation_size. It returns a tuple representing the size of arrays for valid points. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: representation_size\nrepresentation_size(M::ScaledSphere) = (M.dimension+1,)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Similarly, we can implement the function returning the dimension of the manifold, cf.Â manifold_dimension as","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: manifold_dimension\nmanifold_dimension(M::ScaledSphere) = M.dimension","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and we can now easily use them to access the dimension of the manifold","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"manifold_dimension(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"2","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-II:-Verifying-Points-and-tangent-vectors","page":"How to define a manifold","title":"Functions II: Verifying Points and tangent vectors","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"The first two functions we want to define are those to check points and tangent vectors for our manifold. Letâ€™s first clarify what the tangent space looks like. The directions â€œwe can walk intoâ€ from a point pin mathbb S_r^d are all X that are orthogonal to p, which is the plane/vector space tangent to the sphere. Formally","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"T_pmathbb S_r^d =\nbigl\n    X in mathbb R^d+1\n    big\n    langle p X rangle = 0\nbigr qquad p in mathbb S_r^d","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"to verify either p or X one uses is_point(M,p) and is_vector(M, p, X) respectively. Since both involve some automatic options and possibilities, for example whether to throw an error or just return false, both mention that the actual functions to implement are check_point and check_vector, which both do not throw but return an error if something is wrong.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"In principle we would have to check two properties, namely that the size of p is of correct size M.dimension+1 and that its norm is M.radius. Luckily, by defining representation_size the first check is automatically done already â€“Â actually for both points and vectors. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: check_point\nfunction check_point(M::ScaledSphere, p; kwargs...)\n    if !isapprox(norm(p), M.radius; kwargs...)\n        return DomainError(norm(p), \"The norm of $p is not $(M.radius).\")\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And we can directly test the function. To see all 3 failing ones, we switch from errors to warnings in the check","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"is_point(M, [1.5, 0.0], error=:warn) # wrong size\nis_point(M, [1.0, 0.0, 0.0], error=:warn) # wrong norm\nis_point(M, [1.5, 0.0, 0.0], error=:warn) # on the manifold, returns true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"â”Œ Warning: DomainError with (2,):\nâ”‚ The point [1.5, 0.0] can not belong to the manifold Main.Notebook.ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifolds representation size ((3,)).\nâ”” @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:823\nâ”Œ Warning: DomainError with 1.0:\nâ”‚ The norm of [1.0, 0.0, 0.0] is not 1.5.\nâ”” @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:836\n\ntrue","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"similarly for vectors, we just have to implement the orthogonality check.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: check_vector\nfunction check_vector(M::ScaledSphere, p, X; kwargs...)\n    if !isapprox(dot(p,X), 0.0; kwargs...)\n        return DomainError(\n            dot(p,X),\n            \"The tangent vector $X is not orthogonal to $p.\"\n        )\n    end\n    return nothing\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and again, the high level interface can be used to display warnings for vectors not fulfilling the criterion, but we can also activate a check for the point using the last positional argument","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"is_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0]; error=:warn) # wrong size\nis_vector(M, [1.5, 0.0, 0.0], [1.0, 1.0, 0.0]; error=:warn) # not orthogonal norm\nis_vector(M, [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], true; error=:warn) # point not valid\nis_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0, 0.0], true; error=:warn) # returns true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"â”Œ Warning: DomainError with (2,):\nâ”‚ The tangent vector [0.0, 1.0] can not belong to the manifold Main.Notebook.ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifodls representation size ((3,)).\nâ”” @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:894\nâ”Œ Warning: DomainError with 1.5:\nâ”‚ The tangent vector [1.0, 1.0, 0.0] is not orthogonal to [1.5, 0.0, 0.0].\nâ”” @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:907\nâ”Œ Warning: DomainError with 1.0:\nâ”‚ The norm of [1.0, 0.0, 0.0] is not 1.5.\nâ”” @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:836\n\ntrue","category":"page"},{"location":"tutorials/implement-a-manifold/#Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction.","page":"How to define a manifold","title":"Functions on Manifolds III: The exponential map and a retraction.","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"For the final group of functions, we want to implement the exponential map and a retraction. Both are ways to â€œmove aroundâ€ on the manifold, that is, given a point p and a tangent vector indicating a â€œwalking directionâ€, the two functions we define will return a new point q on the manifold.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"For functions that compute a new point or tangent vector, ManifoldsBase.jl always provides two variants: One that allocates new memory, and one that allows to provide the memory the result should be returned inÂ to spare memory allocations.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Letâ€™s first take a look at what the exponential map is defined like. We follow the shortest curves, that is great arcs, on the sphere. Formally we have","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"exp_p X =\ncosBigl(frac1rlVert X rVertBigr)p +\nsinBigl(frac1rlVert X rVertBigr)fracXlVert X rVert","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"In fact, from the two functions above, exp(M, p, X), and exp!(M, q, p, X) that works in place of q, we only have to implement the second. The first one, exp by default falls back to allocating memory and calling the second. So exp should only be defined, if there is a special reason for. Furthermore, we usually do not verify/check inputs to spare time. If a user feels insecure, they could for example use the ValidationManifold wrapper which adds explicit checks of inputs and outputs.","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: exp!\nfunction exp!(M::ScaledSphere, q, p, X)\n    nX = norm(X)\n    if nX == 0\n        q .= p\n    else\n        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (1/nX) .* X\n    end\n    return q\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and we can directly test our function starting in the north pole and â€œwalking downâ€ to the equator","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"q = exp(M, [0.0, 0.0, 1.5], [0.75Ï€, 0.0, 0.0])","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.5\n 0.0\n 9.184850993605148e-17","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"but we also get the other variants for free, for example","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"q2 = zero(q)\nexp!(M, q2, [0.0, 0.0, 1.5], [0.75Ï€, 0.0, 0.0])\nq2","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.5\n 0.0\n 9.184850993605148e-17","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"or the one that shortens or elongates the path by a factor, for example, if we walk twice the distance, we reach the opposite point","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ManifoldsBase.exp_fused!(M, q2, [0.0, 0.0, 1.5], [0.75Ï€, 0.0, 0.0], 2.0)\nq2","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n  1.8369701987210297e-16\n  0.0\n -1.5","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Of course we can easily check that both points we computed still lie on the sphere","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"all([is_point(M, q), is_point(M, q2)])","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"true","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Since the exponential map might in general be expensive, we can do a similar implementation with the ProjectionRetraction. Here, we really have to take into account, that the interface is designed with 3 levels in mind: While the actual function we would call in the end is retract(M, p, X, ProjectionRetraction()) (or its ! variant), we actually have to implement retract_project!(M, q, p, X, t) for technical details, that are a bit beyond this introductory tutorial. In short this split avoids ambiguity errors for decorators of the manifolds. We define","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"function ManifoldsBase.retract_project!(M::ScaledSphere, q, p, X)\n    q .= (p + X) .* (M.radius/norm(p + X))\n    return q\nend","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"And to test also this function, and avoiding allocations at the same time, we call","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"retract!(M, q, [0.0, 0.0, 1.5], [0.75Ï€, 0.0, 0.0], ProjectionRetraction())","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"3-element Vector{Float64}:\n 1.2653454121031529\n 0.0\n 0.8055439082194726","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Finally, there is default_retraction_method to specify which is the default retraction to use. By default this is","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ExponentialRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"But we can easily specify this for our manifold as well, for example defining","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"import ManifoldsBase: default_retraction_method\ndefault_retraction_method(::ScaledSphere) = ProjectionRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method (generic function with 6 methods)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Then","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"default_retraction_method(M)","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"ProjectionRetraction()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"and retract without a method specified would always fall back to using the projection retraction instead of the exponential map. Note that for compatibility there is the AbstractRetractionMethod called ExponentialRetraction which makes retract fall back to calling exp.","category":"page"},{"location":"tutorials/implement-a-manifold/#Technical-Details","page":"How to define a manifold","title":"Technical Details","text":"","category":"section"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"This notebook was rendered with the following environment","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Pkg.status()","category":"page"},{"location":"tutorials/implement-a-manifold/","page":"How to define a manifold","title":"How to define a manifold","text":"Status `~/work/ManifoldsBase.jl/ManifoldsBase.jl/tutorials/Project.toml`\n  [3362f125] ManifoldsBase v2.0.1 `~/work/ManifoldsBase.jl/ManifoldsBase.jl`\n  [91a5bcdd] Plots v1.41.1","category":"page"},{"location":"NEWS/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"NEWS/#[2.0.1](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v2.0.1)-(17/10/2025)","page":"Changelog","title":"2.0.1 (17/10/2025)","text":"","category":"section"},{"location":"NEWS/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"get_vector, get_coordinates, project and their mutating variants now use traits for propagation.","category":"page"},{"location":"NEWS/#[2.0.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v2.0.0)-(02/10/2025)","page":"Changelog","title":"2.0.0 (02/10/2025)","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"While this release should be mostly backward compatible, especially when using defined manifolds from Manifolds.jl, some breaking changes were introduced. To be precise, defining and using traits e.g. to dispatch functions to the embedding changed internally. If you defined your own manifolds and used traits, please check the documentation of the new trait","category":"page"},{"location":"NEWS/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"an interface for quotient manifolds. this also unified the naming a bit. Formerly differential_canonical_project is now diff_canonical_project.","category":"page"},{"location":"NEWS/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"refactor the trait system to no longer use a list of traits but single traits separately for the metric and the embedding specification\nSwitch to using Runic.jl as code formatter","category":"page"},{"location":"NEWS/#Removed","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"ODEExponentialRetraction was removed in favor of solve_chart_exp_ode implemented in Manifolds.jl.","category":"page"},{"location":"NEWS/#[1.2.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v1.2.0)-(08/05/2025)","page":"Changelog","title":"1.2.0 (08/05/2025)","text":"","category":"section"},{"location":"NEWS/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"tangent_vector_type for converting point types to matching tangent vector types.","category":"page"},{"location":"NEWS/#[1.1.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v1.1.0)-(29/04/2025)","page":"Changelog","title":"1.1.0 (29/04/2025)","text":"","category":"section"},{"location":"NEWS/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"default_basis(M) to be more flexible than a fixed DefaultOrthonormalBasis default.\nStabilizedRetraction, a retraction that improves numerical stability of another retraction by projecting the resulting point.","category":"page"},{"location":"NEWS/#[1.0.3](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v1.0.3)-(08/04/2025)","page":"Changelog","title":"1.0.3 (08/04/2025)","text":"","category":"section"},{"location":"NEWS/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"VectorSpaceFiber no longer requires the number system to be consistent with the wrapped manifold.","category":"page"},{"location":"NEWS/#[1.0.2](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v1.0.2)-(07/04/2025)","page":"Changelog","title":"1.0.2 (07/04/2025)","text":"","category":"section"},{"location":"NEWS/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fiber no longer requires the number system to be consistent with the wrapped manifold.","category":"page"},{"location":"NEWS/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"allocate method that works with numeric scalars.","category":"page"},{"location":"NEWS/#[1.0.1](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v1.0.1)-(05/02/2025)","page":"Changelog","title":"1.0.1 (05/02/2025)","text":"","category":"section"},{"location":"NEWS/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"An issue with allocation type promotion in exp_fused.","category":"page"},{"location":"NEWS/#[1.0]-05/02/2025","page":"Changelog","title":"[1.0] 05/02/2025","text":"","category":"section"},{"location":"NEWS/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"to avoid logical ambiguities to the forthcoming LieGroups.jl, the â€œfusingâ€ variant exp(M, p, X, t) has been moved to its own name exp_fused(M, p, X, t) and similarly exp!(M, q, p, X, t) has been moved to its own name exp_fused!(M, q, p, X, t). Note that the new exp_fused! method is not exported and by default falls back to calling exp! with t*X. Actions to take\nif you just implemented an own exp(M, p, X) or exp!(M, q, p, X) everything works as before.\nif you implemented a fused variant exp!(M, q, p, X, t) you have to adapt two things\nmove that implementation to ManifoldsBase.exp_fused!(M, q, p, X, t)\nImplement the default exp!(M, q, p, X) = ManifoldBase.exp_fused!(M, q, p, one(eltype(p)), X),\nor an own specific implementation for the non-fused variant.\nSimilar to exp, the â€œfusingâ€ variant retract(M, p, X, t, m) has been moved to its own name retract_fused(M, p, X, t, m)  and similarly retract!(M, q, p, X, t, m) has been moved to its own name retract_fused!(M, q, p, X, t, m). Note that the new retract_fused! method is not exported and by default falls back to calling retract! with t*X. Actions to take\nif you just implemented an own retract(M, p, X, m) or retract!(M, q, p, X, m) everything works as before.\nif you implemented a fused variant retract!(M, q, p, X, t) you have to adapt two things\nmove that implementation to ManifoldsBase.retract_fused!(M, q, p, X, t, m)\nImplement the default retract!(M, q, p, X, m) = ManifoldBase.retract_fused!(M, q, p, one(eltype(p)), X), or an own specific implementation for the non-fused variant.\nthe TVector type has been renamed to AbstractTangentVector\nthe CoTVector type has been renamed to AbstractCotangentVector","category":"page"},{"location":"NEWS/#Removed-2","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"parallel_transport_along(M, p, X, c), vector_transport_along(M, p, X, c, m) as well as their mutating variants are removed from the API for now. It was never specified how to actually specify a curve c and the method was only implemented for Euclidean in Manifolds.jl, where it is the identity.","category":"page"},{"location":"NEWS/#[0.15.24](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.24)-(17/01/2025)","page":"Changelog","title":"0.15.24 (17/01/2025)","text":"","category":"section"},{"location":"NEWS/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"extended support for allocate_on with ArrayPartition.","category":"page"},{"location":"NEWS/#[0.15.23](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.23)-(09/12/2024)","page":"Changelog","title":"0.15.23 (09/12/2024)","text":"","category":"section"},{"location":"NEWS/#Added-7","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"a field point to ValidationFibreVector to potentially store the point of the vector.\na field store_base_point to ValidationManifold to indicate whether for new fibre vectors the base point should be stored.\na keyword ignore_contexts to ValidationManifold to ignore certain contexts from validation, such as :Input, :Output, :Point, or :Vector.\na keyword ignore_functions to ValidationFibreVector to ignore certain contexts within a single function. This is provided as a dictionary with the key being the (allocating) function and the value is a context or vector of contexts.","category":"page"},{"location":"NEWS/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"the internal function array_value was renamed to internal_value and is now exported, since it can be also used on elements that store values different from arrays,","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"e.g. a ValidationMPoint storing a subtype of a ManifoldPoint. array_value is hence deprecated.","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Minimum Julia version is now 1.10 (the LTS which replaced 1.6)","category":"page"},{"location":"NEWS/#[0.15.22](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.22)-(15/11/2024)","page":"Changelog","title":"0.15.22 (15/11/2024)","text":"","category":"section"},{"location":"NEWS/#Added-8","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"DefaultOrthonormalBasis() is now the default basis for get_vector, get_vector!, get_vectors, get_coordinates and get_coordinates!.","category":"page"},{"location":"NEWS/#[0.15.21](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.21)-(12/11/2024)","page":"Changelog","title":"0.15.21 (12/11/2024)","text":"","category":"section"},{"location":"NEWS/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Coordinate allocation was improved to be more friendly with automatic differentiation.","category":"page"},{"location":"NEWS/#[0.15.20](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.20)-(24/10/2024)","page":"Changelog","title":"0.15.20 (24/10/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"norm function on VectorSpaceFiber (such as TangentSpace) now needs to be called without the point. The passed point was already ignored before.","category":"page"},{"location":"NEWS/#[0.15.19](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.19)-(20/10/2024)","page":"Changelog","title":"0.15.19 (20/10/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-7","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"make has_components introduced in the last version a decorator trait function.","category":"page"},{"location":"NEWS/#[0.15.18](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.18)-(18/10/2024)","page":"Changelog","title":"0.15.18 (18/10/2024)","text":"","category":"section"},{"location":"NEWS/#Added-9","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"distance(M, p, q, r) to compute r-norms on manifolds that have components.\ndistance(M, p, q, m, r) to compute (approximate) r-norms on manifolds that have components using an AbstractInverseRetractionMethod m within every (inner) distance call.\nnorm(M, p, X, r) to compute r-norms on manifolds that have components.","category":"page"},{"location":"NEWS/#[0.15.17](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.17)-(04/10/2024)","page":"Changelog","title":"0.15.17 (04/10/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-8","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Mildly breaking: the number system parameter now corresponds to the coefficients standing in front of basis vectors in a linear combination instead of components of a vector. For example, DefaultOrthonormalBasis() == DefaultOrthonormalBasis(â„) of DefaultManifold(3, field=â„‚) now has 6 vectors, and DefaultOrthonormalBasis(â„‚) of the same manifold has 3 basis vectors.","category":"page"},{"location":"NEWS/#[0.15.16](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.16)-(13/09/2024)","page":"Changelog","title":"0.15.16 (13/09/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-9","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Adapt the traits, so that they also can be used when only using ManifoldsBase,","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"without importing internal structs like EmptyTrait and TraitList","category":"page"},{"location":"NEWS/#[0.15.15](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.15)-(29/08/2024)","page":"Changelog","title":"0.15.15 (29/08/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-10","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Refactored error message code when ProductManifold is used without RecursiveArrayTools.jl.","category":"page"},{"location":"NEWS/#[0.15.14](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.14)-(27/08/2024)","page":"Changelog","title":"0.15.14 (27/08/2024)","text":"","category":"section"},{"location":"NEWS/#Added-10","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"A helpful error message when ProductManifold is used without RecursiveArrayTools.jl.","category":"page"},{"location":"NEWS/#Changed-11","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"representation_size for ProductManifold now returns nothing instead of a one-element tuple. This change makes it easier to notice errors caused by not having RecursiveArrayTools.jl loaded.","category":"page"},{"location":"NEWS/#[0.15.13](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.13)-(10/08/2024)","page":"Changelog","title":"0.15.13 (10/08/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-12","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fixed a small bug that caused calling get_vectors on PowerManifolds","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"to sometimes cause an error, cf #199.","category":"page"},{"location":"NEWS/#[0.15.12](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.12)-(03/08/2024)","page":"Changelog","title":"0.15.12 (03/08/2024)","text":"","category":"section"},{"location":"NEWS/#Changed-13","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Improved performance of power manifold creation and some cases of get_component on product manifold.","category":"page"},{"location":"NEWS/#[0.15.11](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.11)-(28/07/2024)","page":"Changelog","title":"0.15.11 (28/07/2024)","text":"","category":"section"},{"location":"NEWS/#Added-11","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Function allocate_on to generically allocate point and tangent vectors on a manifold without a pre-existing instance but of a particular type.\nFunction default_type to get the default type of points and tangent vectors for a manifold.\nPackage extension for the Quaternions.jl package that handles allocation.","category":"page"},{"location":"NEWS/#Changed-14","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Default allocation method was made more robust to custom promotion functions.","category":"page"},{"location":"NEWS/#[0.15.10](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.10)-(19/05/2024)","page":"Changelog","title":"0.15.10 (19/05/2024)","text":"","category":"section"},{"location":"NEWS/#Added-12","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Functions fill(p, N) and fill!(P, p, N) to fill values into a point on a power manifold N.\nintroduce a base_point(TpM) to access the base point of a tangent space\nintroduce TpM[i] to access tangent spaces of factors from an AbstractPowerManifold or a ProductManifold.","category":"page"},{"location":"NEWS/#[0.15.9](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.9)-(02/05/2024)","page":"Changelog","title":"0.15.9 (02/05/2024)","text":"","category":"section"},{"location":"NEWS/#Added-13","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Tests now also use Aqua.jl to spot problems in the code such as ambiguities.\nintroduce a check_inverse_retraction function to numerically check whether an inverse retraction method is a (correct) inverse retraction.\nintroduce a check_retraction function to numerically check whether a retraction method is a (correct) retraction.\nintroduce a check_vector_transport function to numerically check whether a vector transport is a (correct) vector transport.","category":"page"},{"location":"NEWS/#Changed-15","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"introduced a ManifoldsBaseTestUtils module to encapsulate common types and function definitions in different parts of the tests.","category":"page"},{"location":"NEWS/#[0.15.8](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.8)-(13/03/2024)","page":"Changelog","title":"0.15.8 (13/03/2024)","text":"","category":"section"},{"location":"NEWS/#Added-14","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"sectional_curvature , sectional_curvature_max and sectional_curvature_min functions for obtaining information about sectional curvature of a manifold.","category":"page"},{"location":"NEWS/#[0.15.7](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.7)-(24/01/2024)","page":"Changelog","title":"0.15.7 (24/01/2024)","text":"","category":"section"},{"location":"NEWS/#Fixed-3","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"is_point and is_vector can now more stably :info or :warn when they return false, since they emply showerror for these displays.","category":"page"},{"location":"NEWS/#[0.15.6](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.6)-(15/12/2023)","page":"Changelog","title":"0.15.6 (15/12/2023)","text":"","category":"section"},{"location":"NEWS/#Added-15","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"An AbstractApproximationMethod to specify estimation methods for other more general functions,","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"as well as a default_approximation_method to specify defaults on manifolds.","category":"page"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"An EmbeddedVectorTransport to use a vector transport in the embedding and a final projection.","category":"page"},{"location":"NEWS/#Fixed-4","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"number_eltype correctly returns scalar type for nested array types like number_eltype(Vector{Vector{Float64}}).","category":"page"},{"location":"NEWS/#[0.15.5](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.5)-(13/12/2023)","page":"Changelog","title":"0.15.5 (13/12/2023)","text":"","category":"section"},{"location":"NEWS/#Added-16","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Compatibility with RecursiveArrayTools v3.","category":"page"},{"location":"NEWS/#[0.15.4](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.4)-(25/11/2023)","page":"Changelog","title":"0.15.4 (25/11/2023)","text":"","category":"section"},{"location":"NEWS/#Fixed-5","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fixed a bug reported in Manopt#330.","category":"page"},{"location":"NEWS/#[0.15.3](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.3)-(17/11/2023)","page":"Changelog","title":"0.15.3 (17/11/2023)","text":"","category":"section"},{"location":"NEWS/#Fixed-6","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Pass kwargs in rand! for AbstractPowerManifold to appropriate methods on the wrapped manifold.","category":"page"},{"location":"NEWS/#[0.15.2](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.2)-(8/11/2023)","page":"Changelog","title":"0.15.2 (8/11/2023)","text":"","category":"section"},{"location":"NEWS/#Fixed-7","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"vee and hat now use real coefficient basis for complex manifolds.","category":"page"},{"location":"NEWS/#[0.15.1](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.1)-(30/10/2023)","page":"Changelog","title":"0.15.1 (30/10/2023)","text":"","category":"section"},{"location":"NEWS/#Added-17","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"zero_vector(TpM) to generate a zero vector in the tangent space\na GitHub CI action that errors, when this file was not updated on a PR","category":"page"},{"location":"NEWS/#Fixed-8","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"is_point and is_vector for the tangent space now correctly forward to vector checks on the corresponding manifold. The same for both check_sizes\nadd [compat] entries for the standard libraries.","category":"page"},{"location":"NEWS/#[0.15.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.15.0)-(21/10/2023)","page":"Changelog","title":"0.15.0 (21/10/2023)","text":"","category":"section"},{"location":"NEWS/#Added-18","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"ProductManifold type was migrated from Manifolds.jl.\nFiber, VectorSpaceFiber and TangentSpace types. TangentSpace is a generalized version of TangentSpaceAtPoint from Manifolds.jl.\nA keyword to ValidationManifold which error= mode to use. This is by default the previous :error mode.\nchange_representer!, change_metric! and Weingarten! methods added to PowerManifold.\nÃ— now also works for retractions, inverse retractions, and vector transports to create their product versions\nretract, inverse_retract, and vector_transport_to (and _dir) now also accept arbirtrary retractions on the product manifold. These act the same as the n-fold product of a retraction.","category":"page"},{"location":"NEWS/#Changed-16","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"retract now behaves like exp in the sense that it allocates early, which reduces the amount of code to dispatch through levels 1-3 twice\ninverse_retract now behaves like log in the sense that it allocates early\nRequires.jl is added as a dependency to facilitate loading some methods related to ProductManifolds on Julia 1.6 to 1.8. Later versions rely on package extensions.\nDocumenter.jl was updated to 1.0.\nPowerManifold can now store its size either in a field or in a type, similarly to DefaultManifold. By default the size is stored in a field.\nThe signature of is_point was changed to be consistent with isapprox.. The error positional symbol (third argument) is now a keyword argument. We left the boolean shortcut in place. That means\nis_point(M, p, true) works the same as before (false is the default anyways)\nis_point(M, p, :warn) has to be changed to is_point(M, p; error=:warn)\nThe signature of is_vector was changed to be consistent with isapprox and is_point. The error positional symbol (fourth argument) is now a keyword argument. The error positional boolean (fourth argument) hence moved to fifth place (after check_base_point) This means\nis_vector(M, p, X, true) should now be is_vector(M, p, X; error=:error)\nis_vector(M, p, X, err, base) for two booleans err, base should now be is_vector(M, p, X, base, err)\nis_vector(M, p, X, err, base) for a symbol err should now be is_vector(M, p, X, base; error=err)","category":"page"},{"location":"NEWS/#Removed-3","page":"Changelog","title":"Removed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Julia 1.0 is no longer supported. From now on, the earliest supported Julia version is 1.6.","category":"page"},{"location":"NEWS/#[0.14.12](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.12)-(23/09/2023)","page":"Changelog","title":"0.14.12 (23/09/2023)","text":"","category":"section"},{"location":"NEWS/#Changed-17","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Introduce a thorough way to allocate tangent vectors for rand","category":"page"},{"location":"NEWS/#[0.14.11](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.11)-(25/08/2023)","page":"Changelog","title":"0.14.11 (25/08/2023)","text":"","category":"section"},{"location":"NEWS/#Added-19","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Make the Weingarten map a decorator capable function.","category":"page"},{"location":"NEWS/#[0.14.10](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.10)-(17/08/2023)","page":"Changelog","title":"0.14.10 (17/08/2023)","text":"","category":"section"},{"location":"NEWS/#Added-20","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"introduce the Weingarten map and its in place variant Weingarten!.","category":"page"},{"location":"NEWS/#[0.14.9](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.9)-(03/08/2023)","page":"Changelog","title":"0.14.9 (03/08/2023)","text":"","category":"section"},{"location":"NEWS/#Added-21","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Introduce an interface that allows the static size of a manifold to be a field as well.","category":"page"},{"location":"NEWS/#[0.14.8](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.8)-(07/07/2023)","page":"Changelog","title":"0.14.8 (07/07/2023)","text":"","category":"section"},{"location":"NEWS/#Changed-18","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Improve show for cached bases and make it more robust","category":"page"},{"location":"NEWS/#[0.14.7](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.7)-(07/07/2023)","page":"Changelog","title":"0.14.7 (07/07/2023)","text":"","category":"section"},{"location":"NEWS/#Changed-19","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"the tutorial is now written in Quarto.","category":"page"},{"location":"NEWS/#[0.14.6](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.6)-(10/06/2023)","page":"Changelog","title":"0.14.6 (10/06/2023)","text":"","category":"section"},{"location":"NEWS/#Added-22","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"export the inplace random function rand!","category":"page"},{"location":"NEWS/#[0.14.5](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.5)-(03/05/2023)","page":"Changelog","title":"0.14.5 (03/05/2023)","text":"","category":"section"},{"location":"NEWS/#Added-23","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Allow to specify an AbstractManifold when converting points or tangent vector types.","category":"page"},{"location":"NEWS/#[0.14.4](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.4)-(10/04/2023)","page":"Changelog","title":"0.14.4 (10/04/2023)","text":"","category":"section"},{"location":"NEWS/#Changed-20","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fix copy to work properly when copying Numbers","category":"page"},{"location":"NEWS/#[0.14.3](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.3)-(16/03/2023)","page":"Changelog","title":"0.14.3 (16/03/2023)","text":"","category":"section"},{"location":"NEWS/#Changed-21","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fix an allocation bug in nested power manifolds","category":"page"},{"location":"NEWS/#[0.14.2](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.2)-(16/03/2023)","page":"Changelog","title":"0.14.2 (16/03/2023)","text":"","category":"section"},{"location":"NEWS/#Added-24","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"adds a DependaBot workflow.","category":"page"},{"location":"NEWS/#Changed-22","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Fix an allocation issue with exp(M, p, X, t) that did not respect the type of t.","category":"page"},{"location":"NEWS/#[0.14.1](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.1)-(18/02/2023)","page":"Changelog","title":"0.14.1 (18/02/2023)","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Note that this release did not trigger a TagBot, so it appears within 0.14.2 in the tagged/created releases","category":"page"},{"location":"NEWS/#Added-25","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Introduce change_representer already in ManifoldsBase.","category":"page"},{"location":"NEWS/#[0.14.0](https://github.com/JuliaManifolds/Manopt.jl/releases/tag/v0.14.0)-(â€“-15/02/2023)","page":"Changelog","title":"0.14.0 (â€“ 15/02/2023)","text":"","category":"section"},{"location":"NEWS/#Added-26","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Type restriction for t in scaled retractions relaxed to Number.\nembed_project(M::AbstractManifold, p) and embed_project(M::AbstractManifold, p, X) that are like projections onto a manifold or a tangent space but are guaranteed to be idempotent.","category":"page"},{"location":"NEWS/#Changed-23","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"NEWS/","page":"Changelog","title":"Changelog","text":"Retractions for scaled vectors no longer dispatch to non-scaled retractions. It is now reversed for performance reasons. Please either just define exp!(::MyManifold, q, p, X, t::Number) or both this and exp!(::MyManifold, q, p, X).\nDefaultManifold now stores size in a field instead of the type itself to reduce the amount of compilation needed.\nFixed typo in inverse_retract_caley (now inverse_retract_cayley) and retract_caley (now retract_cayley).\nretract_pade and retract_pade! now receive PadeRetraction objects instead of just n.","category":"page"},{"location":"decorator/#A-Decorator-for-manifolds","page":"Decorating/Extending a Manifold","title":"A Decorator for manifolds","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"Several properties of a manifold are often implicitly assumed, for example the choice of the (Riemannian) metric or the embedding. The latter shall serve as an example how to either implicitly or explicitly specify the embedding to avoid re-implementations and/or distinguish different embeddings.","category":"page"},{"location":"decorator/#The-abstract-decorator","page":"Decorating/Extending a Manifold","title":"The abstract decorator","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"When first implementing a manifold, it might be beneficial to dispatch certain computations to already existing manifolds. For an embedded manifold that is isometrically embedded this might be the inner the manifold inherits in each tangent space from its embedding.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"This means we would like to dispatch the default implementation of a function to some other manifold. We refer to this as implicit decoration, since one can not â€œseeâ€ explicitly that a certain manifold inherits this property. As an example consider the Sphere. At each point the tangent space can be identified with a subspace of the tangent space in the embedding, the Euclidean manifold which the unit vectors of the sphere belong to. Thus every tangent space inherits its metric from the embedding. Since in the default implementation in Manifolds.jl points are represented by unit vectors and tangent vectors at a point as vectors orthogonal to that point, we can just dispatch the inner product to the embedding without having to re-implement this. The manifold using such an implicit dispatch just has to be a subtype of AbstractDecoratorManifold.","category":"page"},{"location":"decorator/#Traits-with-an-inheritance-hierarchy","page":"Decorating/Extending a Manifold","title":"Traits with an inheritance hierarchy","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"The properties mentioned above might form a hierarchy. For embedded manifolds, again, we might have just a manifold whose points are represented in some embedding. If the manifold is even isometrically embedded, it is embedded but also inherits the Riemannian metric by restricting the metric from the embedding to the corresponding tangent space under consideration. But it also inherits the functions defined for the plain embedding, for example checking some conditions for the validity of points and vectors. If it is even a submanifold, also further functions are inherited like the shortest_geodesic.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"We use a variation of Tim Holy's Traits Trick (THTT) which takes into account kind of traits.","category":"page"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"To be precise we have a generic AbstractForwardingType to indicate that on the decorator manifold we want to (or not want to) forward a certain function. To add more semantics one can use subtypes of this type like AbstractEmbeddedForwardingType to indicate how to forward certain functions for the embedding type.","category":"page"},{"location":"decorator/#ManifoldsBase.AbstractDecoratorManifold","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractDecoratorManifold","text":"AbstractDecoratorManifold{ğ”½} <: AbstractManifold{ğ”½}\n\nDeclare a manifold to be an abstract decorator. A manifold which is a subtype of is a decorated manifold, i.e. has\n\ncertain additional properties or\ndelegates certain properties to other manifolds.\n\nMost prominently, a manifold might be an embedded manifold, i.e. points on a manifold mathcal M are represented by (some, maybe not all) points on another manifold mathcal N. Depending on the type of embedding, several functions are dedicated to the embedding. For example if the embedding is isometric, then the inner does not have to be implemented for mathcal M but can be automatically implemented by deligation to mathcal N.\n\nThis is modelled by the AbstractDecoratorManifold and traits. These are mapped to functions, which determine the types of transparencies.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#The-Manifold-decorator","page":"Decorating/Extending a Manifold","title":"The Manifold decorator","text":"","category":"section"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"The idea of the decorator for a manifold is to allow to exchange certain functionality by a dispatch layer. For example that for an embedded manifold some functions are passed to the embedding, or that for a metric manifold decorator, all functions unrelated to the metric are passed to the original manifold. The following types, functions, and macros introduce the decorator trait which allows to decorate an arbitrary <:AbstractDecoratorManifold with further features.","category":"page"},{"location":"decorator/#ManifoldsBase.AbstractEmbeddedForwardingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractEmbeddedForwardingType","text":"AbstractEmbeddedForwardingType\n\nAn abstract type to specify the forwarding behaviour of a function when it should forward to the embedding of a manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.AbstractEmbeddingDirectness","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractEmbeddingDirectness","text":"abstract type AbstractEmbeddingDirectness end\n\nSupertype for DirectEmbedding and IndirectEmbedding that indicate whether embed on a manifold is an identity or not.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.AbstractEmbeddingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractEmbeddingType","text":"AbstractEmbeddingType\n\nWithin all AbstractEmbeddedForwardingTypes this type is used to indicate different kinds of embeddings, for example the default fallback that NotEmbeddedManifoldType a manifold is not embedded, that is is embedded using EmbeddedManifoldType or even specifying further that it is isometrically embedded using IsometricallyEmbeddedManifoldType or as furthermore a submanifold using EmbeddedSubmanifoldType.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.AbstractForwardingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.AbstractForwardingType","text":"AbstractForwardingType\n\nAn abstract type to specify the forwarding behaviour of a function for a decorator manifold or a trait within ManifoldsBase.jl.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.DirectEmbedding","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.DirectEmbedding","text":"struct DirectEmbedding <: AbstractEmbeddingDirectness end\n\nA struct indicating that embed is an identity function on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.EmbeddedForwardingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.EmbeddedForwardingType","text":"EmbeddedForwardingType{TED<:AbstractEmbeddingDirectness} <: AbstractEmbeddedForwardingType\n\nA property of an embedded manifold that indicates that embed and project are available and that a function using this trait type forwards to the embedding. The type parameter TED, a subtype of AbstractEmbeddingDirectness, indicates whether embed on points and tangent vectors needs to be called or is an identity and can be skipped.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.EmbeddedManifoldType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.EmbeddedManifoldType","text":"EmbeddedManifoldType <: AbstractEmbeddingType\n\nA property of an embedded manifold that indicates that embed and project are available.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.EmbeddedSubmanifoldType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.EmbeddedSubmanifoldType","text":"EmbeddedSubmanifoldType <: AbstractEmbeddingType\n\nA property to determine whether an AbstractDecoratorManifold M is an embedded submanifold. It is a special case of the IsometricallyEmbeddedManifoldType property, i.e. it has all properties of this property.\n\nIn this property, additionally to the isometric embedded manifold, all retractions, inverse retractions, and vectors transports, especially exp, log, and parallel_transport_to are passed to the embedding.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.IndirectEmbedding","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IndirectEmbedding","text":"struct IndirectEmbedding <: AbstractEmbeddingDirectness end\n\nA struct indicating that embed is not an identity function on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.IsometricallyEmbeddedManifoldType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.IsometricallyEmbeddedManifoldType","text":"IsometricallyEmbeddedManifold <: AbstractEmbeddingType\n\nA property to determine whether an AbstractDecoratorManifold M is an isometrically embedded manifold.\n\nHere, additionally, metric related functions like inner and norm are passed to the embedding\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.NotEmbeddedManifoldType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.NotEmbeddedManifoldType","text":"NotEmbeddedManifoldType <: AbstractEmbeddingType\n\nA property of an embedded manifold that indicates that embed and project are not available.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.SimpleForwardingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.SimpleForwardingType","text":"SimpleForwardingType <: AbstractForwardingType\n\nA type that indicates forwarding to the wrapped manifold without any changes.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.StopForwardingType","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.StopForwardingType","text":"StopForwardingType <: AbstractForwardingType\n\nA type that indicates that a function should not forward to a certain other manifold, e.g. and embedding. This means that the user is asked to implement this function themselfes.\n\n\n\n\n\n","category":"type"},{"location":"decorator/#ManifoldsBase.decorated_manifold-Tuple{AbstractDecoratorManifold}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::AbstractDecoratorManifold)\n\nFor a manifold M that is decorated with some properties, this function returns the manifold without that manifold, i.e. the manifold that was decorated.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold, Any}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::AbstractDecoratorManifold)\nget_embedding(M::AbstractDecoratorManifold, p)\n\nSpecify the embedding of a manifold that has abstract decorators. the embedding might depend on a point representation, where different point representations are distinguished as subtypes of AbstractManifoldPoint. A unique or default representation might also just be an AbstractArray.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.get_embedding_type-Tuple{AbstractManifold}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.get_embedding_type","text":"get_embedding_type(M::AbstractManifold)\nget_embedding_type(M::AbstractManifold, p)\n\nGet embedding type of AbstractManifold M. The returned value is an object of a subtype of AbstractEmbeddingType, either of:\n\nNotEmbeddedManifoldType (default),\nEmbeddedManifoldType,\nIsometricallyEmbeddedManifoldType,\nEmbeddedSubmanifoldType.\n\nPoint p can be optionally specified if different point types correspond to different embeddings.\n\n\n\n\n\n","category":"method"},{"location":"decorator/#ManifoldsBase.get_forwarding_type-Tuple{AbstractManifold, Any}","page":"Decorating/Extending a Manifold","title":"ManifoldsBase.get_forwarding_type","text":"get_forwarding_type(M::AbstractManifold, f)\nget_forwarding_type(M::AbstractManifold, f, p)\n\nGet the type of forwarding to manifold wrapped by AbstractManifold M, for function f. The returned value is an object of a subtype of AbstractForwardingType.\n\nPoint p can be optionally specified if different point types correspond to different representations of the manifold and hence possibly different embeddings.\n\n\n\n\n\n","category":"method"},{"location":"decorator/","page":"Decorating/Extending a Manifold","title":"Decorating/Extending a Manifold","text":"For an example see the (implicit) embedded manifold.","category":"page"},{"location":"vector_transports/#Vector-transport","page":"Vector transports","title":"Vector transport","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Similar to the exponential and logarithmic map also the parallel transport might be costly to compute, especially when there is no closed form solution known and it has to be approximated with numerical methods. Similar to the retraction and its inverse, the generalisation of the parallel transport can be phrased as follows","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"A vector transport is a way to transport a vector between two tangent spaces. Let pq  mathcal M be given, c the curve along which we want to transport (cf. parallel transport, for example a geodesic or curve given by a retraction. We can specify the geodesic or curve a retraction realises for example by a direction d.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"More precisely using [AMS08], Def. 8.1.1, a vector transport T_pd T_pmathcal M to T_qmathcal M, p mathcal M, Y T_pmathcal M is a smooth mapping associated to a retraction operatornameretr_p(Y) = q such that","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"(associated retraction) mathcal T_pdX  T_qmathcal M if and only if q = operatornameretr_p(d),\n(consistency) mathcal T_p0_pX = X for all XT_pmathcal M,\n(linearity) mathcal T_pd(Î±X+Î²Y) = mathcal Î±T_pdX + mathcal Î²T_pdY for all Î± Î²  ğ”½,","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"hold.","category":"page"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"Currently the following methods for vector transport are defined in ManifoldsBase.jl.","category":"page"},{"location":"vector_transports/#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}","page":"Vector transports","title":"ManifoldsBase.default_vector_transport_method","text":"default_vector_transport_method(M::AbstractManifold)\ndefault_vector_transport_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractVectorTransportMethod that is used when calling vector_transport_to or vector_transport_direction without specifying the vector transport method. By default, this is ParallelTransport.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different vector transport methods.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::AbstractManifold, p, X, d)\nvector_transport_direction(M::AbstractManifold, p, X, d, m::AbstractVectorTransportMethod)\n\nGiven an AbstractManifold mathcal M the vector transport is a generalization of the parallel_transport_direction that identifies vectors from different tangent spaces.\n\nMore precisely using [AMS08], Def. 8.1.1, a vector transport T_pd T_pmathcal M to T_qmathcal M, p mathcal M, Y T_pmathcal M is a smooth mapping associated to a retraction operatornameretr_p(Y) = q such that\n\n(associated retraction) mathcal T_pdX  T_qmathcal M if and only if q = operatornameretr_p(d).\n(consistency) mathcal T_p0_pX = X for all XT_pmathcal M\n(linearity) mathcal T_pd(Î±X+Î²Y) = Î±mathcal T_pdX + Î²mathcal T_pdY\n\nFor the AbstractVectorTransportMethod we might even omit the third point. The AbstractLinearVectorTransportMethods are linear.\n\nInput Parameters\n\nM a manifold\np indicating the tangent space of\nX the tangent vector to be transported\nd indicating a transport direction (and distance through its length)\nm an AbstractVectorTransportMethod, by default default_vector_transport_method, so usually ParallelTransport\n\nUsually this method requires a AbstractRetractionMethod as well. By default this is assumed to be the default_retraction_method or implicitly given (and documented) for a vector transport. To explicitly distinguish different retractions for a vector transport, see VectorTransportDirection.\n\nInstead of spcifying a start direction d one can equivalently also specify a target tanget space T_qmathcal M, see vector_transport_to. By default vector_transport_direction falls back to using vector_transport_to, using the default_retraction_method on M.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction!","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::AbstractManifold, Y, p, X, d)\nvector_transport_direction!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M in the direction indicated by the tangent vector d at p. By default, retract and vector_transport_to! are used with the m and r, which default to default_vector_transport_method(M) and default_retraction_method(M), respectively. The result is saved to Y.\n\nSee vector_transport_direction for more details.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to","page":"Vector transports","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::AbstractManifold, p, X, q)\nvector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)\nvector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M along a curve implicitly given by an AbstractRetractionMethod associated to m. By default m is the default_vector_transport_method(M). To explicitly specify a (different) retraction to the implicitly assumeed retraction, see VectorTransportTo. Note that some vector transport methods might also carry their own retraction they are associated to, like the  DifferentiatedRetractionVectorTransport and some are even independent of the retraction, for example the ProjectionTransport.\n\nThis method is equivalent to using d = operatornameretr^-1_p(q) in vector_transport_direction(M, p, X, q, m, r), where you can find the formal definition. This is the fallback for VectorTransportTo.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to!","page":"Vector transports","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::AbstractManifold, Y, p, X, q)\nvector_transport_to!(M::AbstractManifold, Y, p, X, q, m::AbstractVectorTransportMethod)\n\nTransport a vector X from the tangent space at a point p on the AbstractManifold M to q using the AbstractVectorTransportMethod m and the AbstractRetractionMethod r.\n\nThe result is computed in Y. See vector_transport_to for more details.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#Types-of-vector-transports","page":"Vector transports","title":"Types of vector transports","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"To distinguish different types of vector transport we introduce the AbstractVectorTransportMethod. The following concrete types are available.","category":"page"},{"location":"vector_transports/#ManifoldsBase.AbstractLinearVectorTransportMethod","page":"Vector transports","title":"ManifoldsBase.AbstractLinearVectorTransportMethod","text":"AbstractLinearVectorTransportMethod <: AbstractVectorTransportMethod\n\nAbstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.AbstractVectorTransportMethod","page":"Vector transports","title":"ManifoldsBase.AbstractVectorTransportMethod","text":"AbstractVectorTransportMethod <: AbstractApproximationMethod\n\nAbstract type for methods for transporting vectors. Such vector transports are not necessarily linear.\n\nSee also\n\nAbstractLinearVectorTransportMethod\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.DifferentiatedRetractionVectorTransport","page":"Vector transports","title":"ManifoldsBase.DifferentiatedRetractionVectorTransport","text":"DifferentiatedRetractionVectorTransport{R<:AbstractRetractionMethod} <:\n    AbstractVectorTransportMethod\n\nA type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let mathcal M be a Riemannian manifold, pmathcal M a point, and XY T_pmathcal M denote two tangent vectors at p.\n\nGiven a retraction (cf. AbstractRetractionMethod) operatornameretr, the vector transport of X in direction Y (cf. vector_transport_direction) by differentiation this retraction, is given by\n\nmathcal T^operatornameretr_pYX\n= D_Yoperatornameretr_p(Y)X\n= fracmathrmdmathrmdtoperatornameretr_p(Y+tX)Bigr_t=0\n\nsee [AMS08], Section 8.1.2 for more details.\n\nThis can be phrased similarly as a vector_transport_to by introducing q=operatornameretr_pX and defining\n\nmathcal T^operatornameretr_q gets pX = mathcal T^operatornameretr_pYX\n\nwhich in practice usually requires the inverse_retract to exists in order to compute Y = operatornameretr_p^-1q.\n\nConstructor\n\nDifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.EmbeddedVectorTransport","page":"Vector transports","title":"ManifoldsBase.EmbeddedVectorTransport","text":"EmbeddedVectorTransport{T<:AbstractVectorTransportMethod} <: AbstractVectorTransportMethod\n\nCompute a vector transport by using the vector transport of type T in the embedding and projecting the result.\n\nConstructor\n\nEmbeddedVectorTransport(vt::AbstractVectorTransportMethod)\n\nGenerate the vector transport with vector transport vt to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ParallelTransport","page":"Vector transports","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nCompute the vector transport by parallel transport, see parallel_transport_to\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.PoleLadderTransport","page":"Vector transports","title":"ManifoldsBase.PoleLadderTransport","text":"PoleLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use pole_ladder as vector transport method within vector_transport_to or vector_transport_direction, i.e.\n\nLet X T_pmathcal M be a tangent vector at pmathcal M and qmathcal M the point to transport to. Then x = exp_pX is used to call y =pole_ladder(M, p, x, q) and the resulting vector is obtained by computing Y = -log_qy.\n\nThe PoleLadderTransport posesses two advantages compared to SchildsLadderTransport:\n\nit is cheaper to evaluate, if you want to transport several vectors, since the mid point c then stays unchanged.\nwhile both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds [Pen18]\n\nThe pole ladder was was proposed in [LP13]. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.\n\nConstructor\n\nPoleLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical pole ladder that employs exp and log, i.e. as proposed in[LP13]. For an even cheaper transport the inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ProjectionTransport","page":"Vector transports","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to or vector_transport_direction. See project for details.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.ScaledVectorTransport","page":"Vector transports","title":"ManifoldsBase.ScaledVectorTransport","text":"ScaledVectorTransport{T} <: AbstractVectorTransportMethod\n\nIntroduce a scaled variant of any AbstractVectorTransportMethod T, as introduced in [SI13] for some X T_pmathcal M as\n\n    mathcal T^mathrmS(X) = fraclVert XrVert_plVert mathcal T(X)rVert_qmathcal T(X)\n\nNote that the resulting point q has to be known, i.e. for vector_transport_direction the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the vector_transport_to\n\nConstructor\n\nScaledVectorTransport(m::AbstractVectorTransportMethod)\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.SchildsLadderTransport","page":"Vector transports","title":"ManifoldsBase.SchildsLadderTransport","text":"SchildsLadderTransport <: AbstractVectorTransportMethod\n\nSpecify to use schilds_ladder as vector transport method within vector_transport_to or vector_transport_direction, i.e.\n\nLet X T_pmathcal M be a tangent vector at pmathcal M and qmathcal M the point to transport to. Then\n\nP^mathrmS_qgets p(X) =\n    log_qbigl( operatornameretr_p ( 2operatornameretr_p^-1c ) bigr)\n\nwhere c is the mid point between q and d=exp_pX.\n\nThis method employs the internal function schilds_ladder(M, p, d, q) that avoids leaving the manifold.\n\nThe name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in [EPS72].\n\nConstructor\n\nSchildsLadderTransport(\n    retraction = ExponentialRetraction(),\n    inverse_retraction = LogarithmicInverseRetraction(),\n)\n\nConstruct the classical Schilds ladder that employs exp and log, i.e. as proposed in [EPS72]. For an even cheaper transport these inner operations can be changed to an AbstractRetractionMethod retraction and an AbstractInverseRetractionMethod inverse_retraction, respectively.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportDirection","page":"Vector transports","title":"ManifoldsBase.VectorTransportDirection","text":"VectorTransportDirection{VM<:AbstractVectorTransportMethod,RM<:AbstractRetractionMethod}\n    <: AbstractVectorTransportMethod\n\nSpecify a vector_transport_direction using a AbstractVectorTransportMethod with explicitly using the AbstractRetractionMethod to determine the point in the specified direction where to transsport to. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportTo","page":"Vector transports","title":"ManifoldsBase.VectorTransportTo","text":"VectorTransportTo{VM<:AbstractVectorTransportMethod,RM<:AbstractRetractionMethod}\n    <: AbstractVectorTransportMethod\n\nSpecify a vector_transport_to using a AbstractVectorTransportMethod with explicitly using the AbstractInverseRetractionMethod to determine the direction that transports from  in pto q. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#ManifoldsBase.VectorTransportWithKeywords","page":"Vector transports","title":"ManifoldsBase.VectorTransportWithKeywords","text":"VectorTransportWithKeywords{V<:AbstractVectorTransportMethod, K} <: AbstractVectorTransportMethod\n\nSince vector transports might have keywords, this type is a way to set them as an own type to be used as a specific vector transport. Another reason for this type is that we dispatch on the vector transport first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\nvector_transport the vector transport that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nVectorTransportWithKeywords(m::T; kwargs...) where {T <: AbstractVectorTransportMethod}\n\nSpecify the subtype T <:AbstractVectorTransportMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"vector_transports/#Functions-to-implement-(on-Layer-III)","page":"Vector transports","title":"Functions to implement (on Layer III)","text":"","category":"section"},{"location":"vector_transports/","page":"Vector transports","title":"Vector transports","text":"While you should always add your documentation to the first layer vector transport methods above when implementing new manifolds, the actual implementation happens on the following functions on layer III.","category":"page"},{"location":"vector_transports/#ManifoldsBase.pole_ladder","page":"Vector transports","title":"ManifoldsBase.pole_ladder","text":"pole_ladder(\n    M, p, d, q, c = mid_point(M, p, q);\n    retraction=default_retraction_method(M, typeof(p)),\n    inverse_retraction=default_inverse_retraction_method(M, typeof(p))\n)\n\nCompute an inner step of the pole ladder, that can be used as a vector_transport_to. Let c = gamma_pq(frac12) mid point between p and q, then the pole ladder is given by\n\n    operatornamePl(pdq) = operatornameretr_d (2operatornameretr_d^-1c)\n\nWhere the classical pole ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nWhen you have X=log_pd and Y = -log_q operatornamePl(pdq), you will obtain the PoleLadderTransport. When performing multiple steps, this method avoids the switching to the tangent space. Keep in mind that after n successive steps the tangent vector reads Y_n = (-1)^nlog_q operatornamePl(p_n-1d_n-1p_n).\n\nIt is cheaper to evaluate than schilds_ladder, sinc if you want to form multiple ladder steps between p and q, but with different d, there is just one evaluation of a geodesic each., since the center c can be reused.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.pole_ladder!","page":"Vector transports","title":"ManifoldsBase.pole_ladder!","text":"pole_ladder(\n    M, pl, p, d, q, c = mid_point(M, p, q), X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nCompute the pole_ladder, i.e. the result is saved in pl. X is used for storing intermediate inverse retraction.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.schilds_ladder","page":"Vector transports","title":"ManifoldsBase.schilds_ladder","text":"schilds_ladder(\n    M, p, d, q, c = mid_point(M, q, d);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nPerform an inner step of schilds ladder, which can be used as a vector_transport_to, see SchildsLadderTransport. Let c = gamma_qd(frac12) denote the mid point on the shortest geodesic connecting q and the point d. Then Schild's ladder reads as\n\noperatornameSl(pdq) = operatornameretr_p( 2operatornameretr_p^-1 c)\n\nWhere the classical Schilds ladder employs operatornameretr_d=exp_d and operatornameretr_d^-1=log_d but for an even cheaper transport these can be set to different AbstractRetractionMethod and AbstractInverseRetractionMethod.\n\nIn consistency with pole_ladder you can change the way the mid point is computed using the optional parameter c, but note that here it's the mid point between q and d.\n\nWhen you have X=log_pd and Y = log_q operatornameSl(pdq), you will obtain the PoleLadderTransport. Then the approximation to the transported vector is given by log_qoperatornameSl(pdq).\n\nWhen performing multiple steps, this method avoidsd the switching to the tangent space. Hence after n successive steps the tangent vector reads Y_n = log_q operatornamePl(p_n-1d_n-1p_n).\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.schilds_ladder!","page":"Vector transports","title":"ManifoldsBase.schilds_ladder!","text":"schilds_ladder!(M, sl, p, d, q, c = mid_point(M, q, d),\n    X = allocate_result_type(M, log, d, c);\n    retraction = default_retraction_method(M, typeof(p)),\n    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),\n)\n\nCompute schilds_ladder and return the value in the parameter sl. If the required mid point c was computed before, it can be passed using c, and the allocation of new memory can be avoided providing a tangent vector X for the interims result.\n\n\n\n\n\n","category":"function"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction_diff!","text":"vector_transport_direction_diff!(M::AbstractManifold, Y, p, X, d, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M into the direction d using the differential of the AbstractRetractionMethod m in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_direction_embedded!-Tuple{AbstractManifold, Any, Any, Any, Any, AbstractVectorTransportMethod}","page":"Vector transports","title":"ManifoldsBase.vector_transport_direction_embedded!","text":"vector_transport_direction_embedded!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)\n\nCompute the vector transport of X from T_pmathcal M into the direction d using the AbstractRetractionMethod m in the embedding.\n\nThe default implementataion requires one allocation for the points and tangent vectors in the embedding and the resulting point, but the final projection is performed in place of Y\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Vararg{Any, 5}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_diff!","text":"vector_transport_to_diff(M::AbstractManifold, p, X, q, r)\n\nCompute a vector transport by using a DifferentiatedRetractionVectorTransport r in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_embedded!-Tuple{AbstractManifold, Vararg{Any, 5}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_embedded!","text":"vector_transport_to_embedded!(M::AbstractManifold, Y, p, X, q, m::AbstractRetractionMethod)\n\nCompute the vector transport of X from T_pmathcal M to the point q using the  of the AbstractRetractionMethod m in th embedding.\n\nThe default implementataion requires one allocation for the points and tangent vectors in the embedding and the resulting point, but the final projection is performed in place of Y\n\n\n\n\n\n","category":"method"},{"location":"vector_transports/#ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Vararg{Any, 4}}","page":"Vector transports","title":"ManifoldsBase.vector_transport_to_project!","text":"vector_transport_to_project!(M::AbstractManifold, Y, p, X, q)\n\nCompute a vector transport by projecting Xin T_pmathcal M onto the tangent space T_qmathcal M at q in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#sec-retractions","page":"Retractions","title":"Retractions and inverse Retractions","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The exponential and logarithmic map might be too expensive to evaluate or not be available in a very stable numerical way on certain manifolds mathcal M. Retractions provide a possibly cheap, fast and stable alternative.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"A retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfils (for all pmathcal M) that","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"operatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M to T_pmathcal M is the identity map,","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"i.e. Doperatornameretr_p(0)X=X holds for all X T_pmathcal M,","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"where Doperatornameretr_p denotes the differential of the retraction.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"A retraction operatornameretr_p can be interpreted as a first order approximation to the exponential map exp_p.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The following figure compares the exponential map exp(M, p, X) on the Circle (â„‚) (or Sphere(1) embedded in â„^2 with one possible retraction, the one based on projections. Note especially that operatornamedist(pq)=lVert XrVert_p while this is not the case for the result operatornameretr_p(X) = q.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"(Image: A comparison of the exponential map and a retraction on the Circle.)","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"Similar to the exponential map the retraction might not be globally invertible, but locally it is. So locally one can define the inverse retraction operatornameretr_p^-1colon mathcal M to T_pmathcal M, which can be seen as a first order approximation to the logarithmic map. Within the ManifoldsBase.jl interface the inverse retraction is called inverse_retract.","category":"page"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"The general interface looks as follows.","category":"page"},{"location":"retractions/#ManifoldsBase.default_inverse_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_inverse_retraction_method","text":"default_inverse_retraction_method(M::AbstractManifold)\ndefault_inverse_retraction_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractInverseRetractionMethod that is used when calling inverse_retract without specifying the inverse retraction method. By default, this is the LogarithmicInverseRetraction.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different inverse retraction methods.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.default_retraction_method-Tuple{AbstractManifold}","page":"Retractions","title":"ManifoldsBase.default_retraction_method","text":"default_retraction_method(M::AbstractManifold)\ndefault_retraction_method(M::AbstractManifold, ::Type{T}) where {T}\n\nThe AbstractRetractionMethod that is used when calling retract without specifying the retraction method. By default, this is the ExponentialRetraction.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different retraction methods.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract","page":"Retractions","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::AbstractManifold, p, q)\ninverse_retract(M::AbstractManifold, p, q, method::AbstractInverseRetractionMethod\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). For available inverse retractions on certain manifolds see the documentation on the corresponding manifold.\n\nSee also retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.inverse_retract!","page":"Retractions","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::AbstractManifold, X, p, q[, method::AbstractInverseRetractionMethod])\n\nCompute the inverse retraction, a cheaper, approximate version of the logarithmic map), of points p and q on the AbstractManifold M. Result is saved to X.\n\nInverse retraction method can be specified by the last argument, defaulting to default_inverse_retraction_method(M). See the documentation of respective manifolds for available methods.\n\nSee also retract!.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract","page":"Retractions","title":"ManifoldsBase.retract","text":"retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\nretract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\n\nCompute a retraction, an approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold M. This can be computed in-place of q.\n\nA retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfils\n\noperatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M  T_pmathcal M is the identity map,\n\ni.e. Doperatornameretr_p(0)X=X holds for all X T_pmathcal M,\n\nwhere Doperatornameretr_p denotes the differential of the retraction\n\nThe retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). For further available retractions see the documentation of respective manifolds.\n\nLocally, the retraction is invertible. For the inverse operation, see inverse_retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract!","page":"Retractions","title":"ManifoldsBase.retract!","text":"retract(M::AbstractManifold, p, X, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\nretract!(M::AbstractManifold, q, p, X, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\n\nCompute a retraction, an approximate version of the exponential map, from p into direction X, scaled by t, on the AbstractManifold M. This can be computed in-place of q.\n\nA retraction operatornameretr_p T_pmathcal M  mathcal M is a smooth map that fulfils\n\noperatornameretr_p(0) = p\nDoperatornameretr_p(0) T_pmathcal M  T_pmathcal M is the identity map,\n\ni.e. Doperatornameretr_p(0)X=X holds for all X T_pmathcal M,\n\nwhere Doperatornameretr_p denotes the differential of the retraction\n\nThe retraction is called of second order if for all X the curves c(t) = R_p(tX) have a zero acceleration at t=0, i.e. c(0) = 0.\n\nRetraction method can be specified by the last argument, defaulting to default_retraction_method(M). For further available retractions see the documentation of respective manifolds.\n\nLocally, the retraction is invertible. For the inverse operation, see inverse_retract.\n\n\n\n\n\n","category":"function"},{"location":"retractions/#Types-of-Retractions","page":"Retractions","title":"Types of Retractions","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"To distinguish different types of retractions, the last argument of the retraction as well as its inverse specifies a type. The following ones are available.","category":"page"},{"location":"retractions/#ManifoldsBase.AbstractInverseRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractInverseRetractionMethod","text":"AbstractInverseRetractionMethod <: AbstractApproximationMethod\n\nAbstract type for methods for inverting a retraction (see inverse_retract).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.AbstractRetractionMethod","page":"Retractions","title":"ManifoldsBase.AbstractRetractionMethod","text":"AbstractRetractionMethod <: AbstractApproximationMethod\n\nAbstract type for methods for retracting a tangent vector to a manifold.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ApproximateInverseRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateInverseRetraction","text":"ApproximateInverseRetraction <: AbstractInverseRetractionMethod\n\nAn abstract type for representing approximate inverse retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ApproximateRetraction","page":"Retractions","title":"ManifoldsBase.ApproximateRetraction","text":"ApproximateRetraction <: AbstractRetractionMethod\n\nAn abstract type for representing approximate retraction methods.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.CayleyInverseRetraction","page":"Retractions","title":"ManifoldsBase.CayleyInverseRetraction","text":"CayleyInverseRetraction <: AbstractInverseRetractionMethod\n\nA retraction based on the Cayley transform, which is realized by using the PadeRetraction{1}.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, CayleyInverseRetraction()), to implement an inverse caley retraction, define inverse_retract_cayley!(M, X, p, q) for your manifold M. By default both these functions fall back to calling a PadeInverseRetraction(1).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.CayleyRetraction","page":"Retractions","title":"ManifoldsBase.CayleyRetraction","text":"CayleyRetraction <: AbstractRetractionMethod\n\nA retraction based on the Cayley transform, which is realized by using the PadeRetraction{1}.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, CayleyRetraction()), to implement a caley retraction, define retract_cayley!(M, q, p, X, t) for your manifold M. By default both these functions fall back to calling a PadeRetraction(1).\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.EmbeddedInverseRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedInverseRetraction","text":"EmbeddedInverseRetraction{T<:AbstractInverseRetractionMethod} <: AbstractInverseRetractionMethod\n\nCompute an inverse retraction by using the inverse retraction of type T in the embedding and projecting the result\n\nConstructor\n\nEmbeddedInverseRetraction(r::AbstractInverseRetractionMethod)\n\nGenerate the inverse retraction with inverse retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.EmbeddedRetraction","page":"Retractions","title":"ManifoldsBase.EmbeddedRetraction","text":"EmbeddedRetraction{T<:AbstractRetractionMethod} <: AbstractRetractionMethod\n\nCompute a retraction by using the retraction of type T in the embedding and projecting the result.\n\nConstructor\n\nEmbeddedRetraction(r::AbstractRetractionMethod)\n\nGenerate the retraction with retraction r to use in the embedding.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ExponentialRetraction","page":"Retractions","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction <: AbstractRetractionMethod\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.InverseRetractionWithKeywords","page":"Retractions","title":"ManifoldsBase.InverseRetractionWithKeywords","text":"InverseRetractionWithKeywords{R<:AbstractRetractionMethod,K} <: AbstractInverseRetractionMethod\n\nSince inverse retractions might have keywords, this type is a way to set them as an own type to be used as a specific inverse retraction. Another reason for this type is that we dispatch on the inverse retraction first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\ninverse_retraction the inverse retraction that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nInverseRetractionWithKeywords(m::T; kwargs...) where {T <: AbstractInverseRetractionMethod}\n\nSpecify the subtype T <:AbstractInverseRetractionMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.LogarithmicInverseRetraction","page":"Retractions","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.NLSolveInverseRetraction","page":"Retractions","title":"ManifoldsBase.NLSolveInverseRetraction","text":"NLSolveInverseRetraction{T<:AbstractRetractionMethod,TV,TK} <:\n    ApproximateInverseRetraction\n\nAn inverse retraction method for approximating the inverse of a retraction using NLsolve.\n\nConstructor\n\nNLSolveInverseRetraction(\n    method::AbstractRetractionMethod[, X0];\n    project_tangent=false,\n    project_point=false,\n    nlsolve_kwargs...,\n)\n\nConstructs an approximate inverse retraction for the retraction method with initial guess X0, defaulting to the zero vector. If project_tangent is true, then the tangent vector is projected before the retraction using project. If project_point is true, then the resulting point is projected after the retraction. nlsolve_kwargs are keyword arguments passed to NLsolve.nlsolve.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PadeInverseRetraction","page":"Retractions","title":"ManifoldsBase.PadeInverseRetraction","text":"PadeInverseRetraction{m} <: AbstractInverseRetractionMethod\n\nAn inverse retraction based on the PadÃ© approximation of order m for the retraction.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, PadeInverseRetraction(m)), to implement an inverse PadÃ© retraction, define inverse_retract_pade!(M, X, p, q, m) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PadeRetraction","page":"Retractions","title":"ManifoldsBase.PadeRetraction","text":"PadeRetraction{m} <: AbstractRetractionMethod\n\nA retraction based on the PadÃ© approximation of order m\n\nConstructor\n\nPadeRetraction(m::Int)\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, PadeRetraction(m)), to implement a PadÃ© retraction, define retract_pade!(M, q, p, X, t, m) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PolarInverseRetraction","page":"Retractions","title":"ManifoldsBase.PolarInverseRetraction","text":"PolarInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, PolarInverseRetraction()), to implement an inverse polar retraction, define inverse_retract_polar!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.PolarRetraction","page":"Retractions","title":"ManifoldsBase.PolarRetraction","text":"PolarRetraction <: AbstractRetractionMethod\n\nRetractions that are based on singular value decompositions of the matrix / matrices for point and tangent vectors.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, PolarRetraction()), to implement a polar retraction, define retract_polar!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ProjectionInverseRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionInverseRetraction","text":"ProjectionInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a projection (or its inversion).\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, ProjectionInverseRetraction()), to implement an inverse projection retraction, define inverse_retract_project!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ProjectionRetraction","page":"Retractions","title":"ManifoldsBase.ProjectionRetraction","text":"ProjectionRetraction <: AbstractRetractionMethod\n\nRetractions that are based on projection and usually addition in the embedding.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, ProjectionRetraction()), to implement a projection retraction, define retract_project!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.QRInverseRetraction","page":"Retractions","title":"ManifoldsBase.QRInverseRetraction","text":"QRInverseRetraction <: AbstractInverseRetractionMethod\n\nInverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, QRInverseRetraction()), to implement an inverse QR retraction, define inverse_retract_qr!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.QRRetraction","page":"Retractions","title":"ManifoldsBase.QRRetraction","text":"QRRetraction <: AbstractRetractionMethod\n\nRetractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a AbstractManifold\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, QRRetraction()), to implement a QR retraction, define retract_qr!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.RetractionWithKeywords","page":"Retractions","title":"ManifoldsBase.RetractionWithKeywords","text":"RetractionWithKeywords{R<:AbstractRetractionMethod,K} <: AbstractRetractionMethod\n\nSince retractions might have keywords, this type is a way to set them as an own type to be used as a specific retraction. Another reason for this type is that we dispatch on the retraction first and only the last layer would be implemented with keywords, so this way they can be passed down.\n\nFields\n\nretraction the retraction that is decorated with keywords\nkwargs the keyword arguments\n\nNote that you can nest this type. Then the most outer specification of a keyword is used.\n\nConstructor\n\nRetractionWithKeywords(m::T; kwargs...) where {T <: AbstractRetractionMethod}\n\nSpecify the subtype T <:AbstractRetractionMethod to have keywords kwargs....\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.SasakiRetraction","page":"Retractions","title":"ManifoldsBase.SasakiRetraction","text":"struct SasakiRetraction <: AbstractRetractionMethod end\n\nExponential map on TangentBundle computed via Euler integration as described in [MF12]. The system of equations for gamma  â„ to Tmathcal M such that Î³(1) = exp_pX(X_M X_F) and Î³(0)=(p X) reads\n\ndotÎ³(t) = (dotp(t) dotX(t)) = (R(X(t) dotX(t))dotp(t) 0)\n\nwhere R is the Riemann curvature tensor (see riemann_tensor).\n\nConstructor\n\nSasakiRetraction(L::Int)\n\nIn this constructor L is the number of integration steps.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.SoftmaxInverseRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxInverseRetraction","text":"SoftmaxInverseRetraction <: AbstractInverseRetractionMethod\n\nDescribes an inverse retraction that is based on the softmax function.\n\nnote: Technical Note\nThough you would call e.g. inverse_retract(M, p, q, SoftmaxInverseRetraction()), to implement an inverse softmax retraction, define inverse_retract_softmax!(M, X, p, q) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.SoftmaxRetraction","page":"Retractions","title":"ManifoldsBase.SoftmaxRetraction","text":"SoftmaxRetraction <: AbstractRetractionMethod\n\nDescribes a retraction that is based on the softmax function.\n\nnote: Technical Note\nThough you would call e.g. retract(M, p, X, SoftmaxRetraction()), to implement a softmax retraction, define retract_softmax!(M, q, p, X, t) for your manifold M.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.StabilizedRetraction","page":"Retractions","title":"ManifoldsBase.StabilizedRetraction","text":"StabilizedRetraction <: AbstractRetractionMethod\n\nA retraction wraps another retraction and projects the resulting point onto the manifold for numerical stability.\n\nConstructor\n\nStabilizedRetraction(::AbstractRetractionMethod=ExponentialRetraction())\n\n\n\n\n\n","category":"type"},{"location":"retractions/#ManifoldsBase.ShootingInverseRetraction","page":"Retractions","title":"ManifoldsBase.ShootingInverseRetraction","text":"ShootingInverseRetraction <: ApproximateInverseRetraction\n\nApproximating the inverse of a retraction using the shooting method.\n\nThis implementation of the shooting method works by using another inverse retraction to form the first guess of the vector. This guess is updated by shooting the vector, guessing the vector pointing from the shooting result to the target point, and transporting this vector update back to the initial point on a discretized grid. This process is repeated until the norm of the vector update falls below a specified tolerance or the maximum number of iterations is reached.\n\nFields\n\nretraction::AbstractRetractionMethod: The retraction whose inverse is approximated.\ninitial_inverse_retraction::AbstractInverseRetractionMethod: The inverse retraction used   to form the initial guess of the vector.\nvector_transport::AbstractVectorTransportMethod: The vector transport used to transport   the initial guess of the vector.\nnum_transport_points::Int: The number of discretization points used for vector   transport in the shooting method. 2 is the minimum number of points, including just the   endpoints.\ntolerance::Real: The tolerance for the shooting method.\nmax_iterations::Int: The maximum number of iterations for the shooting method.\n\n\n\n\n\n","category":"type"},{"location":"retractions/#The-functions-on-layer-3","page":"Retractions","title":"The functions on layer 3","text":"","category":"section"},{"location":"retractions/","page":"Retractions","title":"Retractions","text":"While you should always add your documentation to retract or retract! when implementing new manifolds, the actual implementation happens on the following functions on layer III.","category":"page"},{"location":"retractions/#ManifoldsBase.inverse_retract_cayley!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_cayley!","text":"inverse_retract_cayley!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the CayleyInverseRetraction, which by default calls the first order [PadeInverseRetractionÂ§(@ref).\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_embedded!-Tuple{AbstractManifold, Any, Any, Any, AbstractInverseRetractionMethod}","page":"Retractions","title":"ManifoldsBase.inverse_retract_embedded!","text":"inverse_retract_embedded!(M::AbstractManifold, X, p, q, m::AbstractInverseRetractionMethod)\n\nCompute the in-place variant of the EmbeddedInverseRetraction using the AbstractInverseRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_nlsolve!-Tuple{AbstractManifold, Any, Any, Any, NLSolveInverseRetraction}","page":"Retractions","title":"ManifoldsBase.inverse_retract_nlsolve!","text":"inverse_retract_nlsolve!(M::AbstractManifold, X, p, q, m::NLSolveInverseRetraction)\n\nCompute the in-place variant of the NLSolveInverseRetraction m.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_pade!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_pade!","text":"inverse_retract_pade!(M::AbstractManifold, p, q, n)\n\nCompute the in-place variant of the PadeInverseRetraction(n),\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_polar!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_polar!","text":"inverse_retract_polar!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the PolarInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_project!","text":"inverse_retract_project!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the ProjectionInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_qr!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_qr!","text":"inverse_retract_qr!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the QRInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_softmax!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.inverse_retract_softmax!","text":"inverse_retract_softmax!(M::AbstractManifold, X, p, q)\n\nCompute the in-place variant of the SoftmaxInverseRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_cayley!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_cayley!","text":"retract_cayley!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the CayleyRetraction, which by default falls back to calling the first order PadeRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_embedded!-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}","page":"Retractions","title":"ManifoldsBase.retract_embedded!","text":"retract_embedded!(M::AbstractManifold, q, p, X, m::AbstractRetractionMethod)\n\nCompute the in-place variant of the EmbeddedRetraction using the AbstractRetractionMethod m in the embedding (see get_embedding) and projecting the result back.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_embedded_fused!-Tuple{AbstractManifold, Any, Any, Any, Number, AbstractRetractionMethod}","page":"Retractions","title":"ManifoldsBase.retract_embedded_fused!","text":"retract_embedded_fused!(M::AbstractManifold, q, p, X, t::Number, m::AbstractRetractionMethod)\n\nCompute the scaled variant of retract_embedded!.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_fused","page":"Retractions","title":"ManifoldsBase.retract_fused","text":"retract_fused(M::AbstractManifold, p, X, t::Number, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\nretract_fused!(M::AbstractManifold, q, p, X, t::Number, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\n\nA variant of retract that performs retraction on the vector X scaled by t. This can be faster in some cases compared to multiplying X by t, especially when performing this for multiple values of t. This can be computed in-place of q.\n\nBy default, this falls back to calling retract with t*X.\n\nnote: Technical Note\nThis fallback is happening on the in-place variant in Layer 3. Hence implementing this performant variant requires to implement the corresponding third layer fused function, like for example retract_polar_fused!. The â€œnon-fusedâ€ variant always also has to be implemented, but can then be just spefied to fallback to the fused variant. for exampleretract_polar!(M, q, p, X) = retract_polar_fused!(M, q, p, X, one(eltype(p)))\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract_fused!","page":"Retractions","title":"ManifoldsBase.retract_fused!","text":"retract_fused(M::AbstractManifold, p, X, t::Number, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\nretract_fused!(M::AbstractManifold, q, p, X, t::Number, method::AbstractRetractionMethod=default_retraction_method(M, typeof(p)))\n\nA variant of retract that performs retraction on the vector X scaled by t. This can be faster in some cases compared to multiplying X by t, especially when performing this for multiple values of t. This can be computed in-place of q.\n\nBy default, this falls back to calling retract with t*X.\n\nnote: Technical Note\nThis fallback is happening on the in-place variant in Layer 3. Hence implementing this performant variant requires to implement the corresponding third layer fused function, like for example retract_polar_fused!. The â€œnon-fusedâ€ variant always also has to be implemented, but can then be just spefied to fallback to the fused variant. for exampleretract_polar!(M, q, p, X) = retract_polar_fused!(M, q, p, X, one(eltype(p)))\n\n\n\n\n\n","category":"function"},{"location":"retractions/#ManifoldsBase.retract_pade!-Tuple{AbstractManifold, Any, Any, Any, PadeRetraction}","page":"Retractions","title":"ManifoldsBase.retract_pade!","text":"retract_pade!(M::AbstractManifold, q, p, X, m::PadeRetraction)\n\nCompute the in-place variant of the PadeRetraction m.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_polar!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_polar!","text":"retract_polar!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the PolarRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_project!","text":"retract_project!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_project_fused!-Tuple{AbstractManifold, Any, Any, Any, Number}","page":"Retractions","title":"ManifoldsBase.retract_project_fused!","text":"retract_project_fused!(M::AbstractManifold, q, p, X, t::Number)\n\nCompute the in-place variant of the ProjectionRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_qr!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_qr!","text":"retract_qr!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the QRRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_sasaki!-Tuple{AbstractManifold, Any, Any, Any, SasakiRetraction}","page":"Retractions","title":"ManifoldsBase.retract_sasaki!","text":"retract_sasaki!(M::AbstractManifold, q, p, X, m::SasakiRetraction)\n\nCompute the in-place variant of the SasakiRetraction m.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.retract_softmax!-Tuple{AbstractManifold, Any, Any, Any}","page":"Retractions","title":"ManifoldsBase.retract_softmax!","text":"retract_softmax!(M::AbstractManifold, q, p, X)\n\nCompute the in-place variant of the SoftmaxRetraction.\n\n\n\n\n\n","category":"method"},{"location":"retractions/#ManifoldsBase.inverse_retract_shooting!-Tuple{AbstractManifold, Any, Any, Any, ShootingInverseRetraction}","page":"Retractions","title":"ManifoldsBase.inverse_retract_shooting!","text":"inverse_retract_shooting!(M::AbstractManifold, X, p, q, m::ShootingInverseRetraction)\n\nApproximate the inverse of a retraction using the shooting method.\n\n\n\n\n\n","category":"method"},{"location":"design/#Design","page":"Design principles","title":"Main Design Principles","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The interface for a manifold is defined to be as generic as possible, such that applications can be implemented as independently as possible from an actual manifold. This way, algorithms like those from Manopt.jl can be implemented on arbitrary manifolds.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The main design criteria for the interface are:","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Aims to also provide efficient global state-free, both in-place and out-of-place computations whenever possible.\nProvide a high level interface that is easy to use.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Therefore this interface has 3 main features, that we will explain using two (related) concepts, the exponential map that maps a tangent vector X at a point p to a point q or mathematically exp_pT_pmathcal M to mathcal M and its generalization, a retraction operatornameretr_p with the same domain and range.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"You do not need to know their exact definition at this point, just that there is one exponential map on a Riemannian manifold, and several retractions, where one of them is the exponential map (called ExponentialRetraction for completeness). Every retraction has its own subtype of the AbstractRetractionMethod that uniquely defines it.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The following three design patterns aim to fulfil the criteria from above, while also avoiding ambiguities in multiple dispatch using the dispatch on one argument at a time approach.","category":"page"},{"location":"design/#General-order-of-parameters","page":"Design principles","title":"General order of parameters","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Since the central element for functions on a manifold is the manifold itself, it should always be the first parameter, even for in-place functions. Then the classical parameters of a function (for example a point and a tangent vector for the retraction) follow and the final part are parameters to further dispatch on, which usually have their defaults.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Besides this order the functions follow the scheme â€œallocate earlyâ€, i.e. to switch to the mutating variant when reasonable, cf. Mutating and allocating functions. Usually this is done after handling the decorator trait, cf. A Decorator for manifolds, which still acts on the first layer.","category":"page"},{"location":"design/#A-3-Layer-architecture-for-dispatch","page":"Design principles","title":"A 3-Layer architecture for dispatch","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The general architecture consists of three layers","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The high level interface for ease of use â€“ and to dispatch on other manifolds.\nThe intermediate layer to dispatch on different parameters in the last section, e.g. type of retraction or vector transport.\nThe lowest layer for specific manifolds to dispatch on different types of points and tangent vectors. Usually this layer with a specific manifold and no optional parameters.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"These three layers are described in more detail in the following. The main motivation to introduce these layers is, that it reduces method ambiguities. It also provides a good structure where to implement extensions to this interface.","category":"page"},{"location":"design/#design-layer1","page":"Design principles","title":"Layer I: The high level interface and ease of use","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The highest layer for convenience of decorators. A usual scheme is, that a manifold might assume several things implicitly, for example the default implementation of the sphere mathbb S^n using unit vectors in mathbb R^n+1. The embedding can be explicitly used to avoid re-implementations â€“ the inner product can be â€œpassed onâ€ to its embedding.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To do so, we â€œdecorateâ€ the manifold by making it an AbstractDecoratorManifold and activating the right traits see the tutorial How to Implement a Manifold.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The explicit case of the EmbeddedManifold can be used to distinguish different embeddings of a manifold, but also their dispatch (onto the manifold or its embedding, depending on the type of embedding) happens here.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Note that all other parameters of a function should be as least typed as possible for all parameters besides the manifold. With respect to the dispatch on one argument at a time paradigm, this layer dispatches the manifold first. We also stay as abstract as possible, for example on the AbstractManifold level if possible.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"If a function has optional positional arguments, (like retract) their default values might be filled/provided on this layer. This layer ends usually in calling the same functions like retract but prefixed with a _ to enter Layer II.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nUsually only functions from this layer are exported from the interface, since these are the ones one should use for generic implementations. If you implement your own manifold, import the necessary lower layer functions as needed.","category":"page"},{"location":"design/#design-layer2","page":"Design principles","title":"Layer II: An internal dispatch interface for parameters","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This layer is an interims layer to dispatch on the (optional/default) parameters of a function. For example the last parameter of retraction: retract determines the type (variant) to be used. The last function in the previous layer calls _retract, which is an internal function. These parameters are usually the last parameters of a function.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"On this layer, e.g. for _retract only these last parameters should be typed, the manifold should stay at the AbstractManifold level. The layer dispatches on different functions per existing parameter type (and might pass this one further on, if it has fields). Function definitions on this layer should only be extended when introducing new such parameter types, for example when introducing a new type of a retraction.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The functions from this layer should never be called directly, are hence also not exported and carry the _ prefix. They should only be called as the final step in the previous layer.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"If the default parameters are not dispatched per type, using _ might be skipped. The same holds for functions that do not have these parameters.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"When there is no dispatch for different types of the optional parameter (here t), the _ might be skipped. One could hence see the last code line as a definition on Layer I that passes directly to Layer III, since there are not parameter to dispatch on.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To close this section, letâ€˜s look at an example. The high level (or Layer I) definition of the retraction is given by","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"retract!(M::AbstractManifold, q, p, X, m::AbstractRetractionMethod=default_retraction_method(M, typeof(p))) = _retract!(M, q, p, X, m)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Note that the convenience function retract(M, q, p, X, m) first allocates a q before calling this function as well.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This level now dispatches on different retraction types m. It usually passes to specific functions implemented in Layer III, here for example","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"_retract!(M::AbstractManifold, q, p, X, m::Exponentialretraction) = exp(M, q, p, X)\n_retract!(M::AbstractManifold, q, p, X, m::PolarRetraction) = retract_polar(M, q, p, X)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"where the ExponentialRetraction is resolved by again calling a function on Layer I (to fill futher default values if these exist). The PolarRetraction is dispatched to retract_polar!, a function on Layer III.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"For further details and dispatches, see retractions and inverse retractions for an overview.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nThe documentation should be attached to the high level functions, since this again fosters ease of use. If you implement a polar retraction, you should write a method of function retract_polar! but the doc string should be attached to retract(::M, ::P, ::V, ::PolarRetraction) for your types ::M, ::P, ::V of the manifold, points and vectors, respectively.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the (optional) parameters second.","category":"page"},{"location":"design/#design-layer3","page":"Design principles","title":"Layer III: The base layer with focus on implementations","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This lower level aims for the actual implementation of the function avoiding ambiguities. It should have as few as possible optional parameters and as concrete as possible types for these.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"This means","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"the function name should be similar to its high level parent (for example retract! and retract_polar!  above)\nThe manifold type in method signature should always be as narrow as possible.\nThe points/vectors should either be untyped (for the default representation or if there is only one implementation) or provide all type bounds (for second representations or when using AbstractManifoldPoint and AbstractTangentVector, respectively).","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The first step that often happens on this level is memory allocation and calling the in-place function. If faster, it might also implement the function at hand itself.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Usually functions from this layer are not exported, when they have an analogue on the first layer. For example the function retract_polar!(M, q, p, X) is not exported, since when using the interface one would use the PolarRetraction or to be precise call retract!(M, q, p, X, PolarRetraction()). When implementing your own manifold, you have to import functions like these anyway.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"To summarize, with respect to the dispatch on one argument at a time paradigm, this layer dispatches the concrete manifold and point/vector types last.","category":"page"},{"location":"design/#inplace-and-noninplace","page":"Design principles","title":"Mutating and allocating functions","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Every function, where this is applicable, should provide an in-place and an allocating variant. For example for the exponential map exp(M, p, X) returns a new point q where the result is computed in. On the other hand exp!(M, q, p, X) computes the result in place of q, where the design of the implementation should keep in mind that also exp!(M, p, p, X) should correctly overwrite p.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The interface provides a way to determine the allocation type and a result to compute/allocate the resulting memory, such that the default implementation allocating functions, like exp is to allocate the resulting memory and call exp!.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nIt might be useful to provide two distinct implementations, for example when using AD schemes. The default is meant for ease of use (concerning implementation), since then one has to just implement the in-place variants.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Non-mutating functions in ManifoldsBase.jl are typically implemented using in-place variants after a suitable allocation of memory.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"Not that this allocation usually takes place only on Layer III when dispatching on points. Both Layer I and Layer II are usually implemented for both variants in parallel.","category":"page"},{"location":"design/#Allocation-of-new-points-and-vectors","page":"Design principles","title":"Allocation of new points and vectors","text":"","category":"section"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The allocate function behaves like similar for simple representations of points and vectors (for example Array{Float64}). For more complex types, such as nested representations of PowerManifold (see NestedPowerRepresentation), checked types like ValidationMPoint and more it operates differently. While similar only concerns itself with the higher level of nested structures, allocate maps itself through all levels of nesting until a simple array of numbers is reached and then calls similar. The difference can be most easily seen in the following example:","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"julia> x = similar([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n #undef\n #undef\n\njulia> y = allocate([[1.0], [2.0]])\n2-element Array{Array{Float64,1},1}:\n [6.90031725726027e-310]\n [6.9003678131654e-310]\n\njulia> x[1]\nERROR: UndefRefError: access to undefined reference\nStacktrace:\n [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744\n [2] top-level scope at REPL[12]:1\n\njulia> y[1]\n1-element Array{Float64,1}:\n 6.90031725726027e-310","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"The function allocate_result allocates a correct return value. It takes into account the possibility that different arguments may have different numeric number_eltype types thorough the allocate_result_type function. The most prominent example of the usage of this function is the logarithmic function log when used with typed points. Lets assume on a manifold M the have points of type P and corresponding tangent vector types V. then the logarithmic map has the signature","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"log(::M, ::P, ::P)","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"but the return type would be V, whose internal sizes (fields/arrays) will depend on the concrete type of one of the points. This is accomplished by implementing a method allocate_result(::M, ::typeof(log), ::P, ::P) that returns the concrete variable for the result. This way, even with specific types, one just has to implement log! and the one line for the allocation.","category":"page"},{"location":"design/","page":"Design principles","title":"Design principles","text":"note: Note\nThis dispatch from the allocating to the in-place variant happens in Layer I (which changed in ManifoldsBase.jl 0.15), that is, functions like exp or retract allocate their result and call the in-place variant exp! and retract! afterwards, where the ladder passes down to layer III to reach retract_polar!.","category":"page"},{"location":"manifolds/#Manifolds","page":"Manifolds","title":"Manifolds","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"While the interface ManifoldsBase.jl does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds","category":"page"},{"location":"manifolds/#A-default-manifold","page":"Manifolds","title":"A default manifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"DefaultManifold is a simplified version of Euclidean and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using Manifolds.jl the Euclidean is available, the DefaultManifold itself is not exported.","category":"page"},{"location":"manifolds/#ManifoldsBase.DefaultManifold","page":"Manifolds","title":"ManifoldsBase.DefaultManifold","text":"DefaultManifold <: AbstractManifold\n\nThis default manifold illustrates the main features of the interface and provides a skeleton to build one's own manifold. It is a simplified/shortened variant of Euclidean from Manifolds.jl.\n\nThis manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variables.\n\nConstructor\n\nDefaultManifold(n::Int...; field = â„, parameter::Symbol = :field)\n\nArguments:\n\nn: shape of array representing points on the manifold.\nfield: field over which the manifold is defined. Either â„, â„‚ or â„.\nparameter: whether a type parameter should be used to store n. By default size is stored in a field. Value can either be :field or :type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#sec-embedded-manifold","page":"Manifolds","title":"Embedded manifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"The embedded manifold is a manifold mathcal M which is modelled explicitly specifying its embedding mathcal N in which the points and tangent vectors are represented. Most prominently is_point and is_vector of an embedded manifold are implemented to check whether the point is a valid point in the embedding. This can of course still be extended by further tests. ManifoldsBase.jl provides two possibilities of easily introducing this in order to dispatch some functions to the embedding.","category":"page"},{"location":"manifolds/#subsec-implicit-embedded","page":"Manifolds","title":"Implicit case: the decorator Trait","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"For the implicit case, your manifold has to be a subtype of the AbstractDecoratorManifold and specifying the get_embedding_type makes that manifold an embedded manifold. You just have to also define get_embedding so that appropriate functions are passed on to that embedding. Which are passed on also depends on the AbstractForwardingType you specify. This is the implicit case, since the manifold type itself does not carry any information about the embedding, just the trait and the function definition do.","category":"page"},{"location":"manifolds/#subsec-explicit-embedded","page":"Manifolds","title":"Explicit case: the EmbeddedManifold","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"The EmbeddedManifold itself is an AbstractDecoratorManifold so it is a case of the implicit embedding itself, but internally stores both the original manifold and the embedding. They are also parameters of the type. This way, an additional embedding of one manifold in another can be modelled. That is, if the manifold is implemented using the implicit embedding approach from before but can also be implemented using a different embedding, then this method should be chosen, since you can dispatch functions that you want to implement in this embedding then on the type which explicitly has the manifold and its embedding as parameters.","category":"page"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Hence this case should be used for any further embedding after the first or if the default implementation works without an embedding and the alternative needs one.","category":"page"},{"location":"manifolds/#ManifoldsBase.EmbeddedManifold","page":"Manifolds","title":"ManifoldsBase.EmbeddedManifold","text":"EmbeddedManifold{ğ”½, MT <: AbstractManifold, NT <: AbstractManifold} <: AbstractDecoratorManifold{ğ”½}\n\nA type to represent an explicit embedding of a AbstractManifold M of type MT embedded into a manifold N of type NT. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold.\n\nnote: Note\nThis type is not required if a manifold M is to be embedded in one specific manifold N.  One can then just implement embed! and project!. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an AbstractDecoratorManifold. Only for a second â€“maybe considered non-defaultâ€“ embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings N.\n\nFields\n\nmanifold the manifold that is an embedded manifold\nembedding a second manifold, the first one is embedded into\n\nConstructor\n\nEmbeddedManifold(M, N)\n\nGenerate the EmbeddedManifold of the AbstractManifold M into the AbstractManifold N.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.decorated_manifold","text":"decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))\n\nReturn the manifold of M that is decorated with its embedding. For this specific type the internally stored enhanced manifold M.manifold is returned.\n\nSee also base_manifold, where this is used to (potentially) completely undecorate the manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.get_embedding","text":"get_embedding(M::EmbeddedManifold)\n\nReturn the embedding AbstractManifold N of M, if it exists.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.get_embedding_type-Tuple{EmbeddedManifold}","page":"Manifolds","title":"ManifoldsBase.get_embedding_type","text":"get_embedding_type(::EmbeddedManifold)\n\nSpecify the type of embedding. This by default returns EmbeddedManifoldType(). It can be further specified by dispatching in the parameters of the EmbeddedManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#Metrics","page":"Manifolds","title":"Metrics","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"Most metric-related functionality is currently defined in Manifolds.jl but a few basic types are defined here.","category":"page"},{"location":"manifolds/#ManifoldsBase.AbstractMetric","page":"Manifolds","title":"ManifoldsBase.AbstractMetric","text":"AbstractMetric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\nFunctor\n\n(metric::Metric)(M::AbstractManifold)\n(metric::Metric)(M::MetricManifold)\n\nGenerate the MetricManifold that wraps the manifold M with given metric. This works for both a variable containing the metric as well as a subtype T<:AbstractMetric, where a zero parameter constructor T() is availabe. If M is already a metric manifold, the inner manifold with the new metric is returned.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.EuclideanMetric","page":"Manifolds","title":"ManifoldsBase.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\nA general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\nSince the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the EuclideanMetric but where the field type of the manifold is â„‚.\n\nThis metric is the default metric for example for the Euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.RiemannianMetric","page":"Manifolds","title":"ManifoldsBase.RiemannianMetric","text":"RiemannianMetric <: AbstractMetric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for X   T_p mathcal M, the inner product g(X X)  0 whenever X is not the zero vector.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_metric!","text":"change_metric!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)\n\nCompute the change_metric in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_metric-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_metric","text":"change_metric(M::AbstractcManifold, G2::AbstractMetric, p, X)\n\nOn the AbstractManifold M with implicitly given metric g_1 and a second AbstractMetric g_2 this function performs a change of metric in the sense that it returns the tangent vector Z=BX such that the linear map B fulfills\n\ng_2(Y_1Y_2) = g_1(BY_1BY_2) quad textfor all  Y_1 Y_2  T_pmathcal M\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_representer!","text":"change_representer!(M::AbstractcManifold, Y, G2::AbstractMetric, p, X)\n\nCompute the change_metric in place of Y.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.change_representer-Tuple{AbstractManifold, ManifoldsBase.AbstractMetric, Any, Any}","page":"Manifolds","title":"ManifoldsBase.change_representer","text":"change_representer(M::AbstractManifold, G2::AbstractMetric, p, X)\n\nConvert the representer X of a linear function (in other words a cotangent vector at p) in the tangent space at p on the AbstractManifold M given with respect to the AbstractMetric G2 into the representer with respect to the (implicit) metric of M.\n\nIn order to convert X into the representer with respect to the (implicitly given) metric g_1 of M, we have to find the conversion function c T_pmathcal M to T_pmathcal M such that\n\n    g_2(XY) = g_1(c(X)Y)\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#A-manifold-for-validation","page":"Manifolds","title":"A manifold for validation","text":"","category":"section"},{"location":"manifolds/","page":"Manifolds","title":"Manifolds","text":"ValidationManifold is a simple decorator using the AbstractDecoratorManifold that â€œdecoratesâ€ a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling is_point or is_vector whenever applicable.","category":"page"},{"location":"manifolds/#ManifoldsBase.ValidationCotangentVector","page":"Manifolds","title":"ManifoldsBase.ValidationCotangentVector","text":"ValidationCotangentVector = ValidationFibreVector{CotangentSpaceType}\n\nRepresent a cotangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationFibreVector","page":"Manifolds","title":"ManifoldsBase.ValidationFibreVector","text":"ValidationFibreVector{TType<:VectorSpaceType,V,P} <: AbstractFibreVector{TType}\n\nRepresent a tangent vector to a point on an ValidationManifold. The original vector of the manifold is stored internally. The corresponding base point of the fibre can be stored as well.\n\nThe TType indicates the type of fibre, for example TangentSpaceType or CotangentSpaceType.\n\nFields\n\nvalue::V: the internally stored vector on the fibre\npoint::P: the point the vector is associated with\n\nConstructor\n\n    ValidationFibreVector{TType}(value, point=nothing)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationMPoint","page":"Manifolds","title":"ManifoldsBase.ValidationMPoint","text":"ValidationMPoint{P} <: AbstractManifoldPoint\n\nRepresent a point on an ValidationManifold. The point is stored internally.\n\nFields\n\nvalue::P: the internally stored point on a manifold\n\nConstructor\n\n    ValidationMPoint(value)\n\nCreate a point on the manifold with the value value.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationManifold","page":"Manifolds","title":"ManifoldsBase.ValidationManifold","text":"ValidationManifold{ğ”½,M<:AbstractManifold{ğ”½}} <: AbstractDecoratorManifold{ğ”½}\n\nA manifold to add tests to input and output values of functions defined in the interface.\n\nAdditionally the points and tangent vectors can also be encapsulated, cf. ValidationMPoint, ValidationTangentVector, and ValidationCotangentVector. These types can be used to see where some data is assumed to be from, when working on manifolds where both points and tangent vectors are represented as (plain) arrays.\n\nUsing the ignore_contexts keyword allows to specify a single Symbol or a vector of Symbols Of which contexts to ignore.\n\nCurrent contexts are\n\n:All: disable all checks\n:Point: checks for points\n:Vector: checks for vectors\n:Output: checks for output\n:Input: checks for input variables\n\nUsing the ignore_functions keyword (dictionary) allows to disable/ignore certain checks within single functions for this manifold. The key of the dictionary has to be the Function to exclude something in. The value is either a single symbol or a vector of symbols with the same meaning as the ignore_contexts keyword, but limited to this function\n\nExamples\n\nexp => :All disables all checks in the exp function\nexp => :Point excludes point checks in the exp function\nexp => [:Point, :Vector] excludes point and vector checks in the exp function\n\nThis manifold is a decorator for a manifold, i.e. it decorates a AbstractManifold M with types points, vectors, and covectors.\n\nFields\n\nmanifold::M: The manifold to be decorated\nmode::Symbol: The mode to be used for error handling, either :error or :warn\nignore_contexts::AbstractVector{Symbol}: store contexts to be ignored of validation.\nignore_functions::Dict{<:Function,<:Union{Symbol,<:AbstractVector{Symbol}}: store contexts to be ignored with in a function or its mutating variant.\n\nConstructors\n\nValidationManifold(M::AbstractManifold; kwargs...)\n\nGenerate the Validation manifold\n\nValidationManifold(M::AbstractManifold, V::ValidationManifold; kwargs...)\n\nGenerate the Validation manifold for M with the default values of V.\n\nKeyword arguments\n\nerror::Symbol=:error: specify how errors in the validation should be reported. this is passed to is_point and is_vector as the error keyword argument. Available values are :error, :warn, :info, and :none. Every other value is treated as :none.\nstore_base_point::Bool=false: specify whether or not to store the point p a tangent or cotangent vector is associated with. This can be useful for debugging purposes.\nignore_contexts = Vector{Symbol}() a vector to indicate which validation contexts should not be performed.\nignore_functions=Dict{Function,Union{Symbol,Vector{Symbol}}}() a dictionary to disable certain contexts within functions. The key here is the non-mutating function variant (if it exists). The contexts are thre same as in ignore_contexts.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase.ValidationTangentVector","page":"Manifolds","title":"ManifoldsBase.ValidationTangentVector","text":"ValidationTangentVector = ValidationFibreVector{TangentSpaceType}\n\nRepresent a tangent vector to a point on an ValidationManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from ValidationMPoints vectors of other types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/#ManifoldsBase._msg-Tuple{ValidationManifold, Any}","page":"Manifolds","title":"ManifoldsBase._msg","text":"_msg(str; error=:None, within::Union{Nothing,<:Function} = nothing,\ncontext::Union{NTuple{N,Symbol} where N} = NTuple{0,Symbol}())\n\nissue a message str according to the mode mode (as @error, @warn, @info).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase._vMc","page":"Manifolds","title":"ManifoldsBase._vMc","text":"_vMc(M::ValidationManifold, f::Function, context::Symbol)\n_vMc(M::ValidationManifold, f::Function, context::NTuple{N,Symbol}) where {N}\n\nReturn whether a check should be performed within f and the context(s) provided.\n\nThis function returns false and hence indicates not to check, when\n\n(one of the) context(s) is in the ignore list for f within ignore_functions\n(one of the) context(s) is in the ignore_contexts list\n\nOtherwise the test is active.\n\n!!! Note    This function is internal and used very often, co it has a very short name;     _vMc stands for \"ValidationManifold check\".\n\n\n\n\n\n","category":"function"},{"location":"manifolds/#ManifoldsBase.internal_value-Tuple{Any}","page":"Manifolds","title":"ManifoldsBase.internal_value","text":"internal_value(p)\n\nReturn the internal value of an ValidationMPoint, ValidationTangentVector, or ValidationCotangentVector if the value p is encapsulated as such. Return p if it is already an a (plain) value on a manifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.is_point-Tuple{ValidationManifold, Any}","page":"Manifolds","title":"ManifoldsBase.is_point","text":"is_point(M::ValidationManifold, p; kwargs...)\n\nPerform is_point on a ValidationManifold, where two additional keywords can be used\n\nwithin=nothing to specify a function from within which this call was issued\ncontext::NTuple{N,Symbol} where N=() to specify one or more contexts, this call was issued in. The context :Point is added before checking whether the test should be performed\n\nall other keywords are passed on.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/#ManifoldsBase.is_vector","page":"Manifolds","title":"ManifoldsBase.is_vector","text":"is_vector(M::ValidationManifold, p, X, cbp=true; kwargs...)\n\nperform is_vector on a ValidationManifold, where two additional keywords can be used\n\nwithin=nothing to specify a function from within which this call was issued\ncontext::NTuple{N,Symbol} where N=() to specify one or more contexts, this call was issued in. The context :Point is added before checking whether the test should be performed\n\nall other keywords are passed on.\n\n\n\n\n\n","category":"function"},{"location":"bases/#bases","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"","category":"section"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The following functions and types provide support for bases of the tangent space of different manifolds. Moreover, bases of the cotangent space are also supported, though this description focuses on the tangent space. An orthonormal basis of the tangent space T_p mathcal M of (real) dimension n has a real-coefficient basis e_1 e_2  e_n if mathrmRe(g_p(e_i e_j)) = Î´_ij for each ij  1 2  n where g_p is the Riemannian metric at point p. A vector X from the tangent space T_p mathcal M can be expressed in Einstein notation as a sum X = X^i e_i, where (real) coefficients X^i are calculated as X^i = mathrmRe(g_p(X e_i)).","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main types are:","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"DefaultOrthonormalBasis, which is designed to work when no special properties of the tangent space basis are required.  It is designed to make get_coordinates and get_vector fast.\nDiagonalizingOrthonormalBasis, which diagonalizes the curvature tensor and makes the curvature in the selected direction equal to 0.\nProjectedOrthonormalBasis, which projects a basis of the ambient space and orthonormalizes projections to obtain a basis in a generic way.\nCachedBasis, which stores (explicitly or implicitly) a precomputed basis at a certain point.","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"The main functions are:","category":"page"},{"location":"bases/","page":"Bases for tangent spaces","title":"Bases for tangent spaces","text":"get_basis precomputes a basis at a certain point.\nget_coordinates returns coordinates of a tangent vector.\nget_vector returns a vector for the specified coordinates.\nget_vectors returns a vector of basis vectors. Calling it should be avoided for high-dimensional manifolds.","category":"page"},{"location":"bases/#ManifoldsBase.AbstractBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractBasis","text":"AbstractBasis{ğ”½,VST<:VectorSpaceType}\n\nAbstract type that represents a basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.AbstractOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthogonalBasis","text":"AbstractOrthogonalBasis{ğ”½,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.AbstractOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.AbstractOrthonormalBasis","text":"AbstractOrthonormalBasis{ğ”½,VST<:VectorSpaceType}\n\nAbstract type that represents an orthonormal basis of vector space of type VST on a manifold or a subset of it.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.CachedBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.CachedBasis","text":"CachedBasis{ğ”½,V,<:AbstractBasis{ğ”½}} <: AbstractBasis{ğ”½}\n\nA cached version of the given basis with precomputed basis vectors. The basis vectors are stored in data, either explicitly (like in cached variants of ProjectedOrthonormalBasis) or implicitly.\n\nConstructor\n\nCachedBasis(basis::AbstractBasis, data)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.CotangentSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.CotangentSpaceType","text":"struct CotangentSpaceType <: VectorSpaceType end\n\nA type that indicates that a Fiber is a CotangentSpace.\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultBasis","text":"DefaultBasis{ğ”½,VST<:VectorSpaceType}\n\nAn arbitrary basis of vector space of type VST on a manifold. This will usually be the fastest basis available for a manifold.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultOrthogonalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthogonalBasis","text":"DefaultOrthogonalBasis{ğ”½,VST<:VectorSpaceType}\n\nAn arbitrary orthogonal basis of vector space of type VST on a manifold. This will usually be the fastest orthogonal basis available for a manifold.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DefaultOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DefaultOrthonormalBasis","text":"DefaultOrthonormalBasis(ğ”½::AbstractNumbers = â„, vs::VectorSpaceType = TangentSpaceType())\n\nAn arbitrary orthonormal basis of vector space of type VST on a manifold. This will usually be the fastest orthonormal basis available for a manifold.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nSee also\n\nVectorSpaceType\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.DiagonalizingOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.DiagonalizingOrthonormalBasis","text":"DiagonalizingOrthonormalBasis{ğ”½,TV} <: AbstractOrthonormalBasis{ğ”½,TangentSpaceType}\n\nAn orthonormal basis Î as a vector of tangent vectors (of length determined by manifold_dimension) in the tangent space that diagonalizes the curvature tensor R(uv)w and where the direction frame_direction v has curvature 0.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nConstructor\n\nDiagonalizingOrthonormalBasis(frame_direction, ğ”½::AbstractNumbers = â„)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.GramSchmidtOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.GramSchmidtOrthonormalBasis","text":"GramSchmidtOrthonormalBasis{ğ”½} <: AbstractOrthonormalBasis{ğ”½}\n\nAn orthonormal basis obtained from a basis.\n\nConstructor\n\nGramSchmidtOrthonormalBasis(ğ”½::AbstractNumbers = â„)\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.ProjectedOrthonormalBasis","page":"Bases for tangent spaces","title":"ManifoldsBase.ProjectedOrthonormalBasis","text":"ProjectedOrthonormalBasis(method::Symbol, ğ”½::AbstractNumbers = â„)\n\nAn orthonormal basis that comes from orthonormalization of basis vectors of the ambient space projected onto the subspace representing the tangent space at a given point.\n\nThe type parameter ğ”½ denotes the AbstractNumbers that will be used as coefficients in linear combinations of the basis vectors.\n\nAvailable methods:\n\n:gram_schmidt uses a modified Gram-Schmidt orthonormalization.\n:svd uses SVD decomposition to orthogonalize projected vectors. The SVD-based method should be more numerically stable at the cost of an additional assumption (local metric tensor at a point where the basis is calculated has to be diagonal).\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.TangentSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.TangentSpaceType","text":"struct TangentSpaceType <: VectorSpaceType end\n\nA type that indicates that a Fiber is a TangentSpace.\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.VectorSpaceType","page":"Bases for tangent spaces","title":"ManifoldsBase.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space fiber is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector(fiber, p) to construct zero vectors at point p,\nallocate(X) and allocate(X, T) for vector X and type T,\ncopyto!(X, Y) for vectors X and Y,\nnumber_eltype(X) for vector X,\nvector_space_dimension.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat and sharp,\nnorm (by default uses inner),\nproject (for embedded vector spaces),\nrepresentation_size,\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"bases/#ManifoldsBase.allocate_coordinates-Tuple{AbstractManifold, Any, Any, Int64}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocate_coordinates","text":"allocate_coordinates(M::AbstractManifold, p, T, n::Int)\n\nAllocate vector of coordinates of length n of type T of a vector at point p on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.allocation_promotion_function-Tuple{AbstractManifold, Any, Tuple}","page":"Bases for tangent spaces","title":"ManifoldsBase.allocation_promotion_function","text":"allocation_promotion_function(M::AbstractManifold, f, args::Tuple)\n\nDetermine the function that must be used to ensure that the allocated representation is of the right type. This is needed for get_vector when a point on a complex manifold is represented by a real-valued vectors with a real-coefficient basis, so that a complex-valued vector representation is allocated.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.change_basis-Tuple{AbstractManifold, Any, Any, ManifoldsBase.AbstractBasis, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.change_basis","text":"change_basis(M::AbstractManifold, p, c, B_in::AbstractBasis, B_out::AbstractBasis)\n\nGiven a vector with coordinates c at point p from manifold M in basis B_in, compute coordinates of the same vector in basis B_out.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.coordinate_eltype-Tuple{AbstractManifold, Any, ManifoldsBase.ComplexNumbers}","page":"Bases for tangent spaces","title":"ManifoldsBase.coordinate_eltype","text":"coordinate_eltype(M::AbstractManifold, p, ğ”½::AbstractNumbers)\n\nGet the element type for ğ”½-field coordinates of the tangent space at a point p from manifold M. This default assumes that usually complex bases of complex manifolds have real coordinates but it can be overridden by a more specific method.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.default_basis-Tuple{AbstractManifold}","page":"Bases for tangent spaces","title":"ManifoldsBase.default_basis","text":"default_basis(M::AbstractManifold, ::typeof(p); kwargs...)\ndefault_basis(M::AbstractManifold; kwargs...)\n\nProvide a default basis for a manifold's tangent space. This can be specific for different points p on M The global default for both is the DefaultOrthonormalBasis with the same number type as M.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different inverse retraction methods.\n\nKeyword arguments\n\nfield::AbstractNumbers field for the coefficients of the basis\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.default_basis-Union{Tuple{T}, Tuple{AbstractManifold, Type{T}}} where T","page":"Bases for tangent spaces","title":"ManifoldsBase.default_basis","text":"default_basis(M::AbstractManifold, ::typeof(p); kwargs...)\ndefault_basis(M::AbstractManifold; kwargs...)\n\nProvide a default basis for a manifold's tangent space. This can be specific for different points p on M The global default for both is the DefaultOrthonormalBasis with the same number type as M.\n\nThis method can also be specified more precisely with a point type T, for the case that on a M there are two different representations of points, which provide different inverse retraction methods.\n\nKeyword arguments\n\nfield::AbstractNumbers field for the coefficients of the basis\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.dual_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.dual_basis","text":"dual_basis(M::AbstractManifold, p, B::AbstractBasis)\n\nGet the dual basis to B, a basis of a vector space at point p from manifold M.\n\nThe dual to the ith vector v_i from basis B is a vector v^i from the dual space such that v^i(v_j) = Î´^i_j, where Î´^i_j is the Kronecker delta symbol:\n\nÎ´^i_j = begincases\n1  text if  i=j \n0  text otherwise\nendcases\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_basis-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_basis","text":"get_basis(M::AbstractManifold, p, B::AbstractBasis; kwargs...) -> CachedBasis\n\nCompute the basis vectors of the tangent space at a point on manifold M represented by p.\n\nReturned object derives from AbstractBasis and may have a field .vectors that stores tangent vectors or it may store them implicitly, in which case the function get_vectors needs to be used to retrieve the basis vectors.\n\nSee also: get_coordinates, get_vector\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.get_coordinates","page":"Bases for tangent spaces","title":"ManifoldsBase.get_coordinates","text":"get_coordinates(M::AbstractManifold, p, X, B::AbstractBasis=default_basis(M, typeof(p)))\nget_coordinates(M::AbstractManifold, p, X, B::CachedBasis)\n\nCompute a one-dimensional vector of coefficients of the tangent vector X at point denoted by p on manifold M in basis B.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve. If a CachedBasis is provided, their stored vectors are used, otherwise the user has to provide a method to compute the coordinates.\n\nFor the CachedBasis keep in mind that the reconstruction with get_vector requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_vector, get_basis\n\n\n\n\n\n","category":"function"},{"location":"bases/#ManifoldsBase.get_vector","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vector","text":"X = get_vector(M::AbstractManifold, p, c, B::AbstractBasis=default_basis(M, typeof(p)))\n\nConvert a one-dimensional vector of coefficients in a basis B of the tangent space at p on manifold M to a tangent vector X at p.\n\nDepending on the basis, p may not directly represent a point on the manifold. For example if a basis transported along a curve is used, p may be the coordinate along the curve.\n\nFor the CachedBasis keep in mind that the reconstruction from get_coordinates requires either a dual basis or the cached basis to be selfdual, for example orthonormal\n\nSee also: get_coordinates, get_basis, default_basis\n\n\n\n\n\n","category":"function"},{"location":"bases/#ManifoldsBase.get_vectors-Tuple{AbstractManifold, Any, ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.get_vectors","text":"get_vectors(M::AbstractManifold, p, B::AbstractBasis=get_basis(M, p, DefaultOrthonormalBasis()))\n\nGet the basis vectors of basis B of the tangent space at point p. The function may or may not work if passed a basis other than a CachedBasis. A CachedBasis can be obtained by calling get_basis.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.gram_schmidt-Union{Tuple{ğ”½}, Tuple{AbstractManifold{ğ”½}, Any, ManifoldsBase.AbstractBasis{ğ”½}}} where ğ”½","page":"Bases for tangent spaces","title":"ManifoldsBase.gram_schmidt","text":"gram_schmidt(M::AbstractManifold{ğ”½}, p, B::AbstractBasis{ğ”½}) where {ğ”½}\ngram_schmidt(M::AbstractManifold, p, V::AbstractVector)\n\nCompute an ONB in the tangent space at p on the [AbstractManifold](@ref} M from either an AbstractBasis basis Â´BÂ´ or a set of (at most) manifold_dimension(M) many vectors. Note that this method requires the manifold and basis to work on the same AbstractNumbers ğ”½, i.e. with real coefficients.\n\nThe method always returns a basis, i.e. linearly dependent vectors are removed.\n\nKeyword arguments\n\nwarn_linearly_dependent (false) â€“ warn if the basis vectors are not linearly independent\nskip_linearly_dependent (false) â€“ whether to just skip (true) a vector that is linearly dependent to the previous ones or to stop (false, default) at that point\nreturn_incomplete_set (false) â€“ throw an error if the resulting set of vectors is not a basis but contains less vectors\n\nfurther keyword arguments can be passed to set the accuracy of the independence test. Especially atol is raised slightly by default to atol = 5*1e-16.\n\nReturn value\n\nWhen a set of vectors is orthonormalized a set of vectors is returned. When an AbstractBasis is orthonormalized, a CachedBasis is returned.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.hat-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.hat","text":"hat(M::AbstractManifold, p, Xâ±)\n\nGiven a basis e_i on the tangent space at a point p and tangent component vector X^i  â„, compute the equivalent vector representation X=X^i e_i, where Einstein summation notation is used:\n\n  X^i  X^i e_i\n\nFor array manifolds, this converts a vector representation of the tangent vector to an array representation. The vee map is the hat map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.number_of_coordinates-Union{Tuple{ğ”¾}, Tuple{AbstractManifold, ManifoldsBase.AbstractBasis{ğ”¾}}} where ğ”¾","page":"Bases for tangent spaces","title":"ManifoldsBase.number_of_coordinates","text":"number_of_coordinates(M::AbstractManifold, B::AbstractBasis)\nnumber_of_coordinates(M::AbstractManifold, ::ğ”¾)\n\nCompute the number of coordinates in basis of field type ğ”¾ on a manifold M. This also corresponds to the number of vectors represented by B, or stored within B in case of a CachedBasis.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ğ”½}}, Tuple{ğ”½}} where ğ”½","page":"Bases for tangent spaces","title":"ManifoldsBase.number_system","text":"number_system(::AbstractBasis)\n\nThe number system for the vectors of the given basis.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.requires_caching-Tuple{ManifoldsBase.AbstractBasis}","page":"Bases for tangent spaces","title":"ManifoldsBase.requires_caching","text":"requires_caching(B::AbstractBasis)\n\nReturn whether basis B can be used in get_vector and get_coordinates without calling get_basis first.\n\n\n\n\n\n","category":"method"},{"location":"bases/#ManifoldsBase.vee-Tuple{AbstractManifold, Any, Any}","page":"Bases for tangent spaces","title":"ManifoldsBase.vee","text":"vee(M::AbstractManifold, p, X)\n\nGiven a basis e_i on the tangent space at a point p and tangent vector X, compute the vector components X^i  â„, such that X = X^i e_i, where Einstein summation notation is used:\n\nvee  X^i e_i  X^i\n\nFor array manifolds, this converts an array representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n\n\n","category":"method"},{"location":"#ManifoldsBase.jl","page":"Home","title":"ManifoldsBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ManifoldsBase.jl is a lightweight interface for manifolds.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This packages has two main purposes. You can add it as a dependency if you plan to work on manifolds (generically) or if you plan to define own manifolds in a package. For a package that (only) depends on ManifoldsBase.jl, see Manopt.jl, which implements optimization algorithms on manifolds using this interface. These optimisation algorithms can hence be used with any manifold implemented based on ManifoldsBase.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For a library of manifolds implemented using this interface Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your package is using ManifoldsBase? We would like to add that here as well. Either write an issue or add yourself by forking, editing this file and opening a PR.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use ManifoldsBase.jl in your work, please cite the following paper, which covers both the basic interface as well as the performance for Manifolds.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"@article{AxenBaranBergmannRzecki:2023,\n    AUTHOR    = {Axen, Seth D. and Baran, Mateusz and Bergmann, Ronny and Rzecki, Krzysztof},\n    ARTICLENO = {33},\n    DOI       = {10.1145/3618296},\n    JOURNAL   = {ACM Transactions on Mathematical Software},\n    MONTH     = {dec},\n    NUMBER    = {4},\n    TITLE     = {Manifolds.Jl: An Extensible Julia Framework for Data Analysis on Manifolds},\n    VOLUME    = {49},\n    YEAR      = {2023}\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the citation is in BibLaTeX format.","category":"page"},{"location":"projections/#Projections","page":"Projections","title":"Projections","text":"","category":"section"},{"location":"projections/","page":"Projections","title":"Projections","text":"A manifold might be embedded in some space. Often this is implicitly assumed, for example the complex Circle is embedded in the complex plane. Letâ€˜s keep the circle in mind in the following as a simple example. For the general case of explicitly stating an embedding and/or to distinguish several, different embeddings, see Embedded Manifolds below.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"To make this a little more concrete, letâ€˜s assume we have a manifold mathcal M which is embedded in some manifold mathcal N and the image i(mathcal M) of the embedding function i is a closed set (with respect to the topology on mathcal N). Then we can do two kinds of projections.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"To make this concrete in an example for the Circle mathcal M=mathcal C =  p  â„‚Â  p = 1 the embedding can be chosen to be the manifold mathcal N = â„‚ and due to our representation of mathcal C as complex numbers already, we have i(p) = p, that is the identity as the embedding function.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The first projection we can consider is for a given a point pmathcal N in the embedding we can look for the closest point on the manifold mathcal M, i.e.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"  operatorname*argmin_q mathcal M d_mathcal N(i(q)p)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"And this resulting q we call the projection of p onto the manifold mathcal M.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The second projection we can look at is for a given a point pmathcal M and a vector in X T_i(p)mathcal N in the embedding, where we can similarly look for the closest tangent vector Y T_pmathcal M, which we have to embed itself before itself. Embedding a tangent vector is usually the same as using the pushforward mathrmdi_p of the embedding (at p). We obtain","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"  operatorname*argmin_Y T_pmathcal M bigllVert mathrmdi(p)Y - X bigrrVert_i(p)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"And we call the resulting Y the projection of X onto the tangent space T_pmathcal M at p.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Letâ€˜s look at the little more concrete example of the complex circle again. Here, the closest point of p  â„‚ is just the projection onto the circle, or in other words q = fracplvert p rvert, as long as pneq 0. For p=0 the projection is not defined. A tangent space T_pmathcal C in the embedding is the line through the origin that is orthogonal to a point pmathcal C. This can be better visualized by looking at p+T_pmathcal C which is actually the line tangent to p on the unit circle. Note that this shift does not change the resulting projection relative to the origin of the tangent space.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Here the projection can be computed as the classical projection onto the line, i.e.  Y = X - XpX.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"Both projections onto mathcal C and onto T_pmathcal C are illustrated in the following figure.","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"(Image: An example illustrating the two kinds of projections on the Circle.)","category":"page"},{"location":"projections/","page":"Projections","title":"Projections","text":"The functions provided in this interface are the following.","category":"page"},{"location":"projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, Y, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. The result is saved in vector Y. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project! includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is perfomed, too.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project!","text":"project!(M::AbstractManifold, q, p)\n\nProject point p from the ambient space onto the AbstractManifold M. The result is stored in q. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed!\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p, X)\n\nProject ambient space representation of a vector X to a tangent vector at point p on the AbstractManifold M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, project includes changing data representation, if applicable, i.e. if the tangents on M are not represented in the same way as points on the embedding, the representation is changed accordingly. This is the case for example for Lie groups, when tangent vectors are represented in the Lie algebra. after projection the change to the Lie algebra is performed, too.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"projections/#ManifoldsBase.project-Tuple{AbstractManifold, Any}","page":"Projections","title":"ManifoldsBase.project","text":"project(M::AbstractManifold, p)\n\nProject point p from the ambient space of the AbstractManifold M to M. This method is only available for manifolds where implicitly an embedding or ambient space is given. Additionally, the projection includes changing data representation, if applicable, i.e. if the points on M are not represented in the same array data, the data is changed accordingly.\n\nSee also: EmbeddedManifold, embed\n\n\n\n\n\n","category":"method"},{"location":"types/#The-Manifold-interface","page":"An abstract manifold","title":"The Manifold interface","text":"","category":"section"},{"location":"types/#The-AbstractManifold","page":"An abstract manifold","title":"The AbstractManifold","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"The main type is the AbstractManifold. It represents the manifold per se. Throughout the documentation of ManifoldsBase.jl we might use the Euclidean Space and the Sphere (both implemented in Manifolds.jl) as easy examples to illustrate properties and features of this interface on concrete examples.","category":"page"},{"location":"types/#ManifoldsBase.AbstractManifold","page":"An abstract manifold","title":"ManifoldsBase.AbstractManifold","text":"AbstractManifold{ğ”½}\n\nA type to represent a (Riemannian) manifold. The AbstractManifold is a central type of this interface. It allows to distinguish different implementations of functions like the exponential and logarithmic map for different manifolds. Usually, the manifold is the first parameter in any of these functions within ManifoldsBase.jl. Based on these, say â€œelementaryâ€ functions, as the two mentioned above, more general functions are built, for example the shortest_geodesic and the geodesic. These should only be overwritten (reimplemented) if for a certain manifold specific, more efficient implementations are possible, that do not just call the elementary functions.\n\nThe [AbstractManifold] is parametrized by AbstractNumbers to distinguish for example real (â„) and complex (â„‚) manifolds.\n\nFor subtypes the preferred order of parameters is: size and simple value parameters, followed by the AbstractNumbers field, followed by data type parameters, which might depend on the abstract number field type.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"which should store information about the manifold, for example parameters inherent to the manifold.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"In order of parameters for any subtype of AbstractManifold it would be good if the first parameter is the number type that the abstract type has as well, if it is not fixed to a specific one. The second one should be the type of field type for size information. This might be the dimension of the manifold, like for the Sphere or any other number(s) determining the manifolds representation or dimension, like the matrix size for the SymmetricPositiveDefinite manifold.","category":"page"},{"location":"types/#Points-on-a-manifold","page":"An abstract manifold","title":"Points on a manifold","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Points do not necessarily have to be typed. Usually one can just use any type. When a manifold has multiple representations, these should be distinguished by point and vector types.","category":"page"},{"location":"types/#ManifoldsBase.AbstractManifoldPoint","page":"An abstract manifold","title":"ManifoldsBase.AbstractManifoldPoint","text":"AbstractManifoldPoint\n\nType for a point on a manifold. While an AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used either\n\nfor more complicated representations,\nsemantic verification, or\nwhen dispatching on different representations of points on a manifold.\n\nSince semantic verification and different representations usually might still only store a matrix internally, it is possible to use @manifold_element_forwards and @default_manifold_fallbacks to reduce implementation overhead.\n\n\n\n\n\n","category":"type"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Converting points between different representations can be performed using the convert function with either two or three arguments (convert(T, M, p) or convert(T, p)). For some manifolds providing M may be necessary. The first variant falls back to the second variant.","category":"page"},{"location":"types/#Tangent-and-Cotangent-spaces","page":"An abstract manifold","title":"Tangent and Cotangent spaces","text":"","category":"section"},{"location":"types/#ManifoldsBase.AbstractCotangentVector","page":"An abstract manifold","title":"ManifoldsBase.AbstractCotangentVector","text":"AbstractCotangentVector = AbstractFibreVector{CotangentSpaceType}\n\nType for a cotangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.AbstractFibreVector","page":"An abstract manifold","title":"ManifoldsBase.AbstractFibreVector","text":"AbstractFibreVector{TType<:VectorSpaceType}\n\nType for a vector from a vector space (fibre of a vector bundle) of type TType of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\nYou may use macro @manifold_vector_forwards to introduce commonly used method definitions for your subtype of AbstractFibreVector.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.AbstractTangentVector","page":"An abstract manifold","title":"ManifoldsBase.AbstractTangentVector","text":"AbstractTangentVector = AbstractFibreVector{TangentSpaceType}\n\nType for a tangent vector of a manifold. While a AbstractManifold does not necessarily require this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.FVector","page":"An abstract manifold","title":"ManifoldsBase.FVector","text":"FVector(type::VectorSpaceType, data, basis::AbstractBasis)\n\nDecorator indicating that the vector data contains coordinates of a vector from a fiber of a vector bundle of type type. basis is an object describing the basis of that space in which the coordinates are given.\n\nConversion between FVector representation and the default representation of an object (for example a tangent vector) for a manifold should be done using get_coordinates and get_vector.\n\nExamples\n\njulia> using Manifolds\n\njulia> M = Sphere(2)\nSphere(2, â„)\n\njulia> p = [1.0, 0.0, 0.0]\n3-element Vector{Float64}:\n 1.0\n 0.0\n 0.0\n\njulia> X = [0.0, 2.0, -1.0]\n3-element Vector{Float64}:\n  0.0\n  2.0\n -1.0\n\njulia> B = DefaultOrthonormalBasis()\nDefaultOrthonormalBasis(â„)\n\njulia> fX = TFVector(get_coordinates(M, p, X, B), B)\nTFVector([2.0, -1.0], DefaultOrthonormalBasis(â„))\n\njulia> X_back = get_vector(M, p, fX.data, fX.basis)\n3-element Vector{Float64}:\n -0.0\n  2.0\n -1.0\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.vector_space_dimension-Tuple{AbstractManifold, ManifoldsBase.VectorSpaceType}","page":"An abstract manifold","title":"ManifoldsBase.vector_space_dimension","text":"vector_space_dimension(M::AbstractManifold, V::VectorSpaceType)\n\nDimension of the vector space of type V on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"This interface also covers a large variety how to model bases in tangent spaces.","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Converting tangent vectors between different representations can be performed using the convert function with either three or four arguments (convert(T, M, p, X) or convert(T, p, X)). For some manifolds providing M may be necessary. The first variant falls back to the second variant.","category":"page"},{"location":"types/#Macros-for-automatic-forwards-for-simple-points/tangent-vectors","page":"An abstract manifold","title":"Macros for automatic forwards for simple points/tangent vectors","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"When distinguishing different representations of points or tangent vectors on one manifold, it might happen that both a subtype of AbstractManifoldPoint and a subtype of AbstractTangentVector are just encapsulating a value","category":"page"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"This is taken into account by the following macros, that forward several actions just to this field. Most prominently vector operations for the tangent vectors. If there is still a default case, a macro sets this type to be equivalent to calling the manifold functions just with the types field that carries the value.","category":"page"},{"location":"types/#ManifoldsBase.@default_manifold_fallbacks-Tuple{Any, Any, Any, Symbol, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@default_manifold_fallbacks","text":"default_manifold_fallbacks(TM, TP, TV, pfield::Symbol, vfield::Symbol)\n\nIntroduce default fallbacks for all basic functions on manifolds, for manifold of type TM, points of type TP, tangent vectors of type TV, with forwarding to fields pfield and vfield for point and tangent vector functions, respectively.\n\n\n\n\n\n","category":"macro"},{"location":"types/#ManifoldsBase.@manifold_element_forwards-Tuple{Any, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@manifold_element_forwards","text":"manifold_element_forwards(T, field::Symbol)\nmanifold_element_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T (which can be a subtype of Twhere) that represents points or vectors for a manifold. Fallbacks will work by forwarding to the field passed in field`\n\nList of forwarded functions:\n\nallocate,\ncopy,\ncopyto!,\nnumber_eltype (only for values, not the type itself),\nsimilar,\nsize,\n==.\n\n\n\n\n\n","category":"macro"},{"location":"types/#ManifoldsBase.@manifold_vector_forwards-Tuple{Any, Symbol}","page":"An abstract manifold","title":"ManifoldsBase.@manifold_vector_forwards","text":"manifold_vector_forwards(T, field::Symbol)\nmanifold_vector_forwards(T, Twhere, field::Symbol)\n\nIntroduce basic fallbacks for type T that represents vectors from a vector bundle for a manifold. Twhere is put into where clause of each method. Fallbacks work by forwarding to field passed as field.\n\nList of forwarded functions:\n\nbasic arithmetic (*, /, \\, +, -),\nall things from @manifold_element_forwards,\nbroadcasting support.\n\nexample\n\n@eval @manifold_vector_forwards ValidationFibreVector{TType} TType value\n\n\n\n\n\n","category":"macro"},{"location":"types/#number-system","page":"An abstract manifold","title":"Number Systems","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"The AbstractManifold has one parameter to distinguish the number system a manifold is based on.","category":"page"},{"location":"types/#ManifoldsBase.AbstractNumbers","page":"An abstract manifold","title":"ManifoldsBase.AbstractNumbers","text":"AbstractNumbers\n\nAn abstract type to represent the number system on which a manifold is built.\n\nThis provides concrete number types for dispatch. The two most common number types are the fields RealNumbers (â„ for short) and ComplexNumbers (â„‚).\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.ComplexNumbers","page":"An abstract manifold","title":"ManifoldsBase.ComplexNumbers","text":"ComplexNumbers <: AbstractNumbers\nâ„‚ = ComplexNumbers()\n\nThe field of complex numbers.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.QuaternionNumbers","page":"An abstract manifold","title":"ManifoldsBase.QuaternionNumbers","text":"QuaternionNumbers <: AbstractNumbers\nâ„ = QuaternionNumbers()\n\nThe division algebra of quaternions.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.RealNumbers","page":"An abstract manifold","title":"ManifoldsBase.RealNumbers","text":"RealNumbers <: AbstractNumbers\nâ„ = RealNumbers()\n\nThe field of real numbers.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase._unify_number_systems-Tuple{ManifoldsBase.AbstractNumbers, Vararg{ManifoldsBase.AbstractNumbers}}","page":"An abstract manifold","title":"ManifoldsBase._unify_number_systems","text":"_unify_number_systems(ğ”½s::AbstractNumbers...)\n\nCompute a number system that includes all given number systems (as sub-systems) and is closed under addition and multiplication.\n\n\n\n\n\n","category":"method"},{"location":"types/#ManifoldsBase.number_system-Union{Tuple{AbstractManifold{ğ”½}}, Tuple{ğ”½}} where ğ”½","page":"An abstract manifold","title":"ManifoldsBase.number_system","text":"number_system(M::AbstractManifold{ğ”½})\n\nReturn the number system the manifold M is based on, i.e. the parameter ğ”½.\n\n\n\n\n\n","category":"method"},{"location":"types/#ManifoldsBase.real_dimension-Tuple{ManifoldsBase.AbstractNumbers}","page":"An abstract manifold","title":"ManifoldsBase.real_dimension","text":"real_dimension(ğ”½::AbstractNumbers)\n\nReturn the real dimension dim_â„ ğ”½ of the AbstractNumbers system ğ”½. The real dimension is the dimension of a real vector space with which a number in ğ”½ can be identified. For example, ComplexNumbers have a real dimension of 2, and QuaternionNumbers have a real dimension of 4.\n\n\n\n\n\n","category":"method"},{"location":"types/#type-parameter","page":"An abstract manifold","title":"Type Parameter","text":"","category":"section"},{"location":"types/","page":"An abstract manifold","title":"An abstract manifold","text":"Concrete AbstractManifolds usually correspond to families of manifolds that are parameterized by some numbers, for example determining their manifold_dimension. Those numbers can either be stored in a field or as a type parameter of the structure. The TypeParameter offers the flexibility to have this parameter either as type parameter or a field.","category":"page"},{"location":"types/#ManifoldsBase.TypeParameter","page":"An abstract manifold","title":"ManifoldsBase.TypeParameter","text":"TypeParameter{T}\n\nRepresents numeric parameters of a manifold type as type parameters, allowing for static specialization of methods.\n\n\n\n\n\n","category":"type"},{"location":"types/#ManifoldsBase.wrap_type_parameter","page":"An abstract manifold","title":"ManifoldsBase.wrap_type_parameter","text":"wrap_type_parameter(parameter::Symbol, data)\n\nWrap data in TypeParameter if parameter is :type or return data unchanged if parameter is :field. Intended for use in manifold constructors, see DefaultManifold for an example.\n\n\n\n\n\n","category":"function"}]
}
