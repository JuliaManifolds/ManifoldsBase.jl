<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to define a manifold ¬∑ ManifoldsBase.jl</title><meta name="title" content="How to define a manifold ¬∑ ManifoldsBase.jl"/><meta property="og:title" content="How to define a manifold ¬∑ ManifoldsBase.jl"/><meta property="twitter:title" content="How to define a manifold ¬∑ ManifoldsBase.jl"/><meta name="description" content="Documentation for ManifoldsBase.jl."/><meta property="og:description" content="Documentation for ManifoldsBase.jl."/><meta property="twitter:description" content="Documentation for ManifoldsBase.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">ManifoldsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li class="is-active"><a class="tocitem" href>How to define a manifold</a><ul class="internal"><li><a class="tocitem" href="#Preliminaries"><span>Preliminaries</span></a></li><li><a class="tocitem" href="#Defining-a-manifold"><span>Defining a manifold</span></a></li><li><a class="tocitem" href="#Functions-I:-Manifold-properties"><span>Functions I: Manifold properties</span></a></li><li><a class="tocitem" href="#Functions-II:-Verifying-Points-and-tangent-vectors"><span>Functions II: Verifying Points and tangent vectors</span></a></li><li><a class="tocitem" href="#Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction."><span>Functions on Manifolds III: The exponential map and a retraction.</span></a></li><li><a class="tocitem" href="#Technical-Details"><span>Technical Details</span></a></li></ul></li><li><a class="tocitem" href="../../design/">Design principles</a></li><li><a class="tocitem" href="../../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="../../functions/">Basic functions</a></li><li><a class="tocitem" href="../../projections/">Projections</a></li><li><a class="tocitem" href="../../retractions/">Retractions</a></li><li><a class="tocitem" href="../../vector_transports/">Vector transports</a></li></ul></li><li><a class="tocitem" href="../../manifolds/">Manifolds</a></li><li><a class="tocitem" href="../../metamanifolds/">Meta-Manifolds</a></li><li><a class="tocitem" href="../../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../../bases/">Bases for tangent spaces</a></li><li><a class="tocitem" href="../../numerical_verification/">Numerical Verification</a></li><li><a class="tocitem" href="../../NEWS/">Changelog</a></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>How to define a manifold</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to define a manifold</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/tutorials/implement-a-manifold.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="How-to-Implement-a-Manifold"><a class="docs-heading-anchor" href="#How-to-Implement-a-Manifold">How to Implement a Manifold</a><a id="How-to-Implement-a-Manifold-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Implement-a-Manifold" title="Permalink"></a></h1><p>This tutorial illustrates, how to implement your very first manifold. We start from the very beginning and cover the basic ideas of the interface provided by <code>ManifoldsBase.jl</code> interface.</p><h2 id="Preliminaries"><a class="docs-heading-anchor" href="#Preliminaries">Preliminaries</a><a id="Preliminaries-1"></a><a class="docs-heading-anchor-permalink" href="#Preliminaries" title="Permalink"></a></h2><p>We will use a simple example in this tutorial, since the main focus here is to illustrate how to define a manifold. We will use the sphere of radius <span>$r$</span> embedded in <span>$\mathbb R^{d+1}$</span>, i.e.¬†all vectors of length <span>$r$</span>. Formally we define</p><p class="math-container">\[\mathbb S_r^d :=
\bigl\{
    p \in \mathbb R^{d+1}
    \big|
    \lVert p \rVert = r
\bigr\}\]</p><p>When defining a Riemannian manifold mathematically, there is several things to keep in mind, for example the metric imposed on the tangent spaces. For this interface we assume these things to be given implicitly for a first implementation, but they can be made more precise when necessary.</p><p>The only thing we have to be aware of for now is the <a href="../../bases/#ManifoldsBase.number_system-Union{Tuple{ManifoldsBase.AbstractBasis{ùîΩ}}, Tuple{ùîΩ}} where ùîΩ"><code>number_system</code></a>, i.e.¬†whether our manifold is a real-valued or a complex-valued manifold. The abstract type all manifolds inherit from, the <a href="../../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>{ùîΩ}</code> has this number system as a parameter. The usual parameter we will use are the <a href="../../types/#ManifoldsBase.RealNumbers"><code>RealNumbers</code></a><code>()</code>, which have a short hand in <code>ManifoldsBase.jl</code>, namely <code>‚Ñù</code>. The second one are the <a href="../../types/#ManifoldsBase.ComplexNumbers"><code>ComplexNumbers</code></a><code>()</code>, or <code>‚ÑÇ</code> for short.</p><pre><code class="language-julia hljs">using LinearAlgebra, ManifoldsBase
using ManifoldsBase: ‚Ñù</code></pre><h2 id="Defining-a-manifold"><a class="docs-heading-anchor" href="#Defining-a-manifold">Defining a manifold</a><a id="Defining-a-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#Defining-a-manifold" title="Permalink"></a></h2><p>A manifold itself is a <code>struct</code> that is a subtype of <code>AbstractManifold</code> and should contain. We usually recommend to also document your new manifold.</p><p>Since the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/sphere.html"><code>Sphere</code></a> is already a name used within <a href="https://github.com/JuliaManifolds/Manifolds.jl/"><code>Manifolds.jl</code></a>, let‚Äôs use a slightly more specific name. We define</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    ScaledSphere &lt;: AbstractManifold{‚Ñù}

Define a sphere of fixed radius

# Fields

* `dimension` dimension of the sphere
* `radius` the radius of the sphere

# Constructor

    ScaledSphere(dimension,radius=1.0)

Initialize the manifold to a certain `dimension` and `radius`,
which by default is set to `1.0`
&quot;&quot;&quot;
struct ScaledSphere &lt;: AbstractManifold{‚Ñù}
    dimension::Int
    radius::Float64
end</code></pre><p>And we can directly use this manifold and set</p><pre><code class="language-julia hljs">M = ScaledSphere(2,1.5)</code></pre><pre><code class="nohighlight hljs">ScaledSphere(2, 1.5)</code></pre><h2 id="Functions-I:-Manifold-properties"><a class="docs-heading-anchor" href="#Functions-I:-Manifold-properties">Functions I: Manifold properties</a><a id="Functions-I:-Manifold-properties-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-I:-Manifold-properties" title="Permalink"></a></h2><p>While the interface provides a lot of possible functions to define for your manifold, you only need to define those that are necessary for your implementation. If you are using other packages depending on <code>ManifoldsBase.jl</code> you will often just get a ‚ÄúMethod not defined‚Äù and sometimes an ambiguity error indicating that a function is missing that is required for a certain task.</p><p>We can first start with a technical function which internally is often used. Any of our points or tangent vectors are represented as a <span>$(d+1)$</span>-dimensional vector. This is internally often used when allocating memory, see <a href="../../functions/#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a>. It returns a tuple representing the size of arrays for valid points. We define</p><pre><code class="language-julia hljs">import ManifoldsBase: representation_size
representation_size(M::ScaledSphere) = (M.dimension+1,)</code></pre><p>Similarly, we can implement the function returning the dimension of the manifold, cf.¬†<a href="../../functions/#ManifoldsBase.manifold_dimension-Tuple{AbstractManifold}"><code>manifold_dimension</code></a> as</p><pre><code class="language-julia hljs">import ManifoldsBase: manifold_dimension
manifold_dimension(M::ScaledSphere) = M.dimension</code></pre><p>and we can now easily use them to access the dimension of the manifold</p><pre><code class="language-julia hljs">manifold_dimension(M)</code></pre><pre><code class="nohighlight hljs">2</code></pre><h2 id="Functions-II:-Verifying-Points-and-tangent-vectors"><a class="docs-heading-anchor" href="#Functions-II:-Verifying-Points-and-tangent-vectors">Functions II: Verifying Points and tangent vectors</a><a id="Functions-II:-Verifying-Points-and-tangent-vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-II:-Verifying-Points-and-tangent-vectors" title="Permalink"></a></h2><p>The first two functions we want to define are those to check points and tangent vectors for our manifold. Let‚Äôs first clarify what the tangent space looks like. The directions ‚Äúwe can walk into‚Äù from a point <span>$p\in \mathbb S_r^d$</span> are all <span>$X$</span> that are orthogonal to <span>$p$</span>, which is the plane/vector space tangent to the sphere. Formally</p><p class="math-container">\[T_p\mathbb S_r^d :=
\bigl\{
    X \in \mathbb R^{d+1}
    \big|
    \langle p, X \rangle = 0
\bigr\}, \qquad p \in \mathbb S_r^d\]</p><p>to verify either <code>p</code> or <code>X</code> one uses <a href="../../functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a><code>(M,p)</code> and <a href="../../functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>is_vector</code></a><code>(M, p, X)</code> respectively. Since both involve some automatic options and possibilities, for example whether to throw an error or just return false, both mention that the actual functions to implement are <a href="../../functions/#ManifoldsBase.check_point-Tuple{AbstractManifold, Any}"><code>check_point</code></a> and <a href="../../functions/#ManifoldsBase.check_vector-Tuple{AbstractManifold, Any, Any}"><code>check_vector</code></a>, which both do not throw but <em>return</em> an error if something is wrong.</p><p>In principle we would have to check two properties, namely that the size of <code>p</code> is of correct size <code>M.dimension+1</code> and that its norm is <code>M.radius</code>. Luckily, by defining <a href="../../functions/#ManifoldsBase.representation_size-Tuple{AbstractManifold}"><code>representation_size</code></a> the first check is automatically done already ‚Äì¬†actually for both points and vectors. We define</p><pre><code class="language-julia hljs">import ManifoldsBase: check_point
function check_point(M::ScaledSphere, p; kwargs...)
    if !isapprox(norm(p), M.radius; kwargs...)
        return DomainError(norm(p), &quot;The norm of $p is not $(M.radius).&quot;)
    end
    return nothing
end</code></pre><p>And we can directly test the function. To see all 3 failing ones, we switch from errors to warnings in the check</p><pre><code class="language-julia hljs">is_point(M, [1.5, 0.0], error=:warn) # wrong size
is_point(M, [1.0, 0.0, 0.0], error=:warn) # wrong norm
is_point(M, [1.5, 0.0, 0.0], error=:warn) # on the manifold, returns true</code></pre><pre><code class="nohighlight hljs">‚îå Warning: DomainError with (2,):
‚îÇ The point [1.5, 0.0] can not belong to the manifold Main.Notebook.ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifolds representation size ((3,)).
‚îî @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:823
‚îå Warning: DomainError with 1.0:
‚îÇ The norm of [1.0, 0.0, 0.0] is not 1.5.
‚îî @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:836

true</code></pre><p>similarly for vectors, we just have to implement the orthogonality check.</p><pre><code class="language-julia hljs">import ManifoldsBase: check_vector
function check_vector(M::ScaledSphere, p, X; kwargs...)
    if !isapprox(dot(p,X), 0.0; kwargs...)
        return DomainError(
            dot(p,X),
            &quot;The tangent vector $X is not orthogonal to $p.&quot;
        )
    end
    return nothing
end</code></pre><p>and again, the high level interface can be used to display warnings for vectors not fulfilling the criterion, but we can also activate a check for the point using the last positional argument</p><pre><code class="language-julia hljs">is_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0]; error=:warn) # wrong size
is_vector(M, [1.5, 0.0, 0.0], [1.0, 1.0, 0.0]; error=:warn) # not orthogonal norm
is_vector(M, [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], true; error=:warn) # point not valid
is_vector(M, [1.5, 0.0, 0.0], [0.0, 1.0, 0.0], true; error=:warn) # returns true</code></pre><pre><code class="nohighlight hljs">‚îå Warning: DomainError with (2,):
‚îÇ The tangent vector [0.0, 1.0] can not belong to the manifold Main.Notebook.ScaledSphere(2, 1.5), since its size (2,) is not equal to the manifodls representation size ((3,)).
‚îî @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:894
‚îå Warning: DomainError with 1.5:
‚îÇ The tangent vector [1.0, 1.0, 0.0] is not orthogonal to [1.5, 0.0, 0.0].
‚îî @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:907
‚îå Warning: DomainError with 1.0:
‚îÇ The norm of [1.0, 0.0, 0.0] is not 1.5.
‚îî @ ManifoldsBase ~/work/ManifoldsBase.jl/ManifoldsBase.jl/src/ManifoldsBase.jl:836

true</code></pre><h2 id="Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction."><a class="docs-heading-anchor" href="#Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction.">Functions on Manifolds III: The exponential map and a retraction.</a><a id="Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction.-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-on-Manifolds-III:-The-exponential-map-and-a-retraction." title="Permalink"></a></h2><p>For the final group of functions, we want to implement the <a href="../../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>onential map and a <a href="../../metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a>ion. Both are ways to ‚Äúmove around‚Äù on the manifold, that is, given a point <span>$p$</span> and a tangent vector indicating a ‚Äúwalking direction‚Äù, the two functions we define will return a new point <span>$q$</span> on the manifold.</p><p>For functions that compute a new point or tangent vector, <code>ManifoldsBase.jl</code> always provides two variants: One that allocates new memory, and one that allows to provide the memory the result should be returned in¬†to spare memory allocations.</p><p>Let‚Äôs first take a look at what the exponential map is defined like. We follow the shortest curves, that is great arcs, on the sphere. Formally we have</p><p class="math-container">\[\exp_p X =
\cos\Bigl(\frac{1}{r}\lVert X \rVert\Bigr)p +
\sin\Bigl(\frac{1}{r}\lVert X \rVert\Bigr)\frac{X}{\lVert X \rVert}.\]</p><p>In fact, from the two functions above, <a href="../../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a><code>(M, p, X)</code>, and <a href="../../functions/#ManifoldsBase.exp!-Tuple{AbstractManifold, Any, Any, Any}"><code>exp!</code></a><code>(M, q, p, X)</code> that works in place of <code>q</code>, we only have to implement the second. The first one, <code>exp</code> by default falls back to allocating memory and calling the second. So <code>exp</code> should only be defined, if there is a special reason for. Furthermore, we usually do not verify/check inputs to spare time. If a user feels insecure, they could for example use the <a href="../../manifolds/#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> wrapper which adds explicit checks of inputs and outputs.</p><p>We define</p><pre><code class="language-julia hljs">import ManifoldsBase: exp!
function exp!(M::ScaledSphere, q, p, X)
    nX = norm(X)
    if nX == 0
        q .= p
    else
        q .= cos(nX/M.radius)*p + M.radius*sin(nX/M.radius) .* (1/nX) .* X
    end
    return q
end</code></pre><p>and we can directly test our function starting in the north pole and ‚Äúwalking down‚Äù to the equator</p><pre><code class="language-julia hljs">q = exp(M, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0])</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 1.5
 0.0
 9.184850993605148e-17</code></pre><p>but we also get the other variants for free, for example</p><pre><code class="language-julia hljs">q2 = zero(q)
exp!(M, q2, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0])
q2</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 1.5
 0.0
 9.184850993605148e-17</code></pre><p>or the one that shortens or elongates the path by a factor, for example, if we walk twice the distance, we reach the opposite point</p><pre><code class="language-julia hljs">ManifoldsBase.exp_fused!(M, q2, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0], 2.0)
q2</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
  1.8369701987210297e-16
  0.0
 -1.5</code></pre><p>Of course we can easily check that both points we computed still lie on the sphere</p><pre><code class="language-julia hljs">all([is_point(M, q), is_point(M, q2)])</code></pre><pre><code class="nohighlight hljs">true</code></pre><p>Since the exponential map might in general be expensive, we can do a similar implementation with the <a href="../../retractions/#ManifoldsBase.ProjectionRetraction"><code>ProjectionRetraction</code></a>. Here, we really have to take into account, that the interface is <a href="../../design/#Design">designed with 3 levels</a> in mind: While the actual function we would call in the end is <code>retract(M, p, X, ProjectionRetraction())</code> (or its <code>!</code> variant), we actually have to implement <code>retract_project!(M, q, p, X, t)</code> for technical details, that are a bit beyond this introductory tutorial. In short this split avoids ambiguity errors for decorators of the manifolds. We define</p><pre><code class="language-julia hljs">function ManifoldsBase.retract_project!(M::ScaledSphere, q, p, X)
    q .= (p + X) .* (M.radius/norm(p + X))
    return q
end</code></pre><p>And to test also this function, and avoiding allocations at the same time, we call</p><pre><code class="language-julia hljs">retract!(M, q, [0.0, 0.0, 1.5], [0.75œÄ, 0.0, 0.0], ProjectionRetraction())</code></pre><pre><code class="nohighlight hljs">3-element Vector{Float64}:
 1.2653454121031529
 0.0
 0.8055439082194726</code></pre><p>Finally, there is <a href="../../metamanifolds/#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a> to specify which is the default retraction to use. By default this is</p><pre><code class="language-julia hljs">default_retraction_method(M)</code></pre><pre><code class="nohighlight hljs">ExponentialRetraction()</code></pre><p>But we can easily specify this for our manifold as well, for example defining</p><pre><code class="language-julia hljs">import ManifoldsBase: default_retraction_method
default_retraction_method(::ScaledSphere) = ProjectionRetraction()</code></pre><pre><code class="nohighlight hljs">default_retraction_method (generic function with 6 methods)</code></pre><p>Then</p><pre><code class="language-julia hljs">default_retraction_method(M)</code></pre><pre><code class="nohighlight hljs">ProjectionRetraction()</code></pre><p>and retract without a method specified would always fall back to using the projection retraction instead of the exponential map. Note that for compatibility there is the <a href="../../retractions/#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> called <a href="../../retractions/#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a> which makes <a href="../../metamanifolds/#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> fall back to calling <a href="../../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a>.</p><h2 id="Technical-Details"><a class="docs-heading-anchor" href="#Technical-Details">Technical Details</a><a id="Technical-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Technical-Details" title="Permalink"></a></h2><p>This notebook was rendered with the following environment</p><pre><code class="language-julia hljs">Pkg.status()</code></pre><pre><code class="nohighlight hljs">Status `~/work/ManifoldsBase.jl/ManifoldsBase.jl/tutorials/Project.toml`
  [3362f125] ManifoldsBase v2.0.1 `~/work/ManifoldsBase.jl/ManifoldsBase.jl`
  [91a5bcdd] Plots v1.41.1</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">¬´ Home</a><a class="docs-footer-nextpage" href="../../design/">Design principles ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 17 October 2025 14:31">Friday 17 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
