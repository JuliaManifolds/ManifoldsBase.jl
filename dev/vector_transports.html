<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vector transports ¬∑ ManifoldsBase.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ManifoldsBase.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="example.html">How to define a manifold</a></li><li><a class="tocitem" href="design.html">Design principles</a></li><li><a class="tocitem" href="types.html">An abstract manifold</a></li><li><span class="tocitem">Functions on maniolds</span><ul><li><a class="tocitem" href="functions.html">Basic functions</a></li><li><a class="tocitem" href="projections.html">Projections</a></li><li><a class="tocitem" href="retractions.html">Retractions</a></li><li class="is-active"><a class="tocitem" href="vector_transports.html">Vector transports</a><ul class="internal"><li><a class="tocitem" href="#Vector-transport"><span>Vector transport</span></a></li><li><a class="tocitem" href="#Types-of-vector-transports"><span>Types of vector transports</span></a></li><li><a class="tocitem" href="#Functions-to-implement-(on-Layer-III)"><span>Functions to implement (on Layer III)</span></a></li></ul></li></ul></li><li><a class="tocitem" href="manifolds.html">Manifolds</a></li><li><a class="tocitem" href="decorator.html">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="bases.html">Bases for tangent spaces</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions on maniolds</a></li><li class="is-active"><a href="vector_transports.html">Vector transports</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="vector_transports.html">Vector transports</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/vector_transports.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Vector-transport"><a class="docs-heading-anchor" href="#Vector-transport">Vector transport</a><a id="Vector-transport-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-transport" title="Permalink"></a></h2><p>Similar to the <a href="functions.html#exp-and-log">exponential and logarithmic map</a> also the <a href="functions.html#subsec-parallel-transport">parallel transport</a> might be costly to compute, especially when there is no closed form solution known and it has to be approximated with numerical methods. Similar to the <a href="retractions.html#sec-retractions">retraction and its inverse</a>, the generalisation of the parallel transport can be phrased as follows</p><p>A <em>vector transport</em> is a way to transport a vector between two tangent spaces. Let <span>$p,q ‚àà \mathcal M$</span> be given, <span>$c$</span> the curve along which we want to transport (cf. <a href="functions.html#subsec-parallel-transport">parallel transport</a>, for example a geodesic or curve given by a retraction. We can specify the geodesic or curve a retraction realises for example by a direction <span>$d$</span>.</p><p>More precisely using <sup class="footnote-reference"><a id="citeref-AbsilMahonySepulchre2008" href="#footnote-AbsilMahonySepulchre2008">[AbsilMahonySepulchre2008]</a></sup>, Def. 8.1.1, a vector transport <span>$T_{p,d}: T_p\mathcal M \to T_q\mathcal M$</span>, <span>$p‚àà \mathcal M$</span>, <span>$Y‚àà T_p\mathcal M$</span> is a smooth mapping associated to a retraction <span>$\operatorname{retr}_p(Y) = q$</span> such that</p><ol><li>(associated retraction) <span>$\mathcal T_{p,d}X ‚àà T_q\mathcal M$</span> if and only if <span>$q = \operatorname{retr}_p(d)$</span>,</li><li>(consistency) <span>$\mathcal T_{p,0_p}X = X$</span> for all <span>$X‚ààT_p\mathcal M$</span>,</li><li>(linearity) <span>$\mathcal T_{p,d}(Œ±X+Œ≤Y) = \mathcal Œ±T_{p,d}X + \mathcal Œ≤T_{p,d}Y$</span> for all <span>$Œ±, Œ≤ ‚àà ùîΩ$</span>,</li></ol><p>hold.</p><p>Currently the following methods for vector transport are defined in <code>ManifoldsBase.jl</code>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}" href="#ManifoldsBase.default_vector_transport_method-Tuple{AbstractManifold}"><code>ManifoldsBase.default_vector_transport_method</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_vector_transport_method(M::AbstractManifold)
default_vector_transport_method(M::AbstractManifold, ::Type{T}) where {T}</code></pre><p>The <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> that is used when calling <a href="vector_transports.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, or <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> without specifying the vector transport method. By default, this is <a href="vector_transports.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p><p>This method can also be specified more precisely with a point type <code>T</code>, for the case that on a <code>M</code> there are two different representations of points, which provide different vector transport methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L316-L328">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along" href="#ManifoldsBase.vector_transport_along"><code>ManifoldsBase.vector_transport_along</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along(M::AbstractManifold, p, X, c)
vector_transport_along(M::AbstractManifold, p, X, c, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="manifolds.html#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L498-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!" href="#ManifoldsBase.vector_transport_along!"><code>ManifoldsBase.vector_transport_along!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along!(M::AbstractManifold, Y, p, X, c::AbstractVector)
vector_transport_along!(M::AbstractManifold, Y, p, X, c::AbstractVector, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along the curve represented by <code>c</code> using the <code>method</code>, which defaults to <a href="manifolds.html#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. The result is saved to <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L631-L638">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector, SchildsLadderTransport}" href="#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, AbstractVector, SchildsLadderTransport}"><code>ManifoldsBase.vector_transport_along</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along(
    M::AbstractManifold,
    p,
    X,
    c::AbstractVector,
    m::SchildsLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="vector_transports.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L799-L812">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}" href="#ManifoldsBase.vector_transport_along-Tuple{AbstractManifold, Any, Any, Any, AbstractVector, PoleLadderTransport}"><code>ManifoldsBase.vector_transport_along</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function vector_transport_along(
    M::AbstractManifold,
    p,
    X,
    c::AbstractVector,
    m::PoleLadderTransport
)</code></pre><p>Compute the vector transport along a discretized curve using <a href="vector_transports.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> succesively along the sampled curve. This method is avoiding additional allocations as well as inner exp/log by performing all ladder steps on the manifold and only computing one tangent vector in the end.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L724-L737">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction" href="#ManifoldsBase.vector_transport_direction"><code>ManifoldsBase.vector_transport_direction</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::AbstractManifold, p, X, d)
vector_transport_direction(M::AbstractManifold, p, X, d, m::AbstractVectorTransportMethod)</code></pre><p>Given an <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <span>$\mathcal M$</span> the vector transport is a generalization of the <a href="functions.html#ManifoldsBase.parallel_transport_direction-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_direction</code></a> that identifies vectors from different tangent spaces.</p><p>More precisely using <sup class="footnote-reference"><a id="citeref-AbsilMahonySepulchre2008" href="#footnote-AbsilMahonySepulchre2008">[AbsilMahonySepulchre2008]</a></sup>, Def. 8.1.1, a vector transport <span>$T_{p,d}: T_p\mathcal M \to T_q\mathcal M$</span>, <span>$p‚àà \mathcal M$</span>, <span>$Y‚àà T_p\mathcal M$</span> is a smooth mapping associated to a retraction <span>$\operatorname{retr}_p(Y) = q$</span> such that</p><ol><li>(associated retraction) <span>$\mathcal T_{p,d}X ‚àà T_q\mathcal M$</span> if and only if <span>$q = \operatorname{retr}_p(d)$</span>.</li><li>(consistency) <span>$\mathcal T_{p,0_p}X = X$</span> for all <span>$X‚ààT_p\mathcal M$</span></li><li>(linearity) <span>$\mathcal T_{p,d}(Œ±X+Œ≤Y) = Œ±\mathcal T_{p,d}X + Œ≤\mathcal T_{p,d}Y$</span></li></ol><p>For the <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> we might even omit the third point. The <a href="vector_transports.html#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a>s are linear.</p><p><strong>Input Parameters</strong></p><ul><li><code>M</code> a manifold</li><li><code>p</code> indicating the tangent space of</li><li><code>X</code> the tangent vector to be transported</li><li><code>d</code> indicating a transport direction (and distance through its length)</li><li><code>m</code> an <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>, by default <a href="manifolds.html#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a>, so usually <a href="vector_transports.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a></li></ul><p>Usually this method requires a <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> as well. By default this is assumed to be the <a href="manifolds.html#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a> or implicitly given (and documented) for a vector transport. To explicitly distinguish different retractions for a vector transport, see <a href="vector_transports.html#ManifoldsBase.VectorTransportDirection"><code>VectorTransportDirection</code></a>.</p><p>Instead of spcifying a start direction <code>d</code> one can equivalently also specify a target tanget space <span>$T_q\mathcal M$</span>, see <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>. By default <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> falls back to using <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, using the <a href="manifolds.html#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a> on <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L871-L913">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!" href="#ManifoldsBase.vector_transport_direction!"><code>ManifoldsBase.vector_transport_direction!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction!(M::AbstractManifold, Y, p, X, d)
vector_transport_direction!(M::AbstractManifold, Y, p, X, d, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> in the direction indicated by the tangent vector <code>d</code> at <code>p</code>. By default, <a href="manifolds.html#ManifoldsBase.retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>retract</code></a> and <a href="vector_transports.html#ManifoldsBase.vector_transport_to!"><code>vector_transport_to!</code></a> are used with the <code>m</code> and <code>r</code>, which default to <a href="manifolds.html#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code> and <a href="manifolds.html#ManifoldsBase.default_retraction_method-Tuple{PowerManifold}"><code>default_retraction_method</code></a><code>(M)</code>, respectively. The result is saved to <code>Y</code>.</p><p>See <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1005-L1016">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to" href="#ManifoldsBase.vector_transport_to"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to(M::AbstractManifold, p, X, q)
vector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)
vector_transport_to(M::AbstractManifold, p, X, q, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> along a curve implicitly given by an <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> associated to <code>m</code>. By default <code>m</code> is the <a href="manifolds.html#ManifoldsBase.default_vector_transport_method-Tuple{PowerManifold}"><code>default_vector_transport_method</code></a><code>(M)</code>. To explicitly specify a (different) retraction to the implicitly assumeed retraction, see <a href="vector_transports.html#ManifoldsBase.VectorTransportTo"><code>VectorTransportTo</code></a>. Note that some vector transport methods might also carry their own retraction they are associated to, like the  <a href="vector_transports.html#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> and some are even independent of the retraction, for example the <a href="vector_transports.html#ManifoldsBase.ProjectionTransport"><code>ProjectionTransport</code></a>.</p><p>This method is equivalent to using <span>$d = \operatorname{retr}^{-1}_p(q)$</span> in <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a><code>(M, p, X, q, m, r)</code>, where you can find the formal definition. This is the fallback for <a href="vector_transports.html#ManifoldsBase.VectorTransportTo"><code>VectorTransportTo</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1108-L1122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!" href="#ManifoldsBase.vector_transport_to!"><code>ManifoldsBase.vector_transport_to!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to!(M::AbstractManifold, Y, p, X, q)
vector_transport_to!(M::AbstractManifold, Y, p, X, q, m::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from the tangent space at a point <code>p</code> on the <a href="types.html#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> to <code>q</code> using the <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>m</code> and the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>r</code>.</p><p>The result is computed in <code>Y</code>. See <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1212-L1221">source</a></section></article><h2 id="Types-of-vector-transports"><a class="docs-heading-anchor" href="#Types-of-vector-transports">Types of vector transports</a><a id="Types-of-vector-transports-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-vector-transports" title="Permalink"></a></h2><p>To distinguish different types of vector transport we introduce the <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a>. The following concrete types are available.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractLinearVectorTransportMethod" href="#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>ManifoldsBase.AbstractLinearVectorTransportMethod</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractLinearVectorTransportMethod &lt;: AbstractVectorTransportMethod</code></pre><p>Abstract type for linear methods for transporting vectors, that is transport of a linear combination of vectors is a linear combination of transported vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L14-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors. Such vector transports are not necessarily linear.</p><p><strong>See also</strong></p><p><a href="vector_transports.html#ManifoldsBase.AbstractLinearVectorTransportMethod"><code>AbstractLinearVectorTransportMethod</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DifferentiatedRetractionVectorTransport" href="#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>ManifoldsBase.DifferentiatedRetractionVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DifferentiatedRetractionVectorTransport{R&lt;:AbstractRetractionMethod} &lt;:
    AbstractVectorTransportMethod</code></pre><p>A type to specify a vector transport that is given by differentiating a retraction. This can be introduced in two ways. Let <span>$\mathcal M$</span> be a Riemannian manifold, <span>$p‚àà\mathcal M$</span> a point, and <span>$X,Y‚àà T_p\mathcal M$</span> denote two tangent vectors at <span>$p$</span>.</p><p>Given a retraction (cf. <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a>) <span>$\operatorname{retr}$</span>, the vector transport of <code>X</code> in direction <code>Y</code> (cf. <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>) by differentiation this retraction, is given by</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{p,Y}X
= D_Y\operatorname{retr}_p(Y)[X]
= \frac{\mathrm{d}}{\mathrm{d}t}\operatorname{retr}_p(Y+tX)\Bigr|_{t=0}.\]</p><p>see <sup class="footnote-reference"><a id="citeref-AbsilMahonySepulchre2008" href="#footnote-AbsilMahonySepulchre2008">[AbsilMahonySepulchre2008]</a></sup>, Section 8.1.2 for more details.</p><p>This can be phrased similarly as a <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> by introducing <span>$q=\operatorname{retr}_pX$</span> and defining</p><p class="math-container">\[\mathcal T^{\operatorname{retr}}_{q \gets p}X = \mathcal T^{\operatorname{retr}}_{p,Y}X\]</p><p>which in practice usually requires the <a href="manifolds.html#ManifoldsBase.inverse_retract-Tuple{AbstractPowerManifold, Vararg{Any}}"><code>inverse_retract</code></a> to exists in order to compute <span>$Y = \operatorname{retr}_p^{-1}q$</span>.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">DifferentiatedRetractionVectorTransport(m::AbstractRetractionMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L22-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Compute the vector transport by parallel transport, see <a href="functions.html#ManifoldsBase.parallel_transport_to-Tuple{AbstractManifold, Any, Any, Any}"><code>parallel_transport_to</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PoleLadderTransport" href="#ManifoldsBase.PoleLadderTransport"><code>ManifoldsBase.PoleLadderTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PoleLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="vector_transports.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> as vector transport method within <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="vector_transports.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X‚àà T_p\mathcal M$</span> be a tangent vector at <span>$p‚àà\mathcal M$</span> and <span>$q‚àà\mathcal M$</span> the point to transport to. Then <span>$x = \exp_pX$</span> is used to call <code>y =</code><a href="vector_transports.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a><code>(M, p, x, q)</code> and the resulting vector is obtained by computing <span>$Y = -\log_qy$</span>.</p><p>The <a href="vector_transports.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a> posesses two advantages compared to <a href="vector_transports.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>:</p><ul><li>it is cheaper to evaluate, if you want to transport several vectors, since the mid point <span>$c$</span> then stays unchanged.</li><li>while both methods are exact if the curvature is zero, pole ladder is even exact in symmetric Riemannian manifolds<sup class="footnote-reference"><a id="citeref-Pennec2018" href="#footnote-Pennec2018">[Pennec2018]</a></sup></li></ul><p>The pole ladder was was proposed in <sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. Its name stems from the fact that it resembles a pole ladder when applied to a sequence of points usccessively.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">PoleLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical pole ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-LorenziPennec2014" href="#footnote-LorenziPennec2014">[LorenziPennec2014]</a></sup>. For an even cheaper transport the inner operations can be changed to an <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L78-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="vector_transports.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>. See <a href="manifolds.html#ManifoldsBase.project-Tuple{AbstractPowerManifold, Any, Any}"><code>project</code></a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ScaledVectorTransport" href="#ManifoldsBase.ScaledVectorTransport"><code>ManifoldsBase.ScaledVectorTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ScaledVectorTransport{T} &lt;: AbstractVectorTransportMethod</code></pre><p>Introduce a scaled variant of any <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>T</code>, as introduced in <sup class="footnote-reference"><a id="citeref-SatoIwai2013" href="#footnote-SatoIwai2013">[SatoIwai2013]</a></sup> for some <span>$X‚àà T_p\mathcal M$</span> as</p><p class="math-container">\[    \mathcal T^{\mathrm{S}}(X) = \frac{\lVert X\rVert_p}{\lVert \mathcal T(X)\rVert_q}\mathcal T(X).\]</p><p>Note that the resulting point <code>q</code> has to be known, i.e. for <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> the curve or more precisely its end point has to be known (via an exponential map or a retraction). Therefore a default implementation is only provided for the <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a></p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">ScaledVectorTransport(m::AbstractVectorTransportMethod)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L140-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.SchildsLadderTransport" href="#ManifoldsBase.SchildsLadderTransport"><code>ManifoldsBase.SchildsLadderTransport</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SchildsLadderTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use <a href="vector_transports.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> as vector transport method within <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a>, or <a href="vector_transports.html#ManifoldsBase.vector_transport_along"><code>vector_transport_along</code></a>, i.e.</p><p>Let <span>$X‚àà T_p\mathcal M$</span> be a tangent vector at <span>$p‚àà\mathcal M$</span> and <span>$q‚àà\mathcal M$</span> the point to transport to. Then</p><p class="math-container">\[P^{\mathrm{S}}_{q\gets p}(X) =
    \log_q\bigl( \operatorname{retr}_p ( 2\operatorname{retr}_p^{-1}c ) \bigr),\]</p><p>where <span>$c$</span> is the mid point between <span>$q$</span> and <span>$d=\exp_pX$</span>.</p><p>This method employs the internal function <a href="vector_transports.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a><code>(M, p, d, q)</code> that avoids leaving the manifold.</p><p>The name stems from the image of this paralleltogram in a repeated application yielding the image of a ladder. The approximation was proposed in <sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SchildsLadderTransport(
    retraction = ExponentialRetraction(),
    inverse_retraction = LogarithmicInverseRetraction(),
)</code></pre><p>Construct the classical Schilds ladder that employs exp and log, i.e. as proposed in<sup class="footnote-reference"><a id="citeref-EhlersPiraniSchild1972" href="#footnote-EhlersPiraniSchild1972">[EhlersPiraniSchild1972]</a></sup>. For an even cheaper transport these inner operations can be changed to an <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>retraction</code> and an <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> <code>inverse_retraction</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L169-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorTransportDirection" href="#ManifoldsBase.VectorTransportDirection"><code>ManifoldsBase.VectorTransportDirection</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorTransportDirection{VM&lt;:AbstractVectorTransportMethod,RM&lt;:AbstractRetractionMethod}
    &lt;: AbstractVectorTransportMethod</code></pre><p>Specify a <a href="vector_transports.html#ManifoldsBase.vector_transport_direction"><code>vector_transport_direction</code></a> using a <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> with explicitly using the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> to determine the point in the specified direction where to transsport to. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L227-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorTransportTo" href="#ManifoldsBase.VectorTransportTo"><code>ManifoldsBase.VectorTransportTo</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorTransportTo{VM&lt;:AbstractVectorTransportMethod,RM&lt;:AbstractRetractionMethod}
    &lt;: AbstractVectorTransportMethod</code></pre><p>Specify a <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a> using a <a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> with explicitly using the <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a> to determine the direction that transports from  in <code>p</code>to <code>q</code>. Note that you only need this for the non-default (non-implicit) second retraction method associated to a vector transport, i.e. when a first implementation assumed an implicit associated retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L255-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.VectorTransportWithKeywords" href="#ManifoldsBase.VectorTransportWithKeywords"><code>ManifoldsBase.VectorTransportWithKeywords</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VectorTransportWithKeywords{V&lt;:AbstractVectorTransportMethod, K} &lt;: AbstractVectorTransportMethod</code></pre><p>Since vector transports might have keywords, this type is a way to set them as an own type to be used as a specific vector transport. Another reason for this type is that we dispatch on the vector transport first and only the last layer would be implemented with keywords, so this way they can be passed down.</p><p><strong>Fields</strong></p><ul><li><code>vector_transport</code> the vector transport that is decorated with keywords</li><li><code>kwargs</code> the keyword arguments</li></ul><p>Note that you can nest this type. Then the most outer specification of a keyword is used.</p><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">VectorTransportWithKeywords(m::T; kwargs...) where {T &lt;: AbstractVectorTransportMethod}</code></pre><p>Specify the subtype <code>T &lt;:</code><a href="vector_transports.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> to have keywords <code>kwargs...</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L283-L303">source</a></section></article><h2 id="Functions-to-implement-(on-Layer-III)"><a class="docs-heading-anchor" href="#Functions-to-implement-(on-Layer-III)">Functions to implement (on Layer III)</a><a id="Functions-to-implement-(on-Layer-III)-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-to-implement-(on-Layer-III)" title="Permalink"></a></h2><p>While you should always add your documentation to the first layer vector transport methods above when implementing new manifolds, the actual implementation happens on the following functions on <a href="design.html#design-layer3">layer III</a>.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder" href="#ManifoldsBase.pole_ladder"><code>ManifoldsBase.pole_ladder</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, p, q);
    retraction=default_retraction_method(M, typeof(p)),
    inverse_retraction=default_inverse_retraction_method(M, typeof(p))
)</code></pre><p>Compute an inner step of the pole ladder, that can be used as a <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>. Let <span>$c = \gamma_{p,q}(\frac{1}{2})$</span> mid point between <code>p</code> and <code>q</code>, then the pole ladder is given by</p><p class="math-container">\[    \operatorname{Pl}(p,d,q) = \operatorname{retr}_d (2\operatorname{retr}_d^{-1}c)\]</p><p>Where the classical pole ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = -\log_q \operatorname{Pl}(p,d,q)$</span>, you will obtain the <a href="vector_transports.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. When performing multiple steps, this method avoids the switching to the tangent space. Keep in mind that after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = (-1)^n\log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p><p>It is cheaper to evaluate than <a href="vector_transports.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a>, sinc if you want to form multiple ladder steps between <code>p</code> and <code>q</code>, but with different <code>d</code>, there is just one evaluation of a geodesic each., since the center <code>c</code> can be reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L336-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.pole_ladder!" href="#ManifoldsBase.pole_ladder!"><code>ManifoldsBase.pole_ladder!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pole_ladder(
    M,
    pl,
    p,
    d,
    q,
    c = mid_point(M, p, q),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Compute the <a href="vector_transports.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a>, i.e. the result is saved in <code>pl</code>. <code>X</code> is used for storing intermediate inverse retraction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L379-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder" href="#ManifoldsBase.schilds_ladder"><code>ManifoldsBase.schilds_ladder</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder(
    M,
    p,
    d,
    q,
    c = mid_point(M, q, d);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Perform an inner step of schilds ladder, which can be used as a <a href="manifolds.html#ManifoldsBase.vector_transport_to-Tuple{AbstractPowerManifold, Any, Any, Any, AbstractVectorTransportMethod}"><code>vector_transport_to</code></a>, see <a href="vector_transports.html#ManifoldsBase.SchildsLadderTransport"><code>SchildsLadderTransport</code></a>. Let <span>$c = \gamma_{q,d}(\frac{1}{2})$</span> denote the mid point on the shortest geodesic connecting <span>$q$</span> and the point <span>$d$</span>. Then Schild&#39;s ladder reads as</p><p class="math-container">\[\operatorname{Sl}(p,d,q) = \operatorname{retr}_x( 2\operatorname{retr}_p^{-1} c)\]</p><p>Where the classical Schilds ladder employs <span>$\operatorname{retr}_d=\exp_d$</span> and <span>$\operatorname{retr}_d^{-1}=\log_d$</span> but for an even cheaper transport these can be set to different <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> and <a href="retractions.html#ManifoldsBase.AbstractInverseRetractionMethod"><code>AbstractInverseRetractionMethod</code></a>.</p><p>In consistency with <a href="vector_transports.html#ManifoldsBase.pole_ladder"><code>pole_ladder</code></a> you can change the way the mid point is computed using the optional parameter <code>c</code>, but note that here it&#39;s the mid point between <code>q</code> and <code>d</code>.</p><p>When you have <span>$X=log_pd$</span> and <span>$Y = \log_q \operatorname{Sl}(p,d,q)$</span>, you will obtain the <a href="vector_transports.html#ManifoldsBase.PoleLadderTransport"><code>PoleLadderTransport</code></a>. Then the approximation to the transported vector is given by <span>$\log_q\operatorname{Sl}(p,d,q)$</span>.</p><p>When performing multiple steps, this method avoidsd the switching to the tangent space. Hence after <span>$n$</span> successive steps the tangent vector reads <span>$Y_n = \log_q \operatorname{Pl}(p_{n-1},d_{n-1},p_n)$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L411-L445">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.schilds_ladder!" href="#ManifoldsBase.schilds_ladder!"><code>ManifoldsBase.schilds_ladder!</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schilds_ladder!(
    M,
    sl
    p,
    d,
    q,
    c = mid_point(M, q, d),
    X = allocate_result_type(M, log, d, c);
    retraction = default_retraction_method(M, typeof(p)),
    inverse_retraction = default_inverse_retraction_method(M, typeof(p)),
)</code></pre><p>Compute <a href="vector_transports.html#ManifoldsBase.schilds_ladder"><code>schilds_ladder</code></a> and return the value in the parameter <code>sl</code>. If the required mid point <code>c</code> was computed before, it can be passed using <code>c</code>, and the allocation of new memory can be avoided providing a tangent vector <code>X</code> for the interims result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L457-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along_diff!-Tuple{AbstractManifold, Any, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_along_diff!-Tuple{AbstractManifold, Any, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_along_diff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along_diff!(M::AbstractManifold, Y, p, X, c, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> along the curve <code>c</code> using the differential of the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L562-L567">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}" href="#ManifoldsBase.vector_transport_along_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}"><code>ManifoldsBase.vector_transport_along_diff</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along_diff(M::AbstractManifold, p, X, c, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> along the curve <code>c</code> using the differential of the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L546-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along_project!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}" href="#ManifoldsBase.vector_transport_along_project!-Tuple{AbstractManifold, Any, Any, Any, AbstractVector}"><code>ManifoldsBase.vector_transport_along_project!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along_project!(M::AbstractManifold, Y, p, X, c::AbstractVector)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> along the curve <code>c</code> using a projection. The result is computed in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L598-L603">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along_project-Tuple{AbstractManifold, Any, Any, AbstractVector}" href="#ManifoldsBase.vector_transport_along_project-Tuple{AbstractManifold, Any, Any, AbstractVector}"><code>ManifoldsBase.vector_transport_along_project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_along_project(M::AbstractManifold, p, X, c::AbstractVector)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> along the curve <code>c</code> using a projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L582-L587">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}" href="#ManifoldsBase.vector_transport_direction_diff!-NTuple{6, Any}"><code>ManifoldsBase.vector_transport_direction_diff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction_diff!(M::AbstractManifold, Y, p, X, d, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> into the direction <code>d</code> using the differential of the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1065-L1070">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}" href="#ManifoldsBase.vector_transport_direction_diff-Tuple{AbstractManifold, Any, Any, Any, AbstractRetractionMethod}"><code>ManifoldsBase.vector_transport_direction_diff</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_direction_diff(M::AbstractManifold, p, X, d, m::AbstractRetractionMethod)</code></pre><p>Compute the vector transport of <code>X</code> from <span>$T_p\mathcal M$</span> into the direction <code>d</code> using the differential of the <a href="retractions.html#ManifoldsBase.AbstractRetractionMethod"><code>AbstractRetractionMethod</code></a> <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L977-L982">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Any, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to_diff!-Tuple{AbstractManifold, Any, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to_diff!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_diff(M::AbstractManifold, p, X, q, r)</code></pre><p>Compute a vector transport by using a <a href="vector_transports.html#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> <code>r</code> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1171-L1175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_diff-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to_diff-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to_diff</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_diff(M::AbstractManifold, p, X, q, r)</code></pre><p>Compute a vector transport by using a <a href="vector_transports.html#ManifoldsBase.DifferentiatedRetractionVectorTransport"><code>DifferentiatedRetractionVectorTransport</code></a> <code>r</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1162-L1166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Any, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to_project!-Tuple{AbstractManifold, Any, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to_project!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_project!(M::AbstractManifold, Y, p, X, q)</code></pre><p>Compute a vector transport by projecting <span>$X\in T_p\mathcal M$</span> onto the tangent space <span>$T_q\mathcal M$</span> at <span>$q$</span> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1200-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to_project-Tuple{AbstractManifold, Any, Any, Any}" href="#ManifoldsBase.vector_transport_to_project-Tuple{AbstractManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to_project</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vector_transport_to_project(M::AbstractManifold, p, X, q)</code></pre><p>Compute a vector transport by projecting <span>$X\in T_p\mathcal M$</span> onto the tangent space <span>$T_q\mathcal M$</span> at <span>$q$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/3ae0fb563fb83cd2b4aa8a054c2948f4f5b8f1d0/src/vector_transport.jl#L1190-L1195">source</a></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-AbsilMahonySepulchre2008"><a class="tag is-link" href="#citeref-AbsilMahonySepulchre2008">AbsilMahonySepulchre2008</a><blockquote><p>Absil, P.-A., Mahony, R. and Sepulchre R., <em>Optimization Algorithms on Matrix Manifolds</em> Princeton University Press, 2008, doi: <a href="https://doi.org/10.1515/9781400830244">10.1515/9781400830244</a> <a href="http://press.princeton.edu/chapters/absil/">open access</a></p></blockquote></li><li class="footnote" id="footnote-LorenziPennec2014"><a class="tag is-link" href="#citeref-LorenziPennec2014">LorenziPennec2014</a><blockquote><p>Lorenzi, M. and Pennec, X: Efficient parallel transport of deformations in time series of images: From Schild‚Äôs to pole ladder. Journal of Mathematical Imaging and Vision (2014), 50(1), pp. 5‚Äì17 doi <a href="https://doi.org/10.1007/s10851-013-0470-3">10.1007/s10851-013-0470-3</a>, hal: <a href="https://hal.inria.fr/hal-00870489">hal-00870489</a></p></blockquote></li><li class="footnote" id="footnote-Pennec2018"><a class="tag is-link" href="#citeref-Pennec2018">Pennec2018</a><blockquote><p>Pennec, X: Parallel Transport with Pole Ladder: a Third Order Scheme in Affine Connection Spaces which is Exact in Affine Symmetric Spaces. arXiv: <a href="https://arxiv.org/abs/1805.11436">1805.11436</a></p></blockquote></li><li class="footnote" id="footnote-SatoIwai2013"><a class="tag is-link" href="#citeref-SatoIwai2013">SatoIwai2013</a><blockquote><p>Sato, H., Iwai, T.: <em>A new, globally convergent Riemannian conjugate gradient method</em>, Optimization, 2013, Volume 64(4), pp. 1011‚Äì1031. doi: <a href="https://doi.org/10.1080/02331934.2013.836650">10.1080/02331934.2013.836650</a>, arXiv: <a href="https://arxiv.org/abs/1302.0125">1302.0125</a>.</p></blockquote></li><li class="footnote" id="footnote-EhlersPiraniSchild1972"><a class="tag is-link" href="#citeref-EhlersPiraniSchild1972">EhlersPiraniSchild1972</a><blockquote><p>Ehlers, J., Pirani, F.A.E., Schild, A.: The geometry of free fall and light propagation. In: O‚ÄôRaifeartaigh, L. (ed.) General Relativity: Papers in Honour of J. L. Synge, pp. 63‚Äì84. Clarendon Press, Oxford (1972). reprint doi: <a href="https://doi.org/10.1007/s10714-012-1353-4">10.1007/s10714-012-1353-4</a></p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="retractions.html">¬´ Retractions</a><a class="docs-footer-nextpage" href="manifolds.html">Manifolds ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 14 March 2023 13:27">Tuesday 14 March 2023</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
