<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manifolds ¬∑ ManifoldsBase.jl</title><meta name="title" content="Manifolds ¬∑ ManifoldsBase.jl"/><meta property="og:title" content="Manifolds ¬∑ ManifoldsBase.jl"/><meta property="twitter:title" content="Manifolds ¬∑ ManifoldsBase.jl"/><meta name="description" content="Documentation for ManifoldsBase.jl."/><meta property="og:description" content="Documentation for ManifoldsBase.jl."/><meta property="twitter:description" content="Documentation for ManifoldsBase.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../assets/citations.css" rel="stylesheet" type="text/css"/><link href="../assets/link-icons.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.png" alt="ManifoldsBase.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.png" alt="ManifoldsBase.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ManifoldsBase.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/implement-a-manifold/">How to define a manifold</a></li><li><a class="tocitem" href="../design/">Design principles</a></li><li><a class="tocitem" href="../types/">An abstract manifold</a></li><li><span class="tocitem">Functions on manifolds</span><ul><li><a class="tocitem" href="../functions/">Basic functions</a></li><li><a class="tocitem" href="../projections/">Projections</a></li><li><a class="tocitem" href="../retractions/">Retractions</a></li><li><a class="tocitem" href="../vector_transports/">Vector transports</a></li></ul></li><li class="is-active"><a class="tocitem" href>Manifolds</a><ul class="internal"><li><a class="tocitem" href="#A-default-manifold"><span>A default manifold</span></a></li><li><a class="tocitem" href="#sec-embedded-manifold"><span>Embedded manifold</span></a></li><li><a class="tocitem" href="#Connections"><span>Connections</span></a></li><li><a class="tocitem" href="#Metrics"><span>Metrics</span></a></li><li><a class="tocitem" href="#A-manifold-for-validation"><span>A manifold for validation</span></a></li></ul></li><li><a class="tocitem" href="../metamanifolds/">Meta-Manifolds</a></li><li><a class="tocitem" href="../decorator/">Decorating/Extending a Manifold</a></li><li><a class="tocitem" href="../bases/">Bases for tangent spaces</a></li><li><a class="tocitem" href="../numerical_verification/">Numerical Verification</a></li><li><a class="tocitem" href="../NEWS/">Changelog</a></li><li><a class="tocitem" href="../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manifolds</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manifolds</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/master/docs/src/manifolds.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manifolds"><a class="docs-heading-anchor" href="#Manifolds">Manifolds</a><a id="Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Manifolds" title="Permalink"></a></h1><p>While the interface <code>ManifoldsBase.jl</code> does not cover concrete manifolds, it provides a few helpers to build or create manifolds based on existing manifolds</p><h2 id="A-default-manifold"><a class="docs-heading-anchor" href="#A-default-manifold">A default manifold</a><a id="A-default-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#A-default-manifold" title="Permalink"></a></h2><p><a href="#ManifoldsBase.DefaultManifold"><code>DefaultManifold</code></a> is a simplified version of <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> and demonstrates a basic interface implementation. It can be used to perform simple tests. Since when using <code>Manifolds.jl</code> the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> is available, the <code>DefaultManifold</code> itself is not exported.</p><article><details class="docstring" open="true"><summary id="ManifoldsBase.DefaultManifold"><a class="docstring-binding" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DefaultManifold &lt;: AbstractManifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variables.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DefaultManifold(n::Int...; field = ‚Ñù, parameter::Symbol = :field)</code></pre><p>Arguments:</p><ul><li><code>n</code>: shape of array representing points on the manifold.</li><li><code>field</code>: field over which the manifold is defined. Either <code>‚Ñù</code>, <code>‚ÑÇ</code> or <code>‚Ñç</code>.</li><li><code>parameter</code>: whether a type parameter should be used to store <code>n</code>. By default size is stored in a field. Value can either be <code>:field</code> or <code>:type</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/DefaultManifold.jl#L1-L23">source</a></section></details></article><h2 id="sec-embedded-manifold"><a class="docs-heading-anchor" href="#sec-embedded-manifold">Embedded manifold</a><a id="sec-embedded-manifold-1"></a><a class="docs-heading-anchor-permalink" href="#sec-embedded-manifold" title="Permalink"></a></h2><p>The embedded manifold is a manifold <span>$\mathcal M$</span> which is modelled <em>explicitly</em> specifying its embedding <span>$\mathcal N$</span> in which the points and tangent vectors are represented. Most prominently <a href="../functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a> and <a href="../functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>is_vector</code></a> of an embedded manifold are implemented to check whether the point is a valid point in the embedding. This can of course still be extended by further tests. <code>ManifoldsBase.jl</code> provides two possibilities of easily introducing this in order to dispatch some functions to the embedding.</p><h3 id="subsec-implicit-embedded"><a class="docs-heading-anchor" href="#subsec-implicit-embedded">Implicit case: the decorator Trait</a><a id="subsec-implicit-embedded-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-implicit-embedded" title="Permalink"></a></h3><p>For the implicit case, your manifold has to be a subtype of the <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> and specifying the <a href="../decorator/#ManifoldsBase.get_embedding_type-Tuple{AbstractManifold}"><code>get_embedding_type</code></a> makes that manifold an embedded manifold. You just have to also define <a href="../decorator/#ManifoldsBase.get_embedding-Tuple{AbstractDecoratorManifold, Type}"><code>get_embedding</code></a> so that appropriate functions are passed on to that embedding. Which are passed on also depends on the <a href="../decorator/#ManifoldsBase.AbstractForwardingType"><code>AbstractForwardingType</code></a> you specify. This is the implicit case, since the manifold type itself does not carry any information about the embedding, just the trait and the function definition do.</p><h3 id="subsec-explicit-embedded"><a class="docs-heading-anchor" href="#subsec-explicit-embedded">Explicit case: the <code>EmbeddedManifold</code></a><a id="subsec-explicit-embedded-1"></a><a class="docs-heading-anchor-permalink" href="#subsec-explicit-embedded" title="Permalink"></a></h3><p>The <a href="#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> itself is an <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> so it is a case of the implicit embedding itself, but internally stores both the original manifold and the embedding. They are also parameters of the type. This way, an additional embedding of one manifold in another can be modelled. That is, if the manifold is implemented using the implicit embedding approach from before but can also be implemented using a <em>different</em> embedding, then this method should be chosen, since you can dispatch functions that you want to implement in this embedding then on the type which explicitly has the manifold and its embedding as parameters.</p><p>Hence this case should be used for any further embedding after the first or if the default implementation works without an embedding and the alternative needs one.</p><article><details class="docstring" open="true"><summary id="ManifoldsBase.EmbeddedManifold"><a class="docstring-binding" href="#ManifoldsBase.EmbeddedManifold"><code>ManifoldsBase.EmbeddedManifold</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EmbeddedManifold{ùîΩ, MT &lt;: AbstractManifold, NT &lt;: AbstractManifold} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A type to represent an explicit embedding of a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> of type <code>MT</code> embedded into a manifold <code>N</code> of type <code>NT</code>. By default, an embedded manifold is set to be embedded, but neither isometrically embedded nor a submanifold.</p><div class="admonition is-info" id="Note-a785f8c6990b7f6c"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-a785f8c6990b7f6c" title="Permalink"></a></header><div class="admonition-body"><p>This type is not required if a manifold <code>M</code> is to be embedded in one specific manifold <code>N</code>.  One can then just implement <a href="../functions/#ManifoldsBase.embed!-Tuple{AbstractManifold, Any, Any, Any}"><code>embed!</code></a> and <a href="../projections/#ManifoldsBase.project!-Tuple{AbstractManifold, Any, Any, Any}"><code>project!</code></a>. You can further pass functions to the embedding, for example, when it is an isometric embedding, by using an <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a>. Only for a second ‚Äìmaybe considered non-default‚Äì embedding, this type should be considered in order to dispatch on different embed and project methods for different embeddings <code>N</code>.</p></div></div><p><strong>Fields</strong></p><ul><li><code>manifold</code> the manifold that is an embedded manifold</li><li><code>embedding</code> a second manifold, the first one is embedded into</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">EmbeddedManifold(M, N)</code></pre><p>Generate the <code>EmbeddedManifold</code> of the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> into the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/EmbeddedManifold.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}"><a class="docstring-binding" href="#ManifoldsBase.decorated_manifold-Tuple{EmbeddedManifold}"><code>ManifoldsBase.decorated_manifold</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">decorated_manifold(M::EmbeddedManifold, d::Val{N} = Val(-1))</code></pre><p>Return the manifold of <code>M</code> that is decorated with its embedding. For this specific type the internally stored enhanced manifold <code>M.manifold</code> is returned.</p><p>See also <a href="../functions/#ManifoldsBase.base_manifold"><code>base_manifold</code></a>, where this is used to (potentially) completely undecorate the manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/EmbeddedManifold.jl#L49-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><a class="docstring-binding" href="#ManifoldsBase.get_embedding-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_embedding(M::EmbeddedManifold)</code></pre><p>Return the embedding <a href="#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a> <code>N</code> of <code>M</code>, if it exists.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/EmbeddedManifold.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.get_embedding_type-Tuple{EmbeddedManifold}"><a class="docstring-binding" href="#ManifoldsBase.get_embedding_type-Tuple{EmbeddedManifold}"><code>ManifoldsBase.get_embedding_type</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_embedding_type(::EmbeddedManifold)</code></pre><p>Specify the type of embedding. This by default returns <a href="../decorator/#ManifoldsBase.EmbeddedManifoldType"><code>EmbeddedManifoldType</code></a><code>()</code>. It can be further specified by dispatching in the parameters of the <a href="#ManifoldsBase.EmbeddedManifold"><code>EmbeddedManifold</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/EmbeddedManifold.jl#L36-L41">source</a></section></details></article><h2 id="Connections"><a class="docs-heading-anchor" href="#Connections">Connections</a><a id="Connections-1"></a><a class="docs-heading-anchor-permalink" href="#Connections" title="Permalink"></a></h2><p>Most connection-related functionality previously defined in <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/"><code>Manifolds.jl</code></a> is currently available here.</p><article><details class="docstring" open="true"><summary id="ManifoldsBase.AbstractAffineConnection"><a class="docstring-binding" href="#ManifoldsBase.AbstractAffineConnection"><code>ManifoldsBase.AbstractAffineConnection</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractAffineConnection</code></pre><p>Abstract type for affine connections on a manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L1-L5">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.ConnectionManifold"><a class="docstring-binding" href="#ManifoldsBase.ConnectionManifold"><code>ManifoldsBase.ConnectionManifold</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ConnectionManifold{ùîΩ,,M&lt;:AbstractManifold{ùîΩ},G&lt;:AbstractAffineConnection} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ConnectionManifold(M, C)</code></pre><p>Decorate the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with <a href="#ManifoldsBase.AbstractAffineConnection"><code>AbstractAffineConnection</code></a> <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L15-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.LeviCivitaConnection"><a class="docstring-binding" href="#ManifoldsBase.LeviCivitaConnection"><code>ManifoldsBase.LeviCivitaConnection</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LeviCivitaConnection</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Levi-Civita_connection">Levi-Civita connection</a> of a Riemannian manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L8-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.connection-Tuple{AbstractManifold}"><a class="docstring-binding" href="#ManifoldsBase.connection-Tuple{AbstractManifold}"><code>ManifoldsBase.connection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connection(M::AbstractManifold)</code></pre><p>Get the connection (an object of a subtype of <a href="#ManifoldsBase.AbstractAffineConnection"><code>AbstractAffineConnection</code></a>) of <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code>.</p><p>The global default connection is the <a href="#ManifoldsBase.LeviCivitaConnection"><code>LeviCivitaConnection</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L30-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.connection-Tuple{ConnectionManifold}"><a class="docstring-binding" href="#ManifoldsBase.connection-Tuple{ConnectionManifold}"><code>ManifoldsBase.connection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">connection(M::ConnectionManifold)</code></pre><p>Return the connection associated with <a href="#ManifoldsBase.ConnectionManifold"><code>ConnectionManifold</code></a> <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L40-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.is_default_connection-Tuple{AbstractManifold, AbstractAffineConnection}"><a class="docstring-binding" href="#ManifoldsBase.is_default_connection-Tuple{AbstractManifold, AbstractAffineConnection}"><code>ManifoldsBase.is_default_connection</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_default_connection(M::AbstractManifold, c::AbstractAffineConnection)</code></pre><p>returns whether an <a href="#ManifoldsBase.AbstractAffineConnection"><code>AbstractAffineConnection</code></a> is the default metric on the manifold <code>M</code> or not.</p><p>This function falls back to check whether <a href="#ManifoldsBase.connection-Tuple{AbstractManifold}"><code>connection</code></a><code>(M) == c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/connection.jl#L66-L72">source</a></section></details></article><h2 id="Metrics"><a class="docs-heading-anchor" href="#Metrics">Metrics</a><a id="Metrics-1"></a><a class="docs-heading-anchor-permalink" href="#Metrics" title="Permalink"></a></h2><p>Most metric-related functionality is available here. A few additional functions are defined in <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/"><code>Manifolds.jl</code></a>.</p><article><details class="docstring" open="true"><summary id="ManifoldsBase.AbstractMetric"><a class="docstring-binding" href="#ManifoldsBase.AbstractMetric"><code>ManifoldsBase.AbstractMetric</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMetric</code></pre><p>Abstract type for the pseudo-Riemannian metric tensor <span>$g$</span>, a family of smoothly varying inner products on the tangent space. See <a href="../functions/#ManifoldsBase.inner-Tuple{AbstractManifold, Any, Any, Any}"><code>inner</code></a>.</p><p><strong>Functor</strong></p><pre><code class="language-julia hljs">(metric::Metric)(M::AbstractManifold)
(metric::Metric)(M::MetricManifold)</code></pre><p>Generate the <code>MetricManifold</code> that wraps the manifold <code>M</code> with given <code>metric</code>. This works for both a variable containing the metric as well as a subtype <code>T&lt;:AbstractMetric</code>, where a zero parameter constructor <code>T()</code> is available. If <code>M</code> is already a metric manifold, the inner manifold with the new <code>metric</code> is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L1-L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.DefaultMetric"><a class="docstring-binding" href="#ManifoldsBase.DefaultMetric"><code>ManifoldsBase.DefaultMetric</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DefaultMetric &lt;: AbstractMetric</code></pre><p>Indicating that a manifold uses the default metric, that one has implicitly assumed when defining the manifold</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.EuclideanMetric"><a class="docstring-binding" href="#ManifoldsBase.EuclideanMetric"><code>ManifoldsBase.EuclideanMetric</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EuclideanMetric &lt;: RiemannianMetric</code></pre><p>A general type for any manifold that employs the Euclidean Metric, for example the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> manifold itself, or the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/sphere.html"><code>Sphere</code></a>, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).</p><p>Since the metric is independent of the field type, this metric is also used for the Hermitian metrics, i.e. metrics that are analogous to the <code>EuclideanMetric</code> but where the field type of the manifold is <code>‚ÑÇ</code>.</p><p>This metric is the default metric for example for the <a href="https://juliamanifolds.github.io/Manifolds.jl/latest/manifolds/euclidean.html"><code>Euclidean</code></a> manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L28-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.MetricManifold"><a class="docstring-binding" href="#ManifoldsBase.MetricManifold"><code>ManifoldsBase.MetricManifold</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MetricManifold{ùîΩ,M&lt;:AbstractManifold{ùîΩ},G&lt;:AbstractMetric} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>Equip a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> explicitly with an <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>G</code>.</p><p>If the <code>AbstractMetric</code> <code>G</code> yields closed form formulae for the exponential map or another function, you can implement it directly. Otherwise, you can use chart-based solvers, see for example <a href="https://juliamanifolds.github.io/Manifolds.jl/stable/features/atlases/#Manifolds.solve_chart_exp_ode"><code>solve_chart_exp_ode</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">MetricManifold(M, G)</code></pre><p>Generate the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> as a manifold with the <code>AbstractMetric</code> <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L111-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.RiemannianMetric"><a class="docstring-binding" href="#ManifoldsBase.RiemannianMetric"><code>ManifoldsBase.RiemannianMetric</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RiemannianMetric &lt;: AbstractMetric</code></pre><p>Abstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for <span>$X  ‚àà T_p \mathcal M$</span>, the inner product <span>$g(X, X) &gt; 0$</span> whenever <span>$X$</span> is not the zero vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L19-L25">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.log-Tuple{MetricManifold, Vararg{Any}}"><a class="docstring-binding" href="#Base.log-Tuple{MetricManifold, Vararg{Any}}"><code>Base.log</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log(N::MetricManifold{M,G}, p, q)</code></pre><p>Compute the logarithmic map on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> equipped with the <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>G</code>.</p><p>If the metric was declared the default metric, this method falls back to <code>log(M, p, q)</code>. Otherwise, you have to provide an implementation for the non-default <code>AbstractMetric</code> <code>G</code> metric within its <a href="#ManifoldsBase.MetricManifold"><code>MetricManifold</code></a><code>{M,G}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L352-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, AbstractMetric, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.change_metric!-Tuple{AbstractManifold, Any, AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_metric!(M::AbstractManifold, Y, G2::AbstractMetric, p, X)</code></pre><p>Compute the <a href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><code>change_metric</code></a> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L63-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.change_metric-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><code>ManifoldsBase.change_metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_metric(M::AbstractManifold, G2::AbstractMetric, p, X)</code></pre><p>On the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with implicitly given metric <span>$g_1$</span> and a second <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <span>$g_2$</span> this function performs a change of metric in the sense that it returns the tangent vector <span>$Z=BX$</span> such that the linear map <span>$B$</span> fulfills</p><p class="math-container">\[g_2(Y_1,Y_2) = g_1(BY_1,BY_2) \quad \text{for all } Y_1, Y_2 ‚àà T_p\mathcal M.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L44-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, AbstractMetric, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.change_representer!-Tuple{AbstractManifold, Any, AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer!</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_representer!(M::AbstractManifold, Y, G2::AbstractMetric, p, X)</code></pre><p>Compute the <a href="#ManifoldsBase.change_metric-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><code>change_metric</code></a> in place of <code>Y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L91-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.change_representer-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.change_representer-Tuple{AbstractManifold, AbstractMetric, Any, Any}"><code>ManifoldsBase.change_representer</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">change_representer(M::AbstractManifold, G2::AbstractMetric, p, X)</code></pre><p>Convert the representer <code>X</code> of a linear function (in other words a cotangent vector at <code>p</code>) in the tangent space at <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> given with respect to the <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>G2</code> into the representer with respect to the (implicit) metric of <code>M</code>.</p><p>In order to convert <code>X</code> into the representer with respect to the (implicitly given) metric <span>$g_1$</span> of <code>M</code>, we have to find the conversion function <span>$c: T_p\mathcal M \to T_p\mathcal M$</span> such that</p><p class="math-container">\[    g_2(X,Y) = g_1(c(X),Y)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L70-L83">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.inner-Tuple{MetricManifold, Any, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.inner-Tuple{MetricManifold, Any, Any, Any}"><code>ManifoldsBase.inner</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inner(N::MetricManifold{M,G}, p, X, Y)</code></pre><p>Compute the inner product of <code>X</code> and <code>Y</code> from the tangent space at <code>p</code> on the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> using the <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> <code>G</code>.</p><p class="math-container">\[g_p(X, Y) = ‚ü®X, G_p Y‚ü©,\]</p><p>where <span>$G_p$</span> is the local matrix representation of the <code>AbstractMetric</code> <code>G</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L269-L279">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.inverse_retract-Tuple{MetricManifold, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.inverse_retract-Tuple{MetricManifold, Any, Any}"><code>ManifoldsBase.inverse_retract</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_retract(M::MetricManifold, p, q)
inverse_retract!(M::MetricManifold, X, p, q)</code></pre><p>Compute the inverse retraction on the <a href="#ManifoldsBase.MetricManifold"><code>MetricManifold</code></a> <code>M</code>. Since every inverse retraction is an inverse retraction with respect to any logarithmic map (induced by the metric), this method falls back to calling <a href="#ManifoldsBase.inverse_retract-Tuple{MetricManifold, Any, Any}"><code>inverse_retract</code></a> on the base manifold. The two exceptions are the <a href="../retractions/#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a> and <a href="../retractions/#ManifoldsBase.ShootingInverseRetraction"><code>ShootingInverseRetraction</code></a>, in which case the method falls back to the default, that is to calling, respectively, <a href="../functions/#Base.log-Tuple{AbstractManifold, Any, Any}"><code>log(::AbstractManifold, ::Any, ::Any)</code></a> and <code>inverse_retract_shooting!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L296-L306">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.is_default_metric-Tuple{AbstractManifold, AbstractMetric}"><a class="docstring-binding" href="#ManifoldsBase.is_default_metric-Tuple{AbstractManifold, AbstractMetric}"><code>ManifoldsBase.is_default_metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_default_metric(M::AbstractManifold, G::AbstractMetric)</code></pre><p>Return whether an <a href="#ManifoldsBase.AbstractMetric"><code>AbstractMetric</code></a> is the default metric on the manifold <code>M</code> or not.</p><p>If <code>M</code> is a |<code>MetricManifold</code>](@ref) this indicates whether the metric now used is the same as the default one on the wrapped manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L327-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.metric-Tuple{AbstractManifold}"><a class="docstring-binding" href="#ManifoldsBase.metric-Tuple{AbstractManifold}"><code>ManifoldsBase.metric</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">metric(M::MetricManifold)</code></pre><p>Get the metric <span>$g$</span> of the <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a><code>(M)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L375-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.retract-Tuple{MetricManifold, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.retract-Tuple{MetricManifold, Any, Any}"><code>ManifoldsBase.retract</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">retract(M::MetricManifold, p, X)
retract!(M::MetricManifold, q, p, X)</code></pre><p>Compute the retraction on the <a href="#ManifoldsBase.MetricManifold"><code>MetricManifold</code></a> <code>M</code>. Since every retraction is a retraction with respect to any exponential map (here induced by the metric), this method falls back to calling <a href="#ManifoldsBase.retract-Tuple{MetricManifold, Any, Any}"><code>retract</code></a> on the inner manifold. The one exception is the <a href="../retractions/#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>, in which case the method falls back to the default, i.e. to calling <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp(::AbstractManifold, ::Any, ::Any)</code></a> but still on <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L414-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.vector_transport_direction-Tuple{MetricManifold, Any, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.vector_transport_direction-Tuple{MetricManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_direction</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vector_transport_direction(M::MetricManifold, p, X, d)
vector_transport_direction!(M::MetricManifold, Y, p, X, d)</code></pre><p>Compute the vector transport of the tangent vector <code>X</code> at point <code>p</code> in the direction <code>d</code> on the <a href="#ManifoldsBase.MetricManifold"><code>MetricManifold</code></a> <code>M</code>.</p><p>Since a vector transport is usually defined with respect to a retraction, cf. e.g. [<a href="../references/#AbsilMahonySepulchre_2008">AMS08</a>], and the vector transport is closely related to an affine connection, it is to some extent metric dependent. Therefore, this method only falls back to calling its corresponding method on the base manifold, if the metric is the default one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L456-L466">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.vector_transport_to-Tuple{MetricManifold, Any, Any, Any}"><a class="docstring-binding" href="#ManifoldsBase.vector_transport_to-Tuple{MetricManifold, Any, Any, Any}"><code>ManifoldsBase.vector_transport_to</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">vector_transport_to(M::MetricManifold, p, X, d)
vector_transport_to!(M::MetricManifold, Y, p, X, d)</code></pre><p>Compute the vector transport of the tangent vector <code>X</code> at point <code>p</code> to a point <code>q</code> on the <a href="#ManifoldsBase.MetricManifold"><code>MetricManifold</code></a> <code>M</code>.</p><p>Since a vector transport is usually defined with respect to a retraction, cf. e.g. [<a href="../references/#AbsilMahonySepulchre_2008">AMS08</a>], and the vector transport is closely related to an affine connection, it is to some extent metric dependent. Therefore, this method only falls back to calling its corresponding method on the base manifold, if the metric is the default one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/metric.jl#L492-L501">source</a></section></details></article><h2 id="A-manifold-for-validation"><a class="docs-heading-anchor" href="#A-manifold-for-validation">A manifold for validation</a><a id="A-manifold-for-validation-1"></a><a class="docs-heading-anchor-permalink" href="#A-manifold-for-validation" title="Permalink"></a></h2><p><a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a> is a simple decorator using the <a href="../decorator/#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> that ‚Äúdecorates‚Äù a manifold with tests that all involved points and vectors are valid for the wrapped manifold. For example involved input and output paratemers are checked before and after running a function, repectively. This is done by calling <a href="../functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a> or <a href="../functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>is_vector</code></a> whenever applicable.</p><article><details class="docstring" open="true"><summary id="ManifoldsBase.ValidationCotangentVector"><a class="docstring-binding" href="#ManifoldsBase.ValidationCotangentVector"><code>ManifoldsBase.ValidationCotangentVector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationCotangentVector = ValidationFibreVector{CotangentSpaceType}</code></pre><p>Represent a cotangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L200-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.ValidationFibreVector"><a class="docstring-binding" href="#ManifoldsBase.ValidationFibreVector"><code>ManifoldsBase.ValidationFibreVector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationFibreVector{TType&lt;:VectorSpaceType,V,P} &lt;: AbstractFibreVector{TType}</code></pre><p>Represent a tangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>. The original vector of the manifold is stored internally. The corresponding base point of the fibre can be stored as well.</p><p>The <code>TType</code> indicates the type of fibre, for example <a href="../bases/#ManifoldsBase.TangentSpaceType"><code>TangentSpaceType</code></a> or <a href="../bases/#ManifoldsBase.CotangentSpaceType"><code>CotangentSpaceType</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>value::V</code>: the internally stored vector on the fibre</li><li><code>point::P</code>: the point the vector is associated with</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">    ValidationFibreVector{TType}(value, point=nothing)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L164-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.ValidationMPoint"><a class="docstring-binding" href="#ManifoldsBase.ValidationMPoint"><code>ManifoldsBase.ValidationMPoint</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationMPoint{P} &lt;: AbstractManifoldPoint</code></pre><p>Represent a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>. The point is stored internally.</p><p><strong>Fields</strong></p><ul><li><code>value::P</code>: the internally stored point on a manifold</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">    ValidationMPoint(value)</code></pre><p>Create a point on the manifold with the value <code>value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L146-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.ValidationManifold"><a class="docstring-binding" href="#ManifoldsBase.ValidationManifold"><code>ManifoldsBase.ValidationManifold</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationManifold{ùîΩ,M&lt;:AbstractManifold{ùîΩ}} &lt;: AbstractDecoratorManifold{ùîΩ}</code></pre><p>A manifold to add tests to input and output values of functions defined in the interface.</p><p>Additionally the points and tangent vectors can also be encapsulated, cf. <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="#ManifoldsBase.ValidationTangentVector"><code>ValidationTangentVector</code></a>, and <a href="#ManifoldsBase.ValidationCotangentVector"><code>ValidationCotangentVector</code></a>. These types can be used to see where some data is assumed to be from, when working on manifolds where both points and tangent vectors are represented as (plain) arrays.</p><p>Using the <code>ignore_contexts</code> keyword allows to specify a single <code>Symbol</code> or a vector of <code>Symbols</code> Of which contexts to ignore.</p><p>Current contexts are</p><ul><li><code>:All</code>: disable all checks</li><li><code>:Point</code>: checks for points</li><li><code>:Vector</code>: checks for vectors</li><li><code>:Output</code>: checks for output</li><li><code>:Input</code>: checks for input variables</li></ul><p>Using the <code>ignore_functions</code> keyword (dictionary) allows to disable/ignore certain checks within single functions for this manifold. The <code>key</code> of the dictionary has to be the <code>Function</code> to exclude something in. The <code>value</code> is either a single symbol or a vector of symbols with the same meaning as the <code>ignore_contexts</code> keyword, but limited to this function</p><p><strong>Examples</strong></p><ul><li><code>exp =&gt; :All</code> disables <em>all</em> checks in the <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> function</li><li><code>exp =&gt; :Point</code> excludes point checks in the <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> function</li><li><code>exp =&gt; [:Point, :Vector]</code> excludes point and vector checks in the <a href="../functions/#Base.exp-Tuple{AbstractManifold, Any, Any}"><code>exp</code></a> function</li></ul><p>This manifold is a decorator for a manifold, i.e. it decorates a <a href="../types/#ManifoldsBase.AbstractManifold"><code>AbstractManifold</code></a> <code>M</code> with types points, vectors, and covectors.</p><p><strong>Fields</strong></p><ul><li><code>manifold::M</code>: The manifold to be decorated</li><li><code>mode::Symbol</code>: The mode to be used for error handling, either <code>:error</code> or <code>:warn</code></li><li><code>ignore_contexts::AbstractVector{Symbol}</code>: store contexts to be ignored of validation.</li><li><code>ignore_functions::Dict{&lt;:Function,&lt;:Union{Symbol,&lt;:AbstractVector{Symbol}}</code>: store contexts to be ignored with in a function or its mutating variant.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ValidationManifold(M::AbstractManifold; kwargs...)</code></pre><p>Generate the Validation manifold</p><pre><code class="language-julia hljs">ValidationManifold(M::AbstractManifold, V::ValidationManifold; kwargs...)</code></pre><p>Generate the Validation manifold for <code>M</code> with the default values of <code>V</code>.</p><p><strong>Keyword arguments</strong></p><ul><li><code>error::Symbol=:error</code>: specify how errors in the validation should be reported. this is passed to <a href="../functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a> and <a href="../functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>is_vector</code></a> as the <code>error</code> keyword argument. Available values are <code>:error</code>, <code>:warn</code>, <code>:info</code>, and <code>:none</code>. Every other value is treated as <code>:none</code>.</li><li><code>store_base_point::Bool=false</code>: specify whether or not to store the point <code>p</code> a tangent or cotangent vector is associated with. This can be useful for debugging purposes.</li><li><code>ignore_contexts = Vector{Symbol}()</code> a vector to indicate which validation contexts should not be performed.</li><li><code>ignore_functions=Dict{Function,Union{Symbol,Vector{Symbol}}}()</code> a dictionary to disable certain contexts within functions. The key here is the non-mutating function variant (if it exists). The contexts are thre same as in <code>ignore_contexts</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L1-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.ValidationTangentVector"><a class="docstring-binding" href="#ManifoldsBase.ValidationTangentVector"><code>ManifoldsBase.ValidationTangentVector</code></a> ‚Äî <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ValidationTangentVector = ValidationFibreVector{TangentSpaceType}</code></pre><p>Represent a tangent vector to a point on an <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically. This distinguished the value from <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>s vectors of other types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L191-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase._msg-Tuple{ValidationManifold, Any}"><a class="docstring-binding" href="#ManifoldsBase._msg-Tuple{ValidationManifold, Any}"><code>ManifoldsBase._msg</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_msg(str; error=:None, within::Union{Nothing,&lt;:Function} = nothing,
context::Union{NTuple{N,Symbol} where N} = NTuple{0,Symbol}())</code></pre><p>issue a message <code>str</code> according to the mode <code>mode</code> (as <code>@error</code>, <code>@warn</code>, <code>@info</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L242-L247">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase._vMc"><a class="docstring-binding" href="#ManifoldsBase._vMc"><code>ManifoldsBase._vMc</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">_vMc(M::ValidationManifold, f::Function, context::Symbol)
_vMc(M::ValidationManifold, f::Function, context::NTuple{N,Symbol}) where {N}</code></pre><p>Return whether a check should be performed within <code>f</code> and the <code>context</code>(<code>s</code>) provided.</p><p>This function returns false and hence indicates not to check, when</p><ul><li>(one of the) <code>context</code>(<code>s</code>) is in the ignore list for <code>f</code> within <code>ignore_functions</code></li><li>(one of the) <code>context</code>(<code>s</code>) is in the <code>ignore_contexts</code> list</li></ul><p>Otherwise the test is active.</p><p>!!! Note    This function is internal and used very often, co it has a very short name;     <code>_vMc</code> stands for &quot;<code>ValidationManifold</code> check&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L100-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.internal_value-Tuple{Any}"><a class="docstring-binding" href="#ManifoldsBase.internal_value-Tuple{Any}"><code>ManifoldsBase.internal_value</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">internal_value(p)</code></pre><p>Return the internal value of an <a href="#ManifoldsBase.ValidationMPoint"><code>ValidationMPoint</code></a>, <a href="#ManifoldsBase.ValidationTangentVector"><code>ValidationTangentVector</code></a>, or <a href="#ManifoldsBase.ValidationCotangentVector"><code>ValidationCotangentVector</code></a> if the value <code>p</code> is encapsulated as such. Return <code>p</code> if it is already an a (plain) value on a manifold.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L213-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.is_point-Tuple{ValidationManifold, Any}"><a class="docstring-binding" href="#ManifoldsBase.is_point-Tuple{ValidationManifold, Any}"><code>ManifoldsBase.is_point</code></a> ‚Äî <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_point(M::ValidationManifold, p; kwargs...)</code></pre><p>Perform <a href="../functions/#ManifoldsBase.is_point-Tuple{AbstractManifold, Any, Bool}"><code>is_point</code></a> on a <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, where two additional keywords can be used</p><ul><li><code>within=nothing</code> to specify a function from within which this call was issued</li><li><code>context::NTuple{N,Symbol} where N=()</code> to specify one or more contexts, this call was issued in. The context <code>:Point</code> is added before checking whether the test should be performed</li></ul><p>all other keywords are passed on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L583-L595">source</a></section></details></article><article><details class="docstring" open="true"><summary id="ManifoldsBase.is_vector"><a class="docstring-binding" href="#ManifoldsBase.is_vector"><code>ManifoldsBase.is_vector</code></a> ‚Äî <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_vector(M::ValidationManifold, p, X, cbp=true; kwargs...)</code></pre><p>perform <a href="../functions/#ManifoldsBase.is_vector-Tuple{AbstractManifold, Any, Any, Bool, Bool}"><code>is_vector</code></a> on a <a href="#ManifoldsBase.ValidationManifold"><code>ValidationManifold</code></a>, where two additional keywords can be used</p><ul><li><code>within=nothing</code> to specify a function from within which this call was issued</li><li><code>context::NTuple{N,Symbol} where N=()</code> to specify one or more contexts, this call was issued in. The context <code>:Point</code> is added before checking whether the test should be performed</li></ul><p>all other keywords are passed on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaManifolds/ManifoldsBase.jl/blob/b8c72e56dcdd485dc8da7d341a3870925cf0793b/src/ValidationManifold.jl#L608-L620">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vector_transports/">¬´ Vector transports</a><a class="docs-footer-nextpage" href="../metamanifolds/">Meta-Manifolds ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 15 December 2025 18:14">Monday 15 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
